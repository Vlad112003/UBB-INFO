CURS 01A. VERIFICARE ÅI VALIDARE Verificarea ÅŸi validarea sistemlor soft [25 Februarie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut Calitatea produselor soft Stakeholders DefiniÅ£ii ale calitÄƒÅ£ii produselor soft ActivitÄƒÈ›i asociate calitÄƒÈ›ii Verificare ÅŸi validare Defect software Terminologie Costul unui bug software Bug-uri software celebre Bibliografie CALITATEA PRODUSELOR SOFT Stakeholders DefiniÈ›ii ale calitÄƒÅ£ii produselor soft ActivitÄƒÈ›i asociate controlului calitÄƒÈ›ii unui produs soft Stakeholders stakeholder (rom. beneficiar, utilizator) o persoanÄƒ care manifestÄƒ un interes particular pentru succesul sau eÅŸecul unui produs soft . Tipuri de Stakeholders primar/secundar (engl., primary, secondary) : beneficiar primar â€“ direct afectat de succesul sau eÅŸecul produsului; beneficiar secundar â€“ nu este afectat direct de succesul sau eÅŸecul produÅŸului. preferat/nedorit (engl., favored, disfavored) , : beneficiar preferat (avantajat) â€“ produsul este proiectat pentru a fi utilizat de acesta; beneficiar nedorit (dezavantajat) - produsul este proiectat sa creeze dificultÄƒÅ£i Ã®n utilizare; beneficiar neutru â€“ produsul nu este proiectat pentru acesta ÅŸi nu Ã®l poate influenÅ£a; beneficiar ignorat (neglijat) â€“ produsul nu este proiectat pentru fi utilizat de acest tip de utilizator. â€œprodusul soft este conform cu cerinÈ›ele documentateâ€ []: conformitatea cu cerinÈ›ele funcÈ›ionale È™i de performanÅ£Äƒ precizate ÅŸi documentate explicit Ã®n standarde de dezvoltare È™i caracteristicile implicite pe care un produs soft dezvoltat le are; â€œprodusul soft este conform cu cerinÈ›ele reale ale utilizatoruluiâ€ []: conformitatea cu cerinÈ›ele reale ale utilizatorului care pot fi incluse sau nu Ã®n specificaÈ›iile scrise; conformitate cu cerinÈ›ele (nevoile) reale, nu doar cu cerinÅ£ele documentate; â€œprodusul soft este adecvat pentru a fi utilizatâ€ []: satisfiers â€“ orice aspect care Ã®l mulÈ›umeÈ™te pe beneficiar; dissatisfiers â€“ orice aspect care Ã®l nemulÈ›umeÈ™te pe beneficiar; â€œprodusul soft este relevant/important pentru o persoanÄƒâ€ []: calitatea este subiectivÄƒ; un aspect care are relevanÈ›Äƒ/importanÈ›Äƒ Ã®nsemnatÄƒ pentru un utilizator poate fi mai puÈ›in important pentru un alt utilizator din aceeaÅŸi categorie de utilizatori. ActivitÄƒÅ£i asociate calitÄƒÅ£ii Ã®n procesul de dezvoltare, calitatea este abordatÄƒ din perspectiva: procesului ===> asigurarea calitÄƒÅ£ii (engl. quality assurance): Obiectiv: asigurÄƒ respectarea standardelor, planurilor È™i etapelor proceselor de dezvoltare necesare elaborÄƒrii adecvate a produsului cerut; Ãntrebare: Cum se asigurÄƒ calitatea activitÄƒÈ›ilor desfÄƒÈ™urate Ã®n procesul dezvoltare? produsului ===> controlul calitÄƒÅ£ii (engl. quality control): Obiectiv: identificÄƒ deficienÅ£ele Ã®n produsul obÈ›inut; Ãntrebare: Cum se controleazÄƒ calitatea rezultatelor obÈ›inute (e.g., work products) Ã®n urma activitÄƒÈ›ilor desfÄƒÈ™urate? ActivitÄƒÈ›i asociate controlului calitÄƒÈ›ii Analiza staticÄƒ examinarea unor documente (specificaÈ›ii, modele conceptuale, diagrame de clase, cod sursÄƒ, planuri de testare, documentaÈ›ii de utilizare); exemple: activitÄƒÈ›i de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; NU presupune execuÈ›ia propriu-zisÄƒ a programului dezvoltat; Analiza dinamicÄƒ examinarea comportamentului programului cu scopul de a evidenÈ›ia defecÈ›iuni posibile; exemple: tipuri de testare (de regresie, funcÅ£ionalÄƒ, non-funcÅ£ionalÄƒ), niveluri de testare (testare unitarÄƒ, testare de integrare, testare de sistem, testare funcÅ£ionalÄƒ, testare de accpetare); include activitatea de execuÈ›ie propriu- zisÄƒ a programului (testare); VERIFICARE ÅI VALIDARE Verificare Validare Verificare vs. Validare Verificare È™i Validare. DefiniÅ£ie SEI SEI (Software Engineering Institute) [] Verificare procesul prin care se asigurÄƒ cÄƒ produsul este dezvoltat conform cerinÅ£elor, specificaÅ£iilor ÅŸi standardelor; Ã®ntrebare asociatÄƒ: DezvoltÄƒm corect produsul? (Are we building the product right?) Validare procesul prin care se asigurÄƒ cÄƒ produsul dezvoltat satisface cerinÅ£ele utilizatorului; Ã®ntrebare asociatÄƒ: DezvoltÄƒm produsul corect (de care are nevoie clientul)? (Are we building the right product?) Verificare ÅŸi Validare Ã®n modelul V sursa: [] Verificare vs. Validare Verificare stabileÈ™te dacÄƒ rezultatul unei etape de dezvoltare satisface cerinÈ›ele acelei etape; asigurare a consistenÈ›ei, completitudinii, corectitudinii; aplicÄƒ metode de control al calitÄƒÅ£ii; Validare confirmÄƒ cÄƒ produsul satisface cerinÈ›ele de utilizare; se desfÄƒÈ™oarÄƒ spre sfÃ¢rÈ™itul procesului de dezvoltare, cu scopul de a demonstra cÄƒ Ã®ntregul sistem satisface nevoile È™i aÈ™teptÄƒrile; se aplicÄƒ asupra Ã®ntregului sistem, Ã®n contextul real Ã®n care va funcÈ›iona, folosind diferite tipuri de testare. ActivitÄƒÅ£i de Verificare ÅŸi Validare sursa: [] DEFECT SOFTWARE Terminologie CÃ¢nd apare un bug Ã®ntr-un produs soft? De ce apare un bug Ã®n procesul de dezvoltare software? Costul unui bug software Defecte/Buguri software celebre eroare (engl. error, mistake; greÈ™ealÄƒ): o acÈ›iune umanÄƒ care are ca rezultat un defect Ã®n produsul software []; defect (engl. fault, i.e., bug): consecinÈ›Äƒ a unei erori []; un defect poate fi latent: nu cauzeazÄƒ probleme pÃ¢nÄƒ cÃ¢nd nu apar anumite condiÈ›ii (engl. failure triggers) care determinÄƒ execuÈ›ia anumitor linii de cod sursÄƒ; defecÈ›iune (engl. failure): devierea de la comportamentul obiÈ™nuit al unei componente software; apare atunci cÃ¢nd comportamentul observabil al programului nu corespunde specificaÈ›iei sale; procesul de manifestare a unui defect: cÃ¢nd execuÈ›ia programului Ã®ntÃ¢lneÈ™te un defect, acesta provoacÄƒ o defecÈ›iune []; defect (engl. bug, software error) orice aspect al unui produs soft care cauzeazÄƒ reducerea inutilÄƒ È™i inadecvatÄƒ a calitÄƒÈ›ii produsului soft []; constituie o ameninÈ›are asupra imaginii produsului []; exemple: deficienÈ›e de proiectare, greÈ™eli Ã®n documentaÈ›ii, utilizare cu dificultate a programului; totuÈ™i, anumite aspecte ale produsului pot limita calitatea acestuia, dar nu pot fi considerate defecte! exemplu: constrÃ¢ngeri de utilizare precizate sau nu Ã®n specificaÈ›ii; Ãn cadrul acestui curs, orice deficienÈ›Äƒ sau problemÄƒ a produsului soft este denumitÄƒ bug (defect). sinonime pentru bug: engl. variance, problem, inconsistency, error, incident, anomaly [Patton2005]. De ce apare un bug Ã®ntr-un produs soft? Un bug software apare atunci cÃ¢nd cel puÈ›in una din urmÄƒtoarele situaÈ›ii are loc []: Produsul soft nu face ce este precizat Ã®n specificaÈ›ia lui. Produsul soft face ce nu este precizat Ã®n specificaÈ›ie. Produsul soft face ce specificaÈ›ia precizeazÄƒ cÄƒ nu trebuie fÄƒcut. Produsul soft nu face ceea ce specificaÈ›ia ar trebui sÄƒ precizeze. Produsul soft este dificil de Ã®nÈ›eles, greu de utilizat, lent. Testerul pune Ã®n evidenÈ›Äƒ perspectiva utilizatorului final asupra podusului soft, adicÄƒ produsul nu funcÈ›ioneazÄƒ conform aÈ™teptÄƒrilor lui. Ãn ce etapÄƒ a procesului de dezvoltare software apar bug-urile? specificarea cerinÈ›elor: nu se scriu specificaÈ›iile, sunt superficiale, se schimbÄƒ continuu, nu sunt comunicate corespunzÄƒtor Ã®ntregii echipe de dezvoltare; proiectare: sunt superficiale, nu se comunicÄƒ eficient, se modificÄƒ; implementare: complexitatea produsului soft, lipsa documentaÈ›iei (pentru codul sursÄƒ Ã®mbunÄƒtÄƒÈ›it), erori de redactare, presiunea termenului limitÄƒ. Care este etapa de dezvoltare Ã®n care se introduc cele mai multe defecte? CÃ¢t costÄƒ eliminarea unui bug? Care sunt costurile de eliminare a unui bug software? costul eliminÄƒrii bug-urilor creÈ™te pe mÄƒsurÄƒ ce produsul soft este dezvoltat. BUG-URI SOFTWARE CELEBRE Activitate de seminar 9+ bug-uri software celebre Activitate de seminar. Bug Poster Bug Poster CE? DescrieÅ£i un bug faimos (celebru) Ã®ntr-un poster (1 paginÄƒ A4, portret/landscape, Ro/En); CUM? Elementele posterului: denumirea bug-ului, anul apariÅ£iei bug-ului, descrierea contextului (a aplicaÅ£iei) Ã®n care a apÄƒrut bug-ul, descrierea bug-ului (pe scurt), consecinÅ£ele (impactul) apariÅ£iei bug-ului din diferite perspective (costuri de depanare, scÄƒderea credibilitÄƒÈ›ii, etc.), o imagine sugestivÄƒ a bug-ului; CINE? Perechi de 2 studenÅ£i; Ã®nscrierea se face Ã®n fiÅŸierul de la acest ; la completarea datelor, studenÅ£ii sunt rugaÅ£i sÄƒ se asigure cÄƒ bug-ul propus nu este ales deja de alÅ£i colegi care apar Ã®n listÄƒ; CÃ‚ND? Posterul va fi prezentat Ã®n timpul orelor de seminar la grupa din care fac parte membrii echipei; maxim 2 postere/seminar; CÃ‚T? timp alocat: maxim 5 minute/poster; Ã®nainte de prezentare, poster-ul va fi Ã®ncÄƒrcat Ã®n MS Teams, Ã®n channel-ul BugPosters, secÈ›iunea Files; DE CE? StudenÅ£ii primesc maxim 2 puncte de activitate pentru activitatea Bug Poster, inclusÄƒ Ã®n nota de la seminar. Naveta spaÈ›ialÄƒ Mariner 1 â€“ 1962 naveta spaÈ›ialÄƒ Mariner 1 a deviat de la traiectoria ei la scurt timp dupÄƒ lansarea spre planeta Venus; a fost distrusÄƒ la 293 secunde dupÄƒ lansare; cauza: eroare la scrierea unei instrucÈ›iuni Ã®n limbajul FORTRAN, determinÃ¢nd calculul eronat al traiectoriei; cost: 18.5 milioane $ DO 10 I=1.10 ..... compilatorul Fortran ignorÄƒ spaÅ£iile, iar instrucÅ£iunea a fost consideratÄƒ corectÄƒ; astfel: DO10I = 1.10 ---> se iniÅ£ializeazÄƒ o variabilÄƒ nedeclaratÄƒ intenÅ£ia programatorului a fost: DO 10 I = 1, 10 ...... Tratamente Ã®mpotriva cancerului â€“ 1985 dispozitivul Therac-25 fost folosit Ã®n terapia prin radiaÈ›ii; cauza: programul a calculat greÈ™it doza de radiaÈ›ii pe baza datelor de intrare, unii pacienÈ›i primind o dozÄƒ de cÃ¢teva ori mai mare decÃ¢t cea normalÄƒ; cost: 3 pacienÈ›i decedaÈ›i, 3 rÄƒniÈ›i prin iradiere. Sistemul de apÄƒrare american anti-rachetÄƒ â€“ 1991 sistemul american de apÄƒrare antirachetÄƒ MIM-104 Patriot situat Ã®n Arabia SauditÄƒ nu a reuÈ™it sÄƒ detecteze atacuri cu rachete Scud irakiene; cauza: o eroare de rotunjire la ceasul sistemului (un sfert de secundÄƒ) s-a cumulat, astfel Ã®ncÃ¢t la 14 ore, sistemul de urmÄƒrire Ã®È™i pierdea acurateÈ›ea, devenind incapabil sÄƒ localizeze È™i sÄƒ intercepteze rachetele; cost: Ã®n atacul asupra unei cazarme din Dhahran au decedat 28 soldaÈ›i americani; eroarea fusese deja remediatÄƒ de experÈ›ii armatei americane, iar noua versiune a softului urma sÄƒ ajungÄƒ cu o zi mai tÃ¢rziu. Jocul asociat desenului animat Disney Lion King â€“ 1995 la prima apariÈ›ie pe piaÈ›Äƒ a companiei Disney cu un joc pentru copii - The Lion King Animated Storybook - unii utilizatori nu au reuÈ™it sÄƒ foloseascÄƒ produsul soft achiziÈ›ionat; cauza: compania Disney nu a testat produsul pe diferite modele de calculatoare personale existente pe piaÈ›Äƒ; cost: credibilitatea companiei, schimbarea unitÄƒÈ›ilor CD-ROM. Naveta spaÈ›ialÄƒ Mars Climate Orbiter â€“ 1998 obiectiv: orbitarea planetei Marte È™i transmiterea informaÈ›iilor despre condiÈ›iile meteo; eveniment: dupÄƒ o cÄƒlÄƒtorie de 286 zile de pe PÄƒmÃ¢nt, la intrarea Ã®n atmosfera planetei Marte, motoarele au deviat traiectoria navetei; rezultat: dezintegrarea navetei Ã®n atmosferÄƒ; cauza:	douÄƒ	dintre	echipele	implicate	Ã®n	dezvoltarea	aplicaÈ›iei	foloseau	sisteme	de mÄƒsurare a distanÈ›ei diferite, imperial (inch, feet) È™i cel metric (m, km). Naveta spaÈ›ialÄƒ Mars Polar Lander â€“ 1998 obiectiv: studierea solului È™i a climei din regiunea Planum Australe de pe Marte; pentru mecanismul de identificare a momentului cÃ¢nd mototarele trebuie sÄƒ fie oprite, NASA nu a folosit radare costisitoare, ci un senzor pe talpa picioarelor navetei, care determina oprirea alimentÄƒrii cu combustibil; eveniment: la intrarea Ã®n atmosfera planetei Marte, programul a interpretat vibraÈ›iile navetei â€“ cauzate de turbulenÈ›ele din atmosferÄƒ â€“ cÄƒ aceasta ar fi aterizat È™i a oprit motoarele navetei; rezultat: prÄƒbuÅŸirea navetei de Ã®nÄƒlÅ£imea de 40m faÅ£Äƒ de suprafaÅ£a planetei Marte; cauza: testare incompletÄƒ â€“ procedura de aterizare a fost Ã®mpÄƒrÈ›itÄƒ Ã®n douÄƒ etape, care au fost testate independent; nu s-a realizat testarea de integrare. Knight Capital Group â€“ 2012 casa de brokeraj Knight Capital Group a suferit o pierdere consistentÄƒ la bursa din New York; cauza: sistemul a introdus pe bursa de la New York tranzacÈ›ii care au provocat fluctuaÈ›ii violente ale preÈ›urilor multor acÈ›iuni; cost: pierderi de 440 milioane $ Ã®n doar 45 minute. Termostatul Nest â€“ 2016 termostatul Nest Learning Thermostat (achiziÅ£ionat de Google Ã®n 2014 pentru 3.2 mld $) nu a permis controlul temperaturii Ã®n locuinÅ£ele Ã®n care a fost instalat â€“ imposibilitatea de a-l utiliza pentru Ã®ncÄƒlzire sau prepararea apei calde Ã®n timpul unui weekend friguros; cauza: update-ul de firmware pentru device Ã®mpreunÄƒ cu existenÅ£a unor filtre necurÄƒÅ£ate ÅŸi centrale termice incompatibile; aceÅŸti factori au dus la descÄƒrcarea bateriei device-ului. Beresheet (â€In the beginning...â€) â€“ 2019 Ã®n 11 aprilie 2019 a avut loc tentativa eÅŸuatÄƒ a Israelului de a trimite pe LunÄƒ o naveta spaÅ£ialÄƒ fÄƒrÄƒ oameni a bord; cauza: un bug la sistemul de control al motorului care l-a Ã®mpiedicat sÄƒ reducÄƒ viteza Ã®n timpul aselenizÄƒrii; inginerii au Ã®ncercat sa corecteze bug-ul de la distanÅ£Äƒ prin restartarea motorului, dar la preluarea controlului asupra motorului era prea tÃ¢rziu pentru ca Beresheet sa poatÄƒ fi Ã®ncetinitÄƒ ÅŸi s-a dezintegrat la prÄƒbuÅŸire. ReferinÈ›e bibliografice [Firesmith2015] Donald Firesmith, Four Types of Shift Left Testing, [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [NASA] NASA, . [Crosby1980] Philip B. Crosby, Quality Is Free, Signet Shakespeare, 1980. [Juran1998] A. Blanton Godfrey, Joseph Juran, JURANS QUALITY HANDBOOK, McGraw-Hill, 1998. [Weinberg1992] Gerald Weinberg, Quality Software Management , Vol. 1: Systems Thinking, Dorset House Publishing, 1992. [Pressman2000] Roger S. Pressman, Software Engineering: A Practitionerâ€™s Approach, McGraw-Hill, Inc., 2000. [BBST] BBST â€“ Bug Advocacy Course, (. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [Easterbrook2010] S. Easterbrook, Software Testing, . [CFI2022] Stakeholders, . [StakeholderMap2019] Stakeholders, . [GauseWeinberg2011] Donald C. Gause, Gerald M. Weinberg, Exploring Requirements: Quality Before Design, Dorset House, 2011. [KanerBach2005] Kaner, C., Bach, J., Requirements Analysis for Test Documentation, . CURS 01B. INSPECTARE Verificarea ÅŸi validarea sistemelor soft [25 Februarie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut Calitatea produselor soft ActivitÄƒÈ›i asociate controlului calitÄƒÈ›ii Analiza staticÄƒ. Clasificare Metode bazate pe factorul uman DefiniÈ›ie. MotivaÈ›ie. Caracteristici Inspectare Fagan Walkthroughs Technical Review Pair-Programming Pentru examen... Bibliografie CALITATEA PRODUSELOR SOFT ActivitÄƒÈ›i asociate controlului calitÄƒÈ›ii unui produs soft Analiza staticÄƒ. Clasificare ActivitÄƒÅ£i asociate calitÄƒÅ£ii Ã®n procesul de dezvoltare, calitatea este abordatÄƒ din perspectiva: procesului ===> asigurarea calitÄƒÅ£ii (engl. quality assurance): Obiectiv: asigurÄƒ respectarea standardelor, planurilor È™i etapelor proceselor de dezvoltare necesare elaborÄƒrii adecvate a produsului cerut; Ãntrebare: Cum se asigurÄƒ calitatea activitÄƒÈ›ilor desfÄƒÈ™urate Ã®n procesul dezvoltare? produsului ===> controlul calitÄƒÅ£ii (engl. quality control): Obiectiv: identificÄƒ deficienÅ£ele Ã®n produsul obÈ›inut; Ãntrebare: Cum se controleazÄƒ calitatea rezultatelor obÈ›inute (e.g., work products) Ã®n urma activitÄƒÈ›ilor desfÄƒÈ™urate? AnalizÄƒ staticÄƒ (static testing) examinarea unor documente (specificaÈ›ii, modele conceptuale, diagrame de clase, cod sursÄƒ, planuri de testare, documentaÈ›ii de utilizare); exemple: activitÄƒÈ›i de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; se pot baza pe factorul uman (reviews) sau utilizarea tool-urilor (analiza staticÄƒ). AnalizÄƒ dinamicÄƒ (dynamic testing) examinarea comportamentului programului cu scopul de a evidenÈ›ia defecÈ›iuni posibile; exemple: tipuri de testare (de regresie, funcÅ£ionalÄƒ, non-funcÅ£ionalÄƒ), niveluri de testare (testare unitarÄƒ, testare de integrare, testare de sistem, testare funcÅ£ionalÄƒ, testare de acceptare); se bazeazÄƒ Ã®ntotdeauna pe execuÅ£ia programului. AnalizÄƒ staticÄƒ (static testing) permit identificarea mai multor erori (greÅŸeli) care pot fi corectate simultan; NU presupune execuÈ›ia propriu-zisÄƒ a programului dezvoltat; AnalizÄƒ dinamicÄƒ (dynamic testing) sugereazÄƒ doar un simptom, fiecare eroare identificatÄƒ fiind eliminatÄƒ individual; include activitatea de execuÈ›ie propriu-zisÄƒ a programului (testare); poate sÄƒ evidenÅ£ieze o defecÅ£iune doar Ã®n anumite situaÅ£ii. AnalizÄƒ staticÄƒ preconcepÅ£ie (anii â€™60) â€“ â€singura modalitate de a verificare a unui program este execuÅ£ia pe calculatorâ€ [, Cap.3]; se presupunea cÄƒ un program este scris doar pentru execuÈ›ia de cÄƒtre calculator È™i nu este util È™i necesar sÄƒ fie citit È™i Ã®nÈ›eles de o persoanÄƒ, e.g., programator, tester; metode de analizÄƒ staticÄƒ bazate pe: factorul uman (engl. human-based testing, HbT); instrumente specializate (engl. computer-based testing, CbT). AnalizÄƒ staticÄƒ. Clasificare metode de analizÄƒ staticÄƒ bazate pe: factorul uman (engl. human-based testing, HbT), i.e., reviews: formale: inspectare Fagan, technical review, walkthroughs; informale: buddy check, pairing, pair review, over-the-shoulder, e-mail pass-around; instrumente specializate (engl. computer-based testing, CbT), i.e., static analysis: tool-assisted: style checker, corecteness checker; metode hibride: pair-programming. METODE BAZATE PE FACTORUL UMAN DefiniÈ›ie. MotivaÅ£ie. Obiective Avantaje È™i dezavantaje. HbT vs CbT Inspectare Walhthroughs Pair-Programming Metode bazate pe factorul uman. DefiniÅ£ie metodÄƒ HbT [, ] verificare efectuatÄƒ de o persoanÄƒ sau un grup persoane la sfÃ¢rÈ™itul unei etape a procesului de dezvoltare È™i Ã®nainte de a demara urmÄƒtoarea fazÄƒ de dezvoltare; exemplu: activitate: inspectarea codului sursÄƒ; se efectueazÄƒ dupÄƒ etapa de implementare È™i Ã®nainte de Ã®nceperea testÄƒrii. Metode HbT. Obiective. MotivaÈ›ie obiective identificarea defectelor; motivaÅ£ie utilizarea metodelor HbT contribuie la creÈ™terea productivitÄƒÅ£ii ÅŸi a gradului de Ã®ncredere cÄƒ rezultatul obÅ£inut Ã®ndeplineÅŸte cerinÅ£ele: costul de corectare (eliminare) al defectelor creÅŸte odatÄƒ cu parcurgerea etapelor de dezvoltare a softului; modificarea comportamentului programatorilor la demararea analizei dinamice, i.e., la depanare se introduc mai multe bug-uri. Metode HbT. Avantaje È™i dezavataje Avantaje sunt implicate Ã®n proces ÅŸi alte persoane pe lÃ¢ngÄƒ autorul documentului verificat; permite localizarea defectelor; identificÄƒ Ã®ntre 30% ÅŸi 70% din bug- urile de proiectare ÅŸi implementare ale produselor soft. Dezavantaje nu sunt eficiente la identificarea erorilor majore de proiectare; nu pot evidenÅ£ia situaÅ£ii excepÅ£ionale care apar Ã®n utilizarea propriu-zisÄƒ a softului. INSPECTARE FAGAN DefiniÈ›ie. Caracteristici Echipa de inspectare. AtribuÅ£iile membrilor ActivitÄƒÅ£i de inspectare Checklists. DefiniÅ£ie. MotivaÅ£ie. Tipuri de checklists Avantaje Inspectare Fagan. DefiniÈ›ie. Caracteristici 1976 â€“ Fagan [] introduce la IBM procesul de inspectare; Inspectare proces structurat prin care se Ã®ncearcÄƒ identificarea defectelor din documentele elaborate pe parcursul etapelor de dezvoltare a softului, pe baza unor criterii prestabilite; Caracteristici echipa de inspectare (4 membri): moderator, autor, secretar, prezentator; activitÄƒÅ£i de inspectare (6 etape): planificarea, prezentarea, pregÄƒtirea, ÅŸedinÅ£a de analizÄƒ, corectarea, reinspectarea; tipuri de erori cÄƒutate: checklists, adaptate tipului de document inspectat; timp de desfÄƒÅŸurare: 90-120 minute. Echipa de inspectare. AtribuÅ£iile membrilor moderator distribuie materialele ÅŸi planificÄƒ sesiunile de inspectare; conduce sesiunea de inspectare; urmÄƒreÅŸte modul Ã®n care sunt corectate erorile; autorul documentului inspectat (analist, proiectant, programator, tester); rÄƒspunde la Ã®ntrebÄƒrile adresate de membrii echipei, clarificÄƒ nelÄƒmuririle semnalate de cÄƒtre aceÅŸtia; participÄƒ la discuÅ£iile purtate Ã®n timpul ÅŸedinÅ£ei de analizÄƒ; remediazÄƒ defecÅ£iunile constatate; secretar redacteazÄƒ concluziile ÅŸedinÅ£ei de analizÄƒ; Ã®nregistreazÄƒ defectele semnalate ÅŸi problemele discutate Ã®ntr-un document (raport de inspectare); prezentator (reader) citeÅŸte Ã®n cadrul ÅŸedinÅ£ei de analizÄƒ pÄƒrÅ£i ale documentului inspectat; inspectori â€“ cu excepÅ£ia autorului, toÅ£i ceilalÅ£i sunt consideraÅ£i inspectori; analizeazÄƒ documentul primit cu scopul de a identifica cÃ¢t mai multe defecte (bug-uri). planificarea (engl. planning) moderatorul alege membrii echipei de inspectare; distribuie materialele tuturor membrilor echipei ÅŸi atribuie sarcini de inspectare; verificÄƒ dacÄƒ documentul care trebuie inspectat este complet ÅŸi acceptabil pentru a fi inspectat; prezentarea (engl. overview) â€“ nu este obligatorie se prezentÄƒ detaliile materialului inspectat tuturor membrilor echipei de inspectare; moderatorul poate decide dacÄƒ este necesarÄƒ etapa de prezentare sau se trece direct la pregÄƒtirea individualÄƒ; pregÄƒtirea individualÄƒ (engl. preparation) citirea atentÄƒ ÅŸi Ã®nÅ£elegerea documentului primit pentru inspectare; inspectorii reÅ£in toate observaÅ£iile critice ÅŸi formuleazÄƒ Ã®ntrebÄƒri referioare la aspectele care nu sunt clare. ÅŸedinÅ£a de inspectare (engl. inspection meeting) se discutÄƒ observaÅ£iile critice ale fiecÄƒrui inspector; secretarul noteazÄƒ observaÅ£iile considerate prin consens ca fiind defecte ÅŸi ulterior redacteazÄƒ concluziile inspectÄƒrii; concluziile inspectÄƒrii sunt predate autorului documentului inspectat pentru a corecta greÅŸelile; corectarea (engl. rework) autorul efectueazÄƒ modificÄƒrile necesare ÅŸi corecteazÄƒ erorile; reinspectarea (engl. follow-up) se verificÄƒ dacÄƒ modificÄƒrile efectuate au eliminat erorile; se poate reduce la o Ã®ntÃ¢lnire Ã®ntre autor ÅŸi moderator. Checklists. DefiniÅ£ie. MotivaÅ£ie. Tipuri de checklists checklist = listÄƒ cu defecte frecvent Ã®ntÃ¢lnite Ã®ntr-un anumit tip de document; motivaÅ£ie obiectivul inspectÄƒrii: identificarea defectelor; Ã®n raport cu documentul analizat, se urmÄƒreÅŸte identificarea unor bug-uri specifice; tipuri de checklists pentru inspectarea: documentelor cu cerinÈ›ele aplicaÈ›iei; documentelor cu arhitectura aplicaÈ›iei; codului sursÄƒ; documentelor corespunzÄƒtoare testÄƒrii (proiectarea testelor, date de testare alese). Fiecare checklist conÅ£ine aspecte particulare documentelor inspectate ÅŸi sunt rezultatul experienÅ£ei acumulate Ã®n identificarea greÅŸelilor Ã®ntÃ¢lnite frecvent Ã®n desfÄƒÅŸurarea unor etape de dezvoltare software. Inspectare Fagan. Avantaje avantaje permite descoperirea defectelor devreme; reducere costul ÅŸi timpul de dezvoltare; metodÄƒ de grup â€“ membrii echipei conlucreazÄƒ; modalitate de Ã®nvÄƒÅ£are la nivelului echipei; stabileÅŸte sursa defecÅ£iunii, nu oferÄƒ doar indicii referitoare la existenÅ£a lor, e.g., testarea; eliminÄƒ stresul depanÄƒrii Ã®ntr-un timp foarte scurt. Inspectare vs. Testare [] identificarea, localizarea ÅŸi eliminarea defectului; abordare aplicatÄƒ Ã®n douÄƒ etape (individual ÅŸi apoi Ã®n grup); checklists se focalizeazÄƒ pe anumite pÄƒrÅ£i ale documentului care sunt predispuse la introducerea de defecte pe parcursul dezvoltÄƒrii softului. WALKTHROUGHS DefiniÅ£ie. Caracteristici Walkthroughs vs Inspectare Walkthroughs. DefiniÈ›ie. Caracteristici walkthroughs [] procesul prin care se Ã®ncearcÄƒ identifcarea defectelor din documentele elaborate pe parcursul etapelor de dezvoltare a softului sub Ã®ndrumarea autorului documentului; caracteristici [, ] echipa de realizare (3-5 membri) : secretar, inspectori ÅŸi moderator (autorul documentului inspectat, i.e., analist, proiectant, programator, tester); activitÄƒÅ£ile de walkthrough (4 etape): planning, meeting, rework, follow-up; aplicÄƒ tehnici de identificare a erorilor diferite de inspectarea Fagan, i.e., nu se folosesc checklists; timp de realizare: 90-120 minute. Walkthroughs vs Inspectare Fagan Walkthroughs activitate mai puÅ£in riguroasÄƒ; echipa este formatÄƒ din 3-5 membri; se desfÄƒÅŸoarÄƒ Ã®n 4 etape; nu are pretenÅ£ia identificÄƒrii tuturor defectelor; autorul conduce echipa de walkthrough; se folosesc scenarii prestabilite. Inspectare Fagan activitate riguroasÄƒ; echipa este formatÄƒ din 4 membri; se desfÄƒÅŸoarÄƒ Ã®n 6 etape; identificÄƒ defectele des Ã®ntÃ¢lnite; moderatorul conduce echipa de inspectare; foloseÅŸte checklists pentru identificarea defectelor. TECHNICAL REVIEW DefiniÅ£ie. Caracteristici Technical review vs Inspectare Technical Review. DefiniÈ›ie. Caracteristici technical review [] tip de review formal realizat de o echipÄƒ formatÄƒ din personal calificat tehnic care examineazÄƒ conformitatea unui document (work product) cu scopul pentru care este utilizat ÅŸi identificÄƒ diferenÅ£ele faÅ£Äƒ de specificaÅ£ii ÅŸi standarde; caracteristici echipa de realizare (3-5 membri) : secretar, inspectori, moderator (conduce echipa) ÅŸi autorul documentului inspectat (toÅ£i fiind persoane calificate Ã®n acelaÅŸi domeniu ÅŸi fiind considerate peer reviewers faÅ£Äƒ de autor); autorul nu este ÅŸi secretar; activitÄƒÅ£ile de technical review (3-4 etape): planning, preparation (obligatoriu), meeting (opÅ£ional), rework; timp de realizare: 60-90 minute. Technical Review vs Inspectare Fagan Technical Review activitate mai puÅ£in riguroasÄƒ; echipa este formatÄƒ din 3-5 membri; se desfÄƒÅŸoarÄƒ Ã®n 4 etape; obiective: identificarea unui consens, identificarea posibilelor defecte, identificarea de idei noi ÅŸi motivarea autorului sÄƒ Ã®mbunÄƒtÄƒÅ£eascÄƒ documentele elaborate folosind implementÄƒri alternative; utilizarea checklists este opÅ£ionalÄƒ. Inspectare Fagan activitate riguroasÄƒ; echipa este formatÄƒ din 4 membri; se desfÄƒÅŸoarÄƒ Ã®n 6 etape; obiective: evaluarea calitÄƒÅ£ii, identificÄƒ defectele des Ã®ntalnite; foloseÅŸte checklists pentru identificarea defectelor. INFORMAL REVIEW DefiniÅ£ie. Caracteristici Informal Review vs Inspectare Informal Review. DefiniÈ›ie. Caracteristici informal review [] se realizeazÄƒ fÄƒrÄƒ o procedurÄƒ formalÄƒ sau documentatÄƒ; exemple: buddy check, pairing, pair review, over-the-shoulder, e-mail pass-around. caracteristici realizare Ã®n pereche (2 persoane) sau echipe (>2 persoane): autorul, inspectori (cel puÅ£in unul, toÅ£i sunt peer reviewers faÅ£Äƒ de autor); activitÄƒÅ£ile asociate unui review informal (1-2 etape): meeting (opÅ£ionalÄƒ), rework; timp de realizare: 15-60 minute. Informal Review vs Inspectare Fagan Informal Review activitate se scurtÄƒ duratÄƒ, puÅ£in riguroasÄƒ; perechi (autor, inspector) sau echipe de membri; se desfÄƒÅŸoarÄƒ Ã®n 1-2 etape; obiective: identificarea posibilelor defecte, identificarea de idei noi, rezolvarea unor probleme minore; inspectorul este un coleg; utilizarea checklists este opÅ£ionalÄƒ, rezultatele se pot documenta; gradul de utilitate depinde de inspector; utilizatÄƒ frecvent metodologiile Agile. Inspectare Fagan activitate riguroasÄƒ; echipa este formatÄƒ din 4 membri; se desfÄƒÅŸoarÄƒ Ã®n 6 etape; obiective: evaluarea calitÄƒÅ£ii, identificÄƒ defectele des Ã®ntalnite; moderatorul conduce echipa de inspectare; foloseÅŸte checklists pentru identificarea defectelor. PAIR-PROGRAMMING DefiniÅ£ie. Caracteristici Pair-Programming. DefiniÈ›ie. Caracteristici pair-programming metodÄƒ de elaborare a programelor, Ã®n care douÄƒ persoane lucreazÄƒ Ã®mpreunÄƒ; caracteristici combinÄƒ activitÄƒÅ£ile: inspectarea codului ÅŸi implementarea (codificarea); programatorii alterneazÄƒ rolurile; activitÄƒÅ£i de inspectare: nu sunt determinate de checklists; se bazeazÄƒ pe Ã®mpÄƒrtÄƒÅŸirea aceloraÅŸi principii de programare ÅŸi a unui stil de programare asemÄƒnÄƒtor; timp de desfÄƒÅŸurare: durata unei zile normale de muncÄƒ, fÄƒrÄƒ exces de ore suplimentare sau presiunea unui program de lucru strict; nu existÄƒ mediatori, iar responsabilitatea pentru atmosfera de lucru deschisÄƒ ÅŸi non-agresivÄƒ depinde de programatori. PENTRU EXAMEN... Pentru examen... concepte, caracteristici, asemÄƒnÄƒri ÅŸi diferenÅ£e: verificare, validare; verificare vs. validare; eroare, defect/bug, defecÅ£iune; eroare vs. defect/bug vs. defecÅ£iune; stakeholders, calitate, QA, QC; analiza staticÄƒ vs analiza dinamicÄƒ; HbT, motivaÅ£ie; inspectare Fagan, walkthroughs, technical review, informal review: descriere, rolurile membrilor echipei, activitÄƒÅ£ile asociate ÅŸi descrierea lor, avantaje; pair-programming: caracteristici, avantaje. Cursul urmÄƒtor... Testare modele folosite Ã®n testare; planuri de testare; cazuri de testare; Technici de testare Black-box Ã®mpÄƒrÅ£irea Ã®n clase de echivalenÅ£Äƒ; analiza valorilor limitÄƒ; Testing Management Tool â€“ TestLink prezentare tool. ReferinÈ›e bibliografice [Crosby1980] Philip B. Crosby, Quality Is Free, Signet Shakespeare, 1980. [Juran1998] A. Blanton Godfrey, Joseph Juran, JURANS QUALITY HANDBOOK, McGraw-Hill, 1998. [Weinberg1992] Gerald Weinberg, Quality Software Management , Vol. 1: Systems Thinking, Dorset House Publishing, 1992. [Pressman2000] Roger S. Pressman, Software Engineering: A Practitionerâ€™s Approach, McGraw-Hill, Inc., 2000. [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Fagan1976] M. E. Fagan, Design and code inspections to reduce errors in program development, IBM Systems Journal, pages 182â€“211, 1976. [Collard2003] J. F. Collard, I. Burnstein. Practical Software Testing. Springer-Verlag New York, Inc., 2003. [Yourdon1979] E. Yourdon, Structured Walkthroughs, Prentice-Hall,Englewood Cliffs, NJ, 1979. [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Young2008] M. Pezzand, M. Young. Software Testing and Analysis: Process, Principles and Techniques. John Wiley and Sons, 2008. [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [TechReview2019] Cania Consulting, Informal and formal testing reviews, CURS 02A. TESTARE Verificarea ÅŸi validarea sistemelor soft [04 Martie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut Evaluarea calitÄƒÈ›ii unui produs soft ActivitÄƒÅ£i asociate calitÄƒÅ£ii Controlul calitÄƒÅ£ii. ActivitÄƒÅ£i asociate Metode de verificare È™i validare Testare Program. Program testat DefiniÈ›ii ale testÄƒrii Caz de testare. DefiniÅ£ii. Caracteristici Tipuri de testare Principii de testare. Axiome de testare Procesul de testare ÃntrebÄƒri fundamentale ActivitÄƒÈ›i ale procesului de testare Bibliografie EVALUAREA CALITÄ‚ÈšII UNUI PRODUS SOFT ActivitÄƒÅ£i asociate calitÄƒÅ£ii Controlul calitÄƒÅ£ii. ActivitÄƒÅ£i asociate Metode de verificare È™i validare ActivitÄƒÅ£i asociate calitÄƒÅ£ii Ã®n procesul de dezvoltare, calitatea este abordatÄƒ din perspectiva: procesului ===> asigurarea calitÄƒÅ£ii (engl. quality assurance): Obiectiv: asigurÄƒ respectarea standardelor, planurilor È™i etapelor proceselor de dezvoltare necesare elaborÄƒrii adecvate a produsului cerut; Ãntrebare: Cum se asigurÄƒ calitatea activitÄƒÈ›ilor desfÄƒÈ™urate Ã®n procesul dezvoltare? produsului ===> controlul calitÄƒÅ£ii (engl. quality control): Obiectiv: identificÄƒ deficienÅ£ele Ã®n produsul obÈ›inut; Ãntrebare: Cum se controleazÄƒ calitatea rezultatelor obÈ›inute (e.g., work products) Ã®n urma activitÄƒÈ›ilor desfÄƒÈ™urate? AnalizÄƒ staticÄƒ (static testing) examinarea unor documente (specificaÈ›ii, modele conceptuale, diagrame de clase, cod sursÄƒ, planuri de testare, documentaÈ›ii de utilizare); exemple: activitÄƒÈ›i de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; se pot baza pe factorul uman (reviews) sau utilizarea tool-urilor (analiza staticÄƒ). AnalizÄƒ dinamicÄƒ (dynamic testing) examinarea comportamentului programului cu scopul de a evidenÈ›ia defecÈ›iuni posibile; exemple: tipuri de testare (de regresie, funcÅ£ionalÄƒ, non-funcÅ£ionalÄƒ), niveluri de testare (testare unitarÄƒ, testare de integrare, testare de sistem, testare funcÅ£ionalÄƒ, testare de acceptare); se bazeazÄƒ Ã®ntotdeauna pe execuÅ£ia programului. AnalizÄƒ staticÄƒ (static testing) permit identificarea mai multor erori (greÅŸeli) care pot fi corectate simultan; NU presupune execuÈ›ia propriu-zisÄƒ a programului dezvoltat; AnalizÄƒ dinamicÄƒ (dynamic testing) sugereazÄƒ doar un simptom, fiecare eroare identificatÄƒ fiind eliminatÄƒ individual; include activitatea de execuÈ›ie propriu-zisÄƒ a programului (testare); poate sÄƒ evidenÅ£ieze o defecÅ£iune doar Ã®n anumite situaÅ£ii. Metode de Verificare ÅŸi Validare sursa: [] TESTARE Program. Program testat Testare. DefiniÈ›ii Caz de testare. DefiniÅ£ii. Caracteristici Tipuri de testare Principii de testare. Axiome de testare Program. DefiniÅ£ie program (engl. computer program, software application, software product): listÄƒ de instrucÅ£iuni sau o mulÅ£ime de metode sau module care permit execuÅ£ia de cÄƒtre un calculator; un program este o comunicare Ã®ntre persoane ÅŸi calculatoare care sunt separate Ã®n timp ÅŸi spaÅ£iu ÅŸi conÅ£ine instrucÅ£iuni care sunt executate de cÄƒtre calculator. [BBST2010] Program testat. DefiniÅ£ie program testat (engl. software under test, SUT): â‰ˆ funcÅ£ie matematicÄƒ; P : D --> R, unde D â€“ mulÅ£imea datelor de intrare; R â€“ mulÅ£imea datelor de ieÅŸire aÅŸteptate. Testare. DefiniÈ›ii. Caracteristici semnaleazÄƒ prezenÈ›a defectelor unui program, fÄƒrÄƒ a garanta absenÈ›a acestora [Dijkstra1969]. procesul de execuÈ›ie al unui program cu scopul de a identifica erori []. observarea comportÄƒrii unui program Ã®n mai multe execuÈ›ii []. investigaÅ£ie tehnicÄƒ È™i empiricÄƒ realizatÄƒ cu scopul de a oferi beneficiarilor testÄƒrii informaÈ›ii referitoare la programul testat []. Testarea este un proces distructiv; se poate finaliza cu succes (passed) sau eÅŸec (failed). Caz de testare. DefiniÅ£ie caz de testare (engl. test case) â€“ mulÈ›ime de date de intrare, condiÈ›ii de execuÈ›ie È™i rezultate aÈ™teptate, proiectate cu un anumit scop (e.g., cum ar fi parcurgerea unui drum particular Ã®n execuÈ›ia programului sau pentru a verifica respectarea unei cerinÈ›e specifice) []; o interogare adresatÄƒ de tester programului testat ; este relevant obiectivul informaÅ£ional, i.e., informaÅ£ia pe care o descoperim prin testare, e.g., testul este passed sau failed, timpul de execuÅ£ie asociat testului este foarte mare. notaÈ›ie: (i , r), i Ïµ D, r Ïµ R; pentru intrarea i se aÈ™teaptÄƒ sÄƒ se obÈ›inÄƒ rezultatul r. Tipuri de testare. DefiniÅ£ii testare exhaustivÄƒ (testare completÄƒ, engl. exhaustive testing, complete testing): testare cu toate cazurile de testare posibile, folosind toate datele È™i scenariile de utilizare posibile; dacÄƒ D este finit atunci P se poate executa pentru fiecare i Ïµ D; Ã®n majoritatea situaÈ›iilor D nu este finit, deci testarea exhaustivÄƒ nu este posibilÄƒ È™i nici eficace; testare selectivÄƒ (engl. selective testing): testare cu o submulÈ›ime de cazuri de testare; dacÄƒ D nu este finit, atunci se aleg o parte din elementele i , unde i Ïµ S, SâŠ‚D . depanare (engl. debugging, bug fixing): proces de localizare È™i eliminare al unui bug care a fost evidenÈ›iat prin testarea programului; se formuleazÄƒ ipoteze asupra comportamentului programului, se corecteazÄƒ defectele È™i apoi se reia procesul de testare. Principii de testare [] [Cap2. sectiunea Software Testing Principles] DefineÅŸte rezultatele aÅŸteptate Ã®n urma testÄƒrii. EvitÄƒ sÄƒ testezi programelor proprii. AnalizeazÄƒ riguros rezultatele fiecÄƒrui test. Scrie cazuri de testare atÃ¢t pentru condiÅ£ii de intrare valide cÃ¢t ÅŸi pentru cele non- valide. TesteazÄƒ dacÄƒ programul nu face ceea ce se precizeazÄƒ Ã®n specificaÅ£ie, dar ÅŸi dacÄƒ ceea ce face programul nu este descris Ã®n specificaÅ£ii. PÄƒstreazÄƒ Ã®ntotdeauna cazurile de testare. OrganizeazÄƒ ÅŸi planificÄƒ procesul de testare, considerÃ¢nd cÄƒ se vor identifica bug-uri. Testarea este o activitate de stimulare a creativitÄƒÅ£ii. The goal of a software tester is to find bugs, find them as early as possible, and make sure they get fixed. Axiome ale testÄƒrii [] [Cap.3. sectiunea Testing Axioms] Este imposibil ca un program sÄƒ fie complet (exhaustiv) testat. Testarea softului presupune asumarea unui risc. Testarea nu poate demonstra ca bug-urile nu existÄƒ. NumÄƒrul mare de bug-uri asociat unei funcÅ£ionalitÄƒÅ£i este un indicator al prezenÅ£ei altor bug-uri â€“ bug-urile pot fi grupate Ã®n anumite funcÅ£ionalitÄƒÅ£i, nu sunt izolate. Paradoxul pesticidului (Ã®n testare): cu cÃ¢t un program este testat mai mult folosind aceleaÅŸi teste (tehnici de testare), imunitatea la testare creÅŸte (nu se descoperÄƒ bug-uri noi). Nu orice bug identificat va fi eliminat. SpecificaÅ£ia produsului soft se schimbÄƒ Ã®n permanenÅ£Äƒ. Testerii nu sunt cei mai apreciaÅ£i membri ai echipei de dezvoltare. PROCESUL DE TESTARE ÃntrebÄƒri fundamentale ActivitÄƒÈ›i ale procesului de testare De ce este necesar sa testÄƒm un produs soft ? Care este scopul testÄƒrii ? evaluarea unor caracteristici sau atribute are calitÄƒÅ£ii produsului soft; descoperirea unor informaÅ£ii referitoare la produsul soft []; obiective ale testÄƒrii = aspectele de interes care vor fi investigate (evaluate) Ã®n procesul de testare; Cum se organizeazÄƒ procesul de testare ? contextul aplicaÅ£iei = particularitÄƒÅ£i de realizare a testÄƒrii, e.g., componenta testatÄƒ, beneficiarul testÄƒrii (stakeholder), diverse constrÃ¢ngeri, etc; misiunea testÄƒrii = acÅ£iunea desfÄƒÅŸuratÄƒ prin testare pentru a atinge obiectivele testÄƒrii; strategie de testare = cadru general prin care se determinÄƒ care sunt cele mai potrivite teste care trebuie proiectate (i.e., ce tehnici de testare se aplicÄƒ), astfel Ã®ncÃ¢t testarea sÄƒ Ã®ÅŸi atingÄƒ obiectivele informaÅ£ionale, luÃ¢nd Ã®n considerare contextul aplicaÅ£iei Ã®n care se desfÄƒÅŸoarÄƒ testarea; tehnicÄƒ de testare = metodÄƒ de proiectare, implementare ÅŸi interpretare a rezultatelor unui test; abordare a testÄƒrii = modalitate de aplicare a unei tehnici de testare, e.g., black-box testing, white-box testing, grey-box testing, exploratory testing, scripted testing. Cum determinÄƒm momentul Ã®n care putem realiza testarea? Care sunt condiÅ£iile care trebuie Ã®ndeplinite pentru a demara procesul de testare? criterii de Ã®ncepere a testÄƒrii (engl. entry criteria); Cum determinÄƒm momentul Ã®n care testarea efectuatÄƒ este suficientÄƒ? CÃ¢t timp testÄƒm, cÃ¢te teste executÄƒm? criterii de terminare a testÄƒrii (engl. exit criteria). ÃntrebÄƒri fundamentale. Exemplu Exemplu. Criteriu de terminare a testÄƒrii Ã®ntr-o strategie bazatÄƒ pe risc: Se analizeazÄƒ relaÅ£ia dintre numÄƒrul de teste executate, i.e., amount of testing, ÅŸi numÄƒrul de bug-uri identificate, i.e., quantity; Over testing: DacÄƒ se testeazÄƒ tot/mult: costurile cresc, numÄƒrul de bug-uri scade raportul ğ‘ğ‘¢ğ‘”ğ‘  ğ‘“ğ‘œğ‘¢ğ‘›ğ‘‘ ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘–ğ‘›ğ‘” ğ‘ğ‘œğ‘ ğ‘¡ğ‘  Under testing: devine mic ===> eficienÅ£a testÄƒrii scade; DacÄƒ se testeazÄƒ puÅ£in sau se iau decizii nepotrivite legate de CE se va testa: costurile sunt mici, numÄƒrul de bug-uri rÄƒmÃ¢ne ridicat raportul ğ‘ğ‘¢ğ‘”ğ‘  ğ‘“ğ‘œğ‘¢ğ‘›ğ‘‘ ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘–ğ‘›ğ‘” ğ‘ğ‘œğ‘ ğ‘¡ğ‘  rÄƒmÃ¢ne mare ===> calitate redusÄƒ; Fiecare proiect soft are un cost de testare optim. ActivitÄƒÈ›i ale procesului de testare planificare (engl. test planning): stabilirea obiectivelor (de ce testÄƒm); stabilirea terminÄƒrii testÄƒrii (cÃ¢t testÄƒm); identificarea unitÄƒÈ›ii de program care trebuie testatÄƒ (ce testÄƒm); elaborarea strategiei de testare (cum testÄƒm, ce tehnici aplicÄƒm, ce abordare folosim); proiectare (engl. test design): stabilirea datelor de intrare; stabilirea rezultatului aÈ™teptat; configurarea mediului de execuÈ›ie pentru program; testare (engl. test execution): execuÈ›ia programului, i.e, rularea testelor; analiza (engl. test result analysis): analiza rezultatului testului (evaluarea rezultatului); raportarea bug-urilor; monitorizare (engl. test control and monitoring): supravegherea procesului de testare; evaluarea È™i Ã®mbunÄƒtÄƒÈ›irea procesului de testare. QA vs QC Ã®n procesul de testare: activitÄƒÈ›i QC: 2 .. 4; activitÄƒÈ›i QA: 1, 5; ReferinÈ›e bibliografice [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Dijkstra1969] E.W. Dijkstra, Software engineering techniques, Report on a conference sponsored by the NATO Science Committee, Rome, Italy, 27-31 October 1969. [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [BBST2010] Black-Box Software Testing (BBST), Foundations, . [IEEE990] IEEE, IEEE STD 610, In IEEE Standard Glossary of Software Engineering Terminology, 1990. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [ISTQBCertification2020] ISTQB Exam Certification, . [BBST2011] BBST â€“ Test Design, Cem Kaner, CURS 02B. TESTARE BLACK-BOX Verificarea ÅŸi validarea sistemelor soft [04 Martie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut AbordÄƒri ale testÄƒrii Testare Black-Box DefiniÅ£ie. Caracteristici. Clasificare. Tehnici de testare black-box PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ. Exemple Analiza valorilor limitÄƒ. Exemple PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ vs Analiza valorilor limitÄƒ Avantaje ÅŸi dezavantaje Pentru examen... Bibliografie ABORDÄ‚RI ALE TESTÄ‚RII AbordÄƒri ale testÄƒrii. Clasificare Tehnici de testare asociate AbordÄƒri ale testÄƒrii. Clasificare abordare a testÄƒrii modalitate de realizare a testÄƒrii Ã®n care se aplicÄƒ una sau mai multe tehnici de testare Ã®n cadrul unei straegii de testare stabilitÄƒ anterior; clasificare testare Black-box (criteriul cutiei negre, engl. Black-box testing); testare White-box (criteriul cutiei transparente, engl. White-box testing); testare Grey-box (criteriul cutiei gri, engl. Grey-box testing); testare exploratorie (engl. Exploratory testing); testare bazatÄƒ pe scripturi (engl. Scripted testing); AbordÄƒri ale testÄƒrii. Tehnici de testare asociate Testare Black-Box â€“ testare funcÅ£ionalÄƒ: PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ; Analiza valorilor limitÄƒ; Tabele de decizie, Cazuri de utilizare, Scenarii de utilizare, etc.; Testare White-box â€“ testare structuralÄƒ: Acoperirea fluxului de control (e.g., instrucÅ£iuni, ramificaÅ£ii, decizii, condiÅ£ii, bucle, drumuri); Acoperirea fluxului de date; Testare Grey-box â€“ testare mixtÄƒ: folosirea simultanÄƒ a avantajelor abordÄƒrilor black-box ÅŸi white-box pentru proiectarea cazurilor de testare. TESTARE BLACK-BOX DefiniÅ£ie. Caracteristici. Tehnici de testare black-box PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ. Exemple Analiza valorilor limitÄƒ. Exemple PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ vs Analiza valorilor limitÄƒ Avantaje ÅŸi dezavantaje DefiniÅ£ie. Caracteristici testare black-box (engl. black-box testing, data driven testing, input/output driven testing): testare funcÅ£ionalÄƒ; datele de intrare se aleg pe baza specificaÅ£iei problemei, programul fiind vÄƒzut ca o cutie neagrÄƒ; nu se utilizeazÄƒ informaÅ£ii referitoare la structura internÄƒ a programului, i.e., codul sursÄƒ; permite identificarea situaÅ£iilor Ã®n care programul nu funcÅ£ioneazÄƒ conform specificaÅ£iilor. Tehnici de testare black-box tehnici de proiectare a cazurilor de testare bazate pe criteriul black-box: PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ; Analiza valorilor limitÄƒ; Testarea domeniului de valori; Tabele de decizie; Testarea bazatÄƒ pe cazuri de utilizare; Testarea bazatÄƒ pe scenarii de utilizare; alte tehnici. PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ. MotivaÅ£ie Ã®n general, testarea exhausivÄƒ nu este posibil de realizat, e.g.: existÄƒ un set consistent de date de intrare sau domeniul de valori testat este infinit; existÄƒ restricÅ£ii, e.g., timp, buget, resursa umanÄƒ. partiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ (engl. Equivalence Class Partitioning, ECP) este eficientÄƒ pentru reducerea numÄƒrului de cazuri de testare care trebuie proiectate; Etape: identificarea claselor de echivalenÅ£Äƒ disjuncte: se evitÄƒ redundanÅ£a cazurilor de testare; proiectarea cazurilor de testare: se alege un singur element din fiecare clasÄƒ de echivalenÅ£Äƒ; PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ. DefiniÅ£ie clasÄƒ de echivalenÅ£Äƒ (engl. equivalence class, EC): mulÅ£imea datelor de intrare/ieÈ™ire pentru care programul are comportament similar []; procesul de partiÅ£ionare Ã®n clase de echivalenÅ£Äƒ (engl. equivalence class partitioning, ECP): Ã®mpÄƒrÅ£irea (divizarea) domeniului datelor de intrare/ieÈ™ire Ã®n EC, astfel Ã®ncÃ¢t, dacÄƒ programul va rula corect pentru o valoare dintr-o EC, atunci va rula corect pentru orice valoare din acea EC. ECP. Exemplu 1. Identificarea ECs Se considerÄƒ un formular de Ã®nscriere la un concurs. Pentru data naÅŸterii se introduce ziua, luna ÅŸi anul. IdentificaÅ£i clasele de echivalenÅ£Äƒ corespunzÄƒtoare cÃ¢mpului lunÄƒ calendaristicÄƒ (pentru data naÅŸterii). Domeniul de valori valide este [1, 12]. ECP. Exemplu 1. Proiectarea cazurilor de testare ECs identificate: 1 EC validÄƒ, EC1: D1 =[1, 12]; 3 EC non-valide, EC2: D2= {luna| luna<1} = (-âˆ, 1), EC3: D3= {luna| luna>12} = (12, +âˆ), EC4: D4 = simboluri alfanumerice; Cazuri de testare proiectate: 1 EC validÄƒ ==> 1 caz de testare valid, e.g., TC01: luna = 2; 3 EC non-valide ==> 3 cazuri de testare non-valide, e.g., TC02: luna =-2, TC03: luna = 15, TC04: luna = â€%L10â€; Din fiecare EC de intrare identificatÄƒ se alege o singurÄƒ valoare. ECP considerÄƒ cÄƒ fiecare EC trateazÄƒ Ã®n manierÄƒ similarÄƒ toate valorile din acea EC. ECP. Exemplu 2. Identificarea ECs Pentru constituirea unui depozit bancar se considerÄƒ urmÄƒtoarea ofertÄƒ de dobÃ¢nzi: 0,50% dacÄƒ valoarea depozitului este pÃ¢nÄƒ la 1000,00 Euro; 1,00% dacÄƒ valoarea depozitului este pÃ¢nÄƒ la 2000,00 Euro, dar mai mult de 1000,00 Euro; 1,50% dacÄƒ valoarea depozitului este peste 2000,00 Euro; Care sunt clasele de echivalenÅ£Äƒ valide ÅŸi non-valide pentru valoarea depozitului constituit? Clase de echivalenÅ£Äƒ valide: EC1: 0,00 Euro â€“ 1000,00 Euro; EC2: 1000,01 Euro â€“ 2000,00 Euro; EC3: >= 2000,01 Euro. Clase de echivalenÅ£Äƒ non-valide: EC4: < 0,00 Euro; EC5: > valoarea maximÄƒ admisÄƒ pentru un depozit. EC6: caractere din alfabet. ECP. Exemplu 2. Proiectarea cazurilor de testare ECs identificate: 3 ECs valide: EC1: 0,00 Euro â€“ 1000,00 Euro; EC2: 1000,01 Euro â€“ 2000,00 Euro; EC3: >= 2000,01 Euro. 3 ECs non-valide: EC4: < 0,00 Euro; EC5: > valoarea maximÄƒ admisÄƒ pentru un depozit; EC6: caractere din alfabet. Cazuri de testare proiectate: 3 ECs valide ==> 3 cazuri de testare valide,e.g.: TC01: amount= 678,99; TC02: amount = 1742,81; TC03: amount = 5213,00; 3 ECs non-valide ==> 3 cazuri de testare non- valide, i.e., cÃ¢te un TC care corespunde fiecÄƒrei EC non-valide identificate, e.g.: TC04: amount = -0,79; TC05: amount = 9876543210,123; TC06: amount = #12a. ECP. Algoritm Algoritm de aplicare a ECP (identificarea ECs ÅŸi proiectarea TCs): se identificÄƒ clasele de echivalenÅ£Äƒ pe baza condiÅ£iilor de intrare/ieÅŸire; se clasificÄƒ clasele de echivalenÈ›Äƒ Ã®n: valide â€“ formate din datele de intrare/ieÈ™ire valide pentru program; non-valide â€“ formate din datele de intrare/ieÈ™ire eronate, corespunzÄƒtoare tuturor celorlalte stÄƒri ale condiÈ›iei de intrare/ieÈ™ire. se asociazÄƒ un identificator unic fiecÄƒrei clase de echivalenÈ›Äƒ (e.g., EC1, EC2, etc.); cÃ¢ttimp (nu au fost descrise cazuri de testare pentru toate clasele de echivalenÈ›Äƒ valide/non-valide): scrie (un nou caz de testare care corespunde la cÃ¢t mai multe clase de echivalenÈ›Äƒ valide Ã®ncÄƒ neacoperite); scrie (un nou caz de testare care corespunde doar uneia dintre clasele de echivalenÈ›Äƒ de non-valide Ã®ncÄƒ neacoperite). dacÄƒ o condiÈ›ie de intrare precizeazÄƒ apartenenÈ›a la un interval de valori [a,b]: â€¢ ==> 1 EC validÄƒ, 2 EC non-valide; E.g.: luna, o valoare intervalul [1, 12]; dacÄƒ o condiÈ›ie de intrare precizeazÄƒ o mulÈ›ime finitÄƒ de valori de intrare: â€¢ ==> 1 EC validÄƒ pentru fiecare valoare, 1 EC non-validÄƒ; E.g.: tip curs Ïµ CourseType = {opÈ›ional, obligatoriu, facultativ}; 1 EC validÄƒ pentru fiecare element din CourseType: EC1: {opÈ›ional}, EC2: {obligatoriu}, EC3: {facultativ} ===> 3 ECs valide; 1 EC non-validÄƒ: EC4: M=  ğ‘’	ğ‘’ âˆ‰ CourseType}; dacÄƒ o condiÈ›ie de intrare precizeazÄƒ numÄƒrul de valori: â€¢ ==> 1 EC validÄƒ, 2 EC non-valide; E.g.: â€œde la 1 pÃ¢nÄƒ la 5 studenÈ›iâ€; 1 EC validÄƒ: EC1: D=[1,5]; 2 EC non-valide: EC2: nici un student; EC3: mai mult de 5 studenÈ›i; dacÄƒ o condiÈ›ie de intrare precizeazÄƒ o situaÈ›ie de tipul â€œmust beâ€: â€¢ ==> 1 EC validÄƒ, 1 EC non-validÄƒ. E.g.,: â€œprimul caracter din parolÄƒ trebuie sÄƒ fie un simbol numericâ€; 1 EC validÄƒ: EC1: primul caracter este un simbol numeric; 1 EC non-validÄƒ: EC2: primul caracter nu este un simbol numeric. DacÄƒ existÄƒ argumente cÄƒ programul nu trateazÄƒ similar toate elementele dintr- o EC, atunci ECs se Ã®mpart Ã®n ECs mai mici. ECP. Acoperirea testÄƒrii ECs calculul acoperirii (engl. coverage) testÄƒrii ECs pentru tehnica de testare ECP: Acoperirea ECs = numÄƒrul de ECs testate numÄƒrul de ECs identificate x 100 E.g.: pe baza specificaÅ£iilor au fost identificate 18 ECs (pentru datele de intrare ÅŸi ieÅŸire); pentru 15 ECs s-au proiectat, implementat ÅŸi executat teste; Acoperirea ECs= (15/18)*100 = 83,33%. Acoperirea ECs poate fi folositÄƒ ca ÅŸi criteriu de terminare a testÄƒrii, i.e., exit criteria. Este ECP eficientÄƒ la limita dintre ECs ? ECP presupune cÄƒ programul are un comportament similar pentru toate valorile dintr-o EC; ECP nu garanteazÄƒ cÄƒ programul este testat ÅŸi la limitele ECs identificate; existÄƒ greÅŸeli de programare tipice care apar la limita ECs identificate; e.g., pentru xâ‰¥3	if (x>3) y++;  //bug if (x>=3) y++; [ECP]: pentru EC1: [3, MaxInt] se alege TC01: x=4, dar TC01 nu surprinde bug-ul de implementare. Analiza valorilor limitÄƒ. MotivaÅ£ie analiza valorilor limitÄƒ investigheazÄƒ posibilele bug-uri existente la limita dintre ECs identificate; E.g.: pentru xâ‰¥3	if (x>3) y++;  //bug if (x>=3) y++; [ECP]: pentru EC1: [3, MaxInt] se alege TC01: x=4, dar TC01 nu surprinde bug-ul de implementare; [BVA]: pentru EC1: [3, MaxInt] se alege TC02: x=3; Etape: identificarea condiÅ£iilor asociate valorilor limitÄƒ: proiectarea cazurilor de testare: se aleg date test pentru fiecare condiÅ£ie limitÄƒ identificatÄƒ; Analiza valorilor limitÄƒ. DefiniÅ£ie analiza valorilor limitÄƒ (engl. boundary value analysis, BVA) []: testarea realizatÄƒ prin alegerea datelor de test pe baza limitelor ECs de intrare/ieÅŸire; valoare limitÄƒ (engl. boundary value, BV): valoare a domeniului pentru care comportamentul programului se modificÄƒ. BVA. Exemplu 1. CondiÅ£ii BVA Limitele unei EC valide indicÄƒ situaÅ£iile Ã®n care comportamentul programului se schimbÄƒ! ECs identificate: 1 EC validÄƒ: EC1: D1 =[1, 12]; 3 EC non-valide: D2= {luna| luna<1} = (-âˆ, 1), D3= {luna| luna>12} = (12, +âˆ), D4 = simboluri alfanumerice; CondiÅ£ii BVA, construite pentru limitele ECs valide: BVA. Exemplu 1. Proiectarea cazurilor de testare ECs valide identificate: 1 EC validÄƒ: EC1: D1 = [1, 12]; Cazuri de testare proiectate pe baza condiÅ£iilor BVA identificate: Limita inferioarÄƒ a EC1: 1. luna = 0 ==> TC01: luna = 0; (non-valid) 2. luna = 1 ==> TC02: luna = 1; (valid) 3. luna = 2 ==> TC03: luna = 2; (valid) Limita superioarÄƒ a EC1: 4. luna = 11 ==> TC04: luna = 11; (valid) 5. luna = 12 ==> TC05: luna = 12; (valid) 6. luna = 13 ==> TC06: luna = 13; (non-valid) BVA. Exemplu 2. CondiÅ£ii BVA ECs valide identificate: EC1: 0,00 Euro â€“ 1000,00 Euro; EC2: 1000,01 Euro â€“ 2000,00 Euro; EC3: >= 2000,01 Euro. CondiÅ£ii BVA identificate: Limita inferioarÄƒ a EC1: 1. amount = -0,01; (non-validÄƒ) 2. amount = 0,00; 3. amount = 0,01; Limita superioarÄƒ a EC1: 4. amount = 999,99; 5. amount = 1000,00; 6. amount = 1000,01; (non-validÄƒ) Limita inferioarÄƒ a EC2: 1. amount = 1000,00; (non-validÄƒ) 2. amount = 1000,01; 3. amount = 1000,02; Limita superioarÄƒ a EC2: 4. amount = 1999,99; 5. amount = 2000,00; 6. amount = 2000,01; (non-validÄƒ) Limita inferioarÄƒ a EC3: 1. amount = 2000,00; (non-validÄƒ) 2. amount = 2000,01; 3. amount = 2000,02; Limita superioarÄƒ a EC3, MAX_VALUE (float): 4. amount = MAX_VALUE-0,01; 5. amount = MAX_VALUE; 6. amount = MAX_VALUE+0,01; (non-validÄƒ) BVA. Exemplu 2. Proiectarea cazurilor de testare ECs valide identificate: EC1: 0,00 Euro â€“ 1000,00 Euro; EC2: 1000,01 Euro â€“ 2000,00 Euro; similar, se proiecteazÄƒ cazuri de testare valide ÅŸi non-valide pentru limitele inferioare ÅŸi superioare ale EC ÅŸi EC ; EC 3: >= 2000,01 Euro. Cazuri de testare proiectate pe baza condiÅ£iilor BVA identificate: Limita inferioarÄƒ a EC1: 1. amount = -0,01; TC01: amount = -0,01; (non-valid) 2. amount = 0,00; TC02: amount = 0,00 (valid) 3. amount = 0,01; TC03: amount = 0,01; (valid) Limita superioarÄƒ a EC1: 4. amount = 999,99; TC04: amount = 999,99; (valid) 5. amount = 1000,00; TC05: amount = 1000,00; (valid) 6. amount = 1000,0; TC06: amount = 1000,01; (non valid) CondiÅ£ii BVA. ExcepÅ£ii de identificare a condiÅ£iilor BVA existÄƒ ECs care nu au limite: E.g.: mulÅ£imea {Dl, Dna, Dra, Dr.} sau CourseType = {opÈ›ional, obligatoriu, facultativ}; existÄƒ ECs (ordonate) care nu au douÄƒ limite (inferioarÄƒ ÅŸi superioarÄƒ); E.g.: valoarea unei depuneri Ã®ntr-un cont bancar; variabile multiple dependente: E.g.: variabilele: numÄƒr card bancar, data eliberare, data expirare, nume titular; toate variabilele au valori valide ÅŸi toate constrÃ¢ngerile existente Ã®ntre acestea sunt satisfÄƒcute <==> card valid; dacÄƒ variabilele au valori valide dar constrÃ¢ngerile nu sunt satisfÄƒcute ==> card non-valid; dacÄƒ variabilele au valori non-valide ==> card non-valid; ECs dependente â€“ valoarea unei variabile depinde de/ influenÅ£eazÄƒ valoarea alteia: E.g.:, Ã®n OpenOffice Writer existÄƒ mai multe tipuri de paginÄƒ: format_paginÄƒ = {A2, A3, A4}; formatul A4 constrÃ¢nge dimensiunea header-ului paginii (header height) maximÄƒ 20.56 cm. CondiÅ£ii BVA. Sumar BVA. Algoritm Algoritm de aplicare a BVA (identificarea condiÅ£iilor BVA ÅŸi proiectarea TCs): se identificÄƒ limitele tuturor ECs valide de intrare/ieÅŸire; se scriu condiÅ£ii BVA pentru fiecare limitÄƒ a fiecÄƒrei EC identificate, astfel Ã®ncÃ¢t: valoarea sÄƒ fie sub limitÄƒ (mai micÄƒ decÃ¢t limita), e.g., x < 2; valoarea sÄƒ fie pe limitÄƒ (egalÄƒ cu limita) , e.g., x = 2; valoarea sÄƒ fie deasupra limitei (mai mare decÃ¢t limita), e.g., x > 2; se clasificÄƒ condiÅ£iile BVA Ã®n valide â€“ corespund unor date de intrare/ieÅŸire valide pentru program; non-valide â€“ corespund unor date de intrare/ieÅŸire non-valide pentru program. se asociazÄƒ un identificator unic fiecÄƒrei condiÅ£ii BVA (e.g., c1, c2, etc.); cÃ¢ttimp (nu au fost descrise cazuri de testare pentru toate condiÅ£iile BVA valide/non-valide): scrie (un caz de testare nou, care corespunde la cÃ¢t mai multe condiÅ£ii BVA valide Ã®ncÄƒ neacoperite); scrie (un caz de testare nou, care corespunde doar uneia dintre condiÅ£iile BVA non-valide Ã®ncÄƒ neacoperite). BVA. Proiectarea cazurilor de testare. Reguli dacÄƒ o condiÅ£ie de intrare/ieÈ™ire precizeazÄƒ apartenenÈ›a la un interval de valori [a,b]: â€¢	==> cazuri de testare pentru: (1) condiÈ›ii BVA valide - limitele intervalului (e.g., a, a+1; b-1, b); (2) condiÈ›ii BVA non-valide - valori aflate Ã®n afara intervalului (e.g., a-1, b+1); dacÄƒ o condiÈ›ie de intrare/ieÈ™ire precizeazÄƒ o mulÈ›ime de valori ordonatÄƒ: â€¢	==> cazuri de testare pentru: (1) condiÈ›ii BVA valide - primul È™i ultimul element din mulÈ›ime; (2) condiÈ›ii BVA non-valide â€“ valoarea imediat mai micÄƒ decÃ¢t cea mai micÄƒ valoare din mulÈ›ime È™i valoarea imediat mai mare decÃ¢t cea mai mare valoare in mulÈ›ime; dacÄƒ o condiÈ›ie de intrare/ieÈ™ire precizeazÄƒ numÄƒrul de valori (e.g., â€œde la 1 pÃ¢nÄƒ la 5 studenÈ›iâ€): â€¢	==> cazuri de testare pentru: (1) condiÈ›ii BVA valide â€“ numÄƒrul minim È™i maxim de valori, i.e., 1 È™i 5; (2) condiÈ›ii BVA non-valide â€“ valoarea imediat mai micÄƒ È™i imediat mai mare, i.e. 0 È™i 6; BVA. Acoperirea testÄƒrii condiÅ£iilor BVA calculul acoperirii (engl. coverage) testÄƒrii condiÅ£iilor BVA: Acoperirea BVAs = numÄƒrul de condiÅ£ii BVA testate numÄƒrul de condiÅ£ii BVA identificate x 100 E.g.: pe baza specificaÅ£iilor au fost identificate 64 BVAs (pentru datele de intrare ÅŸi ieÅŸire, corespunzÄƒtor ECs valide); 48 BVAs au fost testate prin cazurile de testare proiectate; Acoperirea BVAs= (48/64)*100 = 75%. Acoperirea BVAs poate fi folositÄƒ ca ÅŸi criteriu de terminare a testÄƒrii, i.e., exit criteria. ECP vs BVA ECP presupune cÄƒ programul trateazÄƒ similar toate valorile din aceeaÅŸi EC; se poate selecta orice valoare din EC; se alege o singurÄƒ valoare din EC, consideratÄƒ reprezentativÄƒ pentru a acoperi testarea acelei EC; ECs se construiesc pentru condiÅ£ii de intrare/ieÈ™ire valide ÅŸi non-valide; obiectiv al testÄƒrii = verificarea respectÄƒrii specificaÅ£iilor pentru valori uzuale, i.e., building confidence in software; BVA valorile identificate de condiÅ£iile BVA sunt prelucrate individual, nu Ã®n grup; valorile se gÄƒsesc la limitele dintre ECs, acolo unde programul Ã®ÅŸi schimbÄƒ comportamentul; se iau Ã®n considerare valori egale cu limita, valori imediat inferioare ÅŸi valori imediat superioare limitei; sunt luate Ã®n considerare atÃ¢t datele de intrare cÃ¢t ÅŸi cele de ieÅŸire, corespunzÄƒtoare fiecÄƒrei EC valide; obiectiv al testÄƒrii = cÄƒutarea bug-urilor uzuale, i.e., bug hunting; Testarea Black-box Avantaje nu se existÄƒ informaÅ£ii despre implementare; activitatea testerului este independentÄƒ de cea a programatorului; reflecta punctul de vedere al utilizatorului; suprinde ambiguitÄƒÅ£ile sau inconsistenÅ£ele din specificaÅ£ii; Ã®ncepe imediat dupÄƒ finalizarea specificaÅ£iilor. Dezavantaje daca specificaÅ£ia nu este clarÄƒ ==> dificultate de construire a cazurilor de testare; la execuÅ£ia programului, multe drumurile din graful de execuÅ£ie asociat codului rÄƒmÃ¢n netestate ==> secvenÅ£ele de cod sursÄƒ corespunzÄƒtoare pot conÅ£ine bug-uri care nu sunt identificate; doar un numÄƒr foarte mic de date de intrare va fi efectiv testat. PENTRU EXAMENâ€¦ Pentru examen... testare: definiÅ£ii ale testÄƒrii (4); terminologie: program, program testat, caz de testare; tipuri de testare: exhaustivÄƒ, selectivÄƒ; testare black-box: definiÅ£ie, caracteristici; ECP, BVA, ECP vs. BVA; aplicarea ECP ÅŸi BVA pentru probleme concrete; avantaje ÅŸi dezavanataje BBT. Cursul urmÄƒtor... Testare White-Box Tehnici de testare white-box Testare bazatÄƒ pe fluxul de control. Componente Graful fluxului de control. Drumuri Ã®n CFG. Complexitatea ciclomaticÄƒ Testare bazatÄƒ pe acoperirea drumurilor Testare bazatÄƒ pe acoperirea codului sursÄƒ Acoperirea instrucÅ£iunilor, deciziilor, condiÅ£iilor, deciziilor ÅŸi condiÅ£iilor, condiÅ£iilor multiple, drumurilor, buclelor Testare White-box vs Testare Black-box ReferinÈ›e bibliografice [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [BBST2010] Black-Box Software Testing (BBST), Foundations, . CURS 03. TESTARE WHITE-BOX Verificarea ÅŸi validarea sistemelor soft [11 Martie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut AbordÄƒri ale testÄƒrii Testare White-Box DefiniÅ£ie. Caracteristici Tehnici de testare white-box Testare bazatÄƒ pe fluxul de control. Componente DefiniÅ£ie. Caracteristici. Avantaje ÅŸi dezavantaje Graful fluxului de control. Exemple Drumuri Ã®n CFG. Exemple Complexitatea ciclomaticÄƒ. Exemple Testare bazatÄƒ pe acoperirea drumurilor DefiniÅ£ie. Algoritm. Exemplu Testare bazatÄƒ pe acoperirea codului sursÄƒ DefiniÅ£ie. Criterii de acoperire Acoperirea instrucÅ£iunilor, deciziilor, condiÈ›iilor, deciziilor ÅŸi condiÅ£iilor, condiÅ£iilor multiple, buclelor Testare White-box vs Testare Black-box Avantaje ÅŸi dezavantaje ale TestÄƒrii White-Box Testare Black-box vs. Testare White-box Bibliografie ABORDÄ‚RI ALE TESTÄ‚RII AbordÄƒri ale testÄƒrii. Clasificare Tehnici de testare asociate AbordÄƒri ale testÄƒrii. Clasificare abordare a testÄƒrii modalitate de realizare a testÄƒrii Ã®n care se aplicÄƒ una sau mai multe tehnici de testare Ã®n cadrul unei straegii de testare stabilitÄƒ anterior; clasificare testare Black-box (criteriul cutiei negre, engl. Black-box testing); testare White-box (criteriul cutiei transparente, engl. White-box testing); testare Grey-box (criteriul cutiei gri, engl. Grey-box testing); testare bazatÄƒ pe experienÅ£Äƒ (engl. Experienced-based testing); testare bazatÄƒ pe scripturi (engl. Scripted-based testing); AbordÄƒri ale testÄƒrii. Tehnici de testare asociate Testare Black-Box â€“ testare funcÅ£ionalÄƒ: PartiÅ£ionarea Ã®n clase de echivalenÅ£Äƒ; Analiza valorilor limitÄƒ; Tabele de decizie, Cazuri de utilizare, Scenarii de utilizare, etc.; Testare White-box â€“ testare structuralÄƒ: Acoperirea fluxului de control (e.g., drumuri, instrucÅ£iuni, ramificaÅ£ii, decizii, condiÅ£ii, bucle); Acoperirea fluxului de date; Testare Grey-box â€“ testare mixtÄƒ: folosirea simultanÄƒ a avantajelor abordÄƒrilor black-box ÅŸi white-box pentru proiectarea cazurilor de testare. TESTARE WHITE-BOX DefiniÅ£ie. Caracteristici Tehnici de testare white-box Quiz WBT Quiz WBT CE? CompletaÈ›i quiz-ul WBT cu Ã®ntrebÄƒri referitoare la testarea white-box, disponibil la acest . CUM? Activitatea este facultativÄƒ. Fiecare Ã®ntrebare din quiz are o singurÄƒ variantÄƒ de rÄƒspuns corectÄƒ. CINE? Activitatea se adreseazÄƒ tuturor studenÈ›ilor Ã®nscriÈ™i la disciplina VVSS (IR, MIR). CÃ‚ND? Quiz-ul trebuie completat pÃ¢nÄƒ cel tÃ¢rziu Vineri, 04 Aprilie 2025, orele 20:00. CÃ‚T? Sunt necesare max. 15 minute pentru completarea quiz-ului. DE CE? StudenÅ£ii primesc 2 puncte pentru activitatea Quiz WBT, inclusÄƒ Ã®n nota de la seminar. Punctele pentru aceastÄƒ activitate se acordÄƒ indiferent de numÄƒrul de rÄƒspunsuri corecte indicate. Testare White-Box. DefiniÅ£ie. Caracteristici criteriul cutiei transparente (engl. white-box testing, logic driven testing): testare structuralÄƒ; datele de intrare se aleg pe baza instrucÅ£iunilor care trebuie executate, programul este vÄƒzut ca o cutie transparentÄƒ; avem acces la structura internÄƒ a programului (codul sursÄƒ); permite identificarea situaÅ£iilor Ã®n care execuÅ£ia programului nu acoperÄƒ diferite structuri ale acestuia. Tehnici de testare white-box tehnici de proiectare a cazurilor de testare white-box bazate pe: fluxul de control: acoperirea drumurilor []; acoperirea codului sursÄƒ: instrucÅ£iunilor, ramificaÅ£iilor, deciziilor, condiÅ£iilor, deciziilor ÅŸi condiÅ£iilor, condiÅ£iilor multiple [], condiÅ£iilor/deciziilor modificate; buclelor []; acoperirea predicatelor (engl. predicate complete coverage); acoperirea prin mutaÅ£ii; fluxul de date []. TESTARE BAZATÄ‚ PE FLUXUL DE CONTROL. COMPONENTE DefiniÅ£ie. Caracteristici Graful fluxului de control. Exemple Drumuri Ã®n CFG. Exemple Complexitatea ciclomaticÄƒ. Exemple Testare bazatÄƒ pe fluxul de control â€“ Avantaje ÅŸi dezavantaje Testarea bazatÄƒ pe fluxul de control testarea bazatÄƒ pe fluxul de control utilizeazÄƒ structurile de control pentru proiectarea cazurilor de testare; scop: acoperirea prin cazuri de testare la un nivel statisfÄƒcator a structurilor de control din programul testat; componente: graful fluxului de control; complexitatea ciclomaticÄƒ. Graful fluxului de control. DefiniÅ£ie graful fluxului de control (engl. Control Flow Graph, CFG): reprezentare graficÄƒ detaliatÄƒ a unei unitÄƒÅ£i de program; permite vizualizarea tuturor drumurilor din unitatea de program; graf orientat: vÃ¢rf (engl. node): indicÄƒ structuri secvenÅ£iale ÅŸi condiÅ£iile din structurile alternative sau repetitive; arc (engl. edge): indicÄƒ sensul transmiterii controlului logic Ã®n cadrul programului. CFG. Caracteristici permite reprezentarea graficÄƒ a structurilor de programare; tipuri de vÃ¢rfuri: decizie: are o condiÅ£ie prin care se permite ramificarea execuÅ£iei prin cel puÅ£in douÄƒ cÄƒi; e.g., instrucÅ£iunile if, while, repeat/until, case; instrucÅ£iune/calcul: conÅ£ine o secvenÅ£Äƒ de instrucÅ£iuni; conector: nu conÅ£ine o instrucÅ£iune ÅŸi reprezintÄƒ un punct al programului care uneÅŸte mai multe ramificaÅ£ii; intrare, ieÅŸire: existÄƒ un singur vÃ¢rf intrare ÅŸi un singur vÃ¢rf ieÅŸire; Ã®n vÃ¢rful de intrare nu Ã®ntrÄƒ nici un arc; din vÃ¢rful de ieÅŸire nu iese nici un arc. CFG. Construire paÅŸi de elaborare a unui CFG: se numeroteazÄƒ unic fiecare element de structurÄƒ secvenÅ£ialÄƒ (calcul) ÅŸi condiÅ£ionalÄƒ (decizie); se Ã®ncepe pornind de la vÃ¢rful de intrare, care are (de obicei) numÄƒrul 1; se adaugÄƒ celelalte vÄƒrfuri corespunzÄƒtoare structurilor numerotate ÅŸi se unesc prin arce, evidenÅ£iind transmiterea controlului Ã®n cadrul programului; la final, toate ieÅŸirile posibile din program se unesc Ã®n vÃ¢rful de ieÅŸire; condiÅ£ii complexe care conÅ£in atribuiri ==> CFG are o descriere complexÄƒ []; e.g., if (((fptr1 = fopen(â€™â€™file1â€™â€™, â€™â€™râ€™â€™ )) != NULL) && (i++) && (0)){...}. CFG. Complexitatea construirii pentru metoda openfiles(), avem CFG alÄƒturat; CFG. Exemple de notaÅ£ii CFG. Exemple (1) CFG. Exemple (2) CFG. Drumuri Ã®n CFG drum: execuÅ£ia unei secvenÅ£e de instrucÅ£iuni de la punctul de intrare pÃ¢nÄƒ la punctul de ieÅŸire al CFG asociat unei unitÄƒÅ£i de program; drum independent (engl. independent path): orice drum Ã®n CFG care introduce cel puÅ£in o instrucÅ£iune nouÄƒ sau o condiÅ£ie nouÄƒ, care este executatÄƒ cel puÅ£in o datÄƒ; mulÅ£imea drumurilor independente formeazÄƒ mulÅ£imea drumurilor de bazÄƒ (engl. basis path set) a unui CFG; indicÄƒ numÄƒrul minim de cazuri de testare care trebuie executate pentru ca fiecare instrucÅ£iune sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ. drumuri independente: drum 1: 1(F)-11. drum 2: 1(T)-2-3(T)-4-5-10-1(F)-11. drum 3: 1(T)-2-3(F)-6(T)-8-9-10-1(F)-11. drum 4: 1(T)-2-3(F)-6(F)-7-9-10-1(F)-11. drumuri independente: drum 1: A-B-D-E-G-K-M; drum 2: A-C-D-E-G-K-M; drum 3: A-B-D-F-I-L-M;. drum 4: A-B-D-E-H-K-M; drum 5: A-C-D-F-J-L-M. CFG. Algoritm de construire a drumurilor independente Algoritmul lui McCabe [McCabe1984, McCabe Baseline Method] se alege un drum normal (numit drum iniÅ£ial, D1); se recomandÄƒ ca acesta sÄƒ aibÄƒ cÃ¢t mai multe decizii este posibil; pentru generarea urmÄƒtorului drum (D2), se modificÄƒ rezultatul evaluÄƒrii primei decizii de pe D1 È™i pÄƒstrÃ¢nd numÄƒrul de decizii ale drumului D1; pentru generarea urmÄƒtorului drum (D3), se modificÄƒ rezultatul evaluÄƒrii celei de a doua decizii de pe D1; se repetÄƒ pasul 3 pÃ¢nÄƒ cÃ¢nd toate deciziile de pe D1 au fost modificate/inversate; se reiau paÅŸii de la 1..4 considerÃ¢nd ca drum iniÅ£ial pe D2, modificÃ¢nd/inversÃ¢nd deciziile, pÃ¢nÄƒ cÃ¢nd toate se obÅ£in toate drumurile independente din mulÅ£imea de bazÄƒ a CFG. Complexitatea ciclomaticÄƒ. DefiniÅ£ie complexitatea ciclomaticÄƒ (engl. McCabeâ€™s cyclomatic complexity, CC): metricÄƒ software aplicatÄƒ pentru mÄƒsurarea cantitativÄƒ a complexitÄƒÅ£ii logice a unui program; permite determinarea numÄƒrului de drumuri independente din mulÅ£imea de bazÄƒ a unui CFG; modalitÄƒÅ£i de calcul a CC la nivelul CFG: CC = numÄƒrul de regiuni din CFG; CC = E âˆ’ N + 2, unde E - #arce, N - #vÃ¢rfuri ; CC = P + 1, unde P - #vÃ¢rfuri condiÅ£ie. regiune: zonÄƒ a CFG marginitÄƒ parÅ£ial sau Ã®n totalitate de arce ÅŸi vÃ¢rfuri; CC. Exemple (1) CC pentru CFG: CC = numÄƒrul de regiuni = 4 regiuni = 4. CC = E âˆ’ N + 2 = 14 arce - 12 vÃ¢rfuri + 2 = 4. CC = P + 1 = 3 vÃ¢rfuri condiÅ£ie + 1 = 4. drumuri independente: drum 1: 1(F)-11. drum 2: 1(T)-2-3(T)-4-5-10-1(F)-11. drum 3: 1(T)-2-3(F)-6(T)-8-9-10-1(F)-11. drum 4: 1(T)-2-3(F)-6(F)-7-9-10-1(F)-11. CC. Exemple (2) drumuri independente: drum 1: A-B-D-E-G-K-M; drum 2: A-C-D-E-G-K-M; drum 3: A-B-D-F-I-L-M;. drum 4: A-B-D-E-H-K-M; drum 5: A-C-D-F-J-L-M. CC pentru CFG: CC = numÄƒrul de regiuni = 5 regiuni = 5; CC = E âˆ’ N + 2 = 16 arce - 13 vÃ¢rfuri + 2 = 5; CC = P + 1 = 4 vÃ¢rfuri condiÅ£ie + 1 = 5. Utilizarea CFG Ã®n testare. Avantaje ÅŸi dezavantaje Avantaje Testarea de bazÄƒ aplicatÄƒ Ã®n testarea unitarÄƒ, care sunt dezvoltate la momentul curent; Se aplicÄƒ pentru modulele pentru care prin inspectare nu pot fi suficient verificate; Limbajele orientate-obiect reduc numÄƒrul de bug-uri la nivelul fluxului de control. Dezavantaje DacÄƒ este aplicatÄƒ de tester ÅŸi nu de programator, este necesar ca testerul sÄƒ aibÄƒ abilitÄƒÅ£i de programare pentru a Ã®nÅ£elege codul sursÄƒ ÅŸi modul de execuÅ£ie al acestuia; TehnicÄƒ de testare consumatoare de timp, deoarece mai Ã®ntÃ¢i se elaboreazÄƒ CFG, CC, drumuri independente ÅŸi ulterior se proiecteazÄƒ cazurile de testare; ConsiderÄƒ cÄƒ: SpecificaÅ£iile sunt corecte; Datele sunt definite ÅŸi accesate corespunzÄƒtor; Nu existÄƒ alte bug-uri pe lÃ¢ngÄƒ cele determinate de fluxul de control. TESTARE BAZATÄ‚ PE ACOPERIREA DRUMURILOR DefiniÅ£ie Algoritm Exemplu Testare bazatÄƒ pe acoperirea drumurilor. DefiniÅ£ie acoperirea tuturor drumurilor (engl. all path coverage, apc): testarea tuturor drumurilor programului; avantaje ÅŸi dezavantaje: permite identificarea tuturor defectelor, dar nu ÅŸi de pe drumurile care lipsesc; dificil de realizat Ã®n practicÄƒ pentru programe cu structuri repetitive ===> se alege un numÄƒr redus de drumuri; Testare bazatÄƒ pe acoperirea drumurilor. Algoritm Algoritmul de proiectare a cazurilor de testare bazat pe drumuri este: Se elaboreazÄƒ CFG; Se calculeazÄƒ CC pe baza CFG; Se determinÄƒ mulÅ£imea de bazÄƒ a CFG (cu drumuri independente, liniare); Se proiecteazÄƒ cÃ¢te un caz de testare pentru fiecare drum independent identificat. ordinea de selectare a drumurilor: drumuri scurte; drumuri de lungime crescÃ¢ndÄƒ; drumuri lungi, complexe, alese arbitrar. Testare bazatÄƒ pe acoperirea drumurilor. Exemplu CÃ¢te cazuri de testare sunt necesare pentru acoperira drumurilor? Testare bazatÄƒ pe acoperirea drumurilor. Exemplu (cont) CC pentru CFG: CC = numÄƒrul de regiuni = 3 regiuni = 3; CC = E âˆ’ N + 2 = 7 arce - 6 vÃ¢rfuri + 2 = 3; CC = P + 1 = 2 vÃ¢rfuri condiÅ£ie + 1 = 3. drumuri independente: drum 1: 1-2(F)-6. drum 2: 1-2(T)-3(F)-5-2(F)-6. drum 3: 1-2(T)-3(T)-4-5-2(F)-6. TESTARE BAZATÄ‚ PE ACOPERIREA CODULUI SURSÄ‚ DefiniÅ£ie. Criterii de acoperire Acoperirea instrucÅ£iunilor. DefiniÅ£ie. Exemplu Acoperirea deciziilor. DefiniÅ£ie. Exemplu Acoperirea condiÅ£iilor. DefiniÅ£ie. Exemplu Acoperirea deciziilor ÅŸi condiÅ£iilor. DefiniÅ£ie. Exemplu Acoperirea condiÅ£iilor multiple. DefiniÅ£ie. Exemplu Acoperirea buclelor. DefiniÅ£ie. Exemplu Testare bazatÄƒ pe acoperirea codului sursÄƒ. DefiniÅ£ie acoperirea codului sursÄƒ: testarea tuturor structurilor de control folosind un numÄƒr minim de teste, astfel Ã®ncÃ¢t sÄƒ fie satisfÄƒcute criteriile: acoperirea instrucÅ£iunilor (engl. statement/line/node coverage); acoperirea ramificaÅ£iilor: acoperirea deciziilor (arcelor) (engl. decision/branch/edge coverage); acoperirea condiÅ£iilor (engl. condition coverage); acoperirea deciziilor ÅŸi condiÅ£iilor (engl. decision-condition coverage); acoperirea condiÅ£iilor multiple (engl. multiple condition coverage); acoperirea structurilor repetitive: acoperirea buclelor (engl. loop coverage). Acoperirea instrucÅ£iunilor. DefiniÅ£ie acoperirea instrucÅ£iunilor (engl. statement/line/node coverage, sc): proiectarea cazurilor de testare astfel Ã®ncÃ¢t toate instrucÅ£iunile sunt executate cel puÅ£in o datÄƒ, adicÄƒ fiecare vÃ¢rf al CFG este vizitat; cel mai slab criteriu de acoperire Ã®n testare; o mulÅ£ime de teste care nu realizeazÄƒ acoperire 100% a vÃ¢rfurilor nu este consideratÄƒ acceptabilÄƒ. SC. Exemplu Fiecare intrucÅ£iune trebuie sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ. // returneazÄƒ valoarea absolutÄƒ a lui y int abs (int y) { if (y<0) y = -y; return y; } Care este numÄƒrul minim de cazuri de testare necesar? Criteriul de acoperire a instrucÅ£iunilor este Ã®ndeplinit 100%. SC. ObservaÅ£ii cel mai slab criteriu de acoperire deoarece: nu acoperÄƒ ramificaÅ£ia else pentru instrucÅ£iunile if care nu descriu explicit aceastÄƒ ramificaÅ£ie; nu evdenÅ£iazÄƒ implicit prezenÅ£a posibilelor bug-uri de pe aceste ramificaÅ£ii; SC se recomandÄƒ doar atunci cÃ¢nd nu existÄƒ alte criterii de acoperire care se pot aplica. // returneazÄƒ valoarea absolutÄƒ a lui y int abs (int y) { if (y<0) y = -y; return y; } Este necesarÄƒ acoperirea deciziilor. Acoperirea deciziilor. DefiniÅ£ie ramificaÅ£ie (engl. branch/edge): arc care porneÅŸte dintr-un vÃ¢rf; din fiecare vÃ¢rf porneÅŸte cel mult un arc, mai puÅ£in din vÃ¢rful de ieÅŸire al CFG; din vÃ¢rfurile de decizie pornesc douÄƒ arce, etichetate cu true ÅŸi false; acoperirea deciziilor (engl. branch/edge/decision coverage, dc): acoperirea unui arc a = drum care parcurge arcul a; proiectarea cazurilor de testare se face astfel Ã®ncÃ¢t fiecare arc de decizie sÄƒ fie parcurs cel puÅ£in o datÄƒ; regulÄƒ de selectare: fiecare decizie selectatÄƒ, evaluatÄƒ la true sau false, trebuie sÄƒ se gÄƒseascÄƒ pe cel puÅ£in un drum. DC. Exemplu Pentru fiecare decizie, fiecare ramificaÅ£ie (true, false) trebuie sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ. // returneazÄƒ valoarea absolutÄƒ a lui y int abs (int y) { if (y<0) y = -y; return y; } Care este numÄƒrul minim de cazuri de testare necesar ? Criteriul de acoperire a deciziilor este Ã®ndeplinit 100%. Ambele ramificaÅ£ii ale deciziei au fost explorate. DC vs. SC dc ===> sc; instrucÅ£iunile se aflÄƒ pe arce; dacÄƒ se parcurge fiecare arc atunci se executÄƒ ÅŸi instrucÅ£iunile asociate; DC. ObservaÅ£ii e.g.,	y = fou(x); if (x<10 || y>20) {z=fie(x, y);} else {z=foo(x,y);} pentru x=1 ÅŸi y=2 nu mai este relevantÄƒ evaluarea condiÅ£iei y>20; Ã®n deciziile formate din mai multe condiÅ£ii, unele condiÅ£ii pot sÄƒ rÄƒmÃ¢nÄƒ neacoperite fiind irelevante pentru rezultatul final al deciziei; dacÄƒ condiÅ£ia este scrisÄƒ greÅŸit, e.g., y<20 Ã®n loc de y>20, cazuri de testare ca x=1, y=2 nu evidenÅ£iazÄƒ defectul. Este necesarÄƒ acoperirea condiÅ£iilor. Acoperirea condiÅ£iilor. DefiniÅ£ie condiÅ£ie: expresie logicÄƒ dintr-un vÃ¢rf de decizie; o decizie este formatÄƒ din una mai mai multe condiÅ£ii; acoperirea condiÅ£iilor (engl. condition coverage, cc): proiectarea cazurilor de testare se realizeazÄƒ astfel Ã®ncÃ¢t fiecare condiÅ£ie din fiecare decizie ia fiecare dintre valorile posibile, cel puÅ£in o datÄƒ; regulÄƒ de selectare: pentru fiecare decizie care conÅ£ine mai multe condiÅ£ii, fiecare condiÅ£ie selectatÄƒ va fi evaluatÄƒ la true sau false ÅŸi se va gÄƒsi pe cel puÅ£in un drum. CC. Exemplu Fiecare condiÅ£ie din fiecare decizie trebuie sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ cu fiecare din valorile posibile (e.g., true, false) // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? CC. Exemplu (cont.) // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? Criteriul de acoperire a condiÅ£iilor este Ã®ndeplinit 100%. Toate rezultatele posibile ale evaluÄƒrii condiÅ£iilor din decizie au fost explorate. CC. ObservaÅ£ii e.g., if (x<10 && y>20) {z=fie(x, y);} else {z=foo(x,y);} pentru x=11 ÅŸi y=21, avem false && true = false; pentru x=1	ÅŸi y=1,	avem true && false = false; fiecare condiÅ£ie selectatÄƒ este acoperitÄƒ prin evaluarea la true ÅŸi false, dar decizia nu este acoperitÄƒ, doar ramificaÅ£ia false este exploratÄƒ; Este necesarÄƒ acoperirea deciziilor ÅŸi condiÅ£iilor. CC vs. DC Ã®n general, cc ===> dc; prin acoperirea condiÅ£iilor se poate acoperi ÅŸi decizia; caz particular: cc = dc atunci cÃ¢nd decizia conÅ£ine doar o condiÅ£ie; e.g., decizia	y<0 este evaluatÄƒ la true sau false, similar cu evaluarea condiÅ£iei y<0, care este evaluatÄƒ la true sau false ==> acoperirea condiÅ£iei este similarÄƒ cu acoperirea deciziei; Acoperirea deciziilor ÅŸi condiÅ£iilor. DefiniÅ£ie acoperirea deciziilor ÅŸi condiÅ£iilor (engl. decision and condition coverage, dcc): proiectarea cazurilor de testare astfel Ã®ncÃ¢t: fiecare condiÅ£ie din fiecare decizie ia toate valorile posibile, cel puÅ£in o datÄƒ; fiecare decizie ia toate valorile posibile cel puÅ£in o datÄƒ; regulÄƒ de selectare: pentru fiecare decizie care conÅ£ine mai multe condiÅ£ii, fiecare condiÅ£ie selectatÄƒ va fi evaluatÄƒ la true sau false ÅŸi Ã®mpreunÄƒ cu decizia evaluatÄƒ la true sau false se vor gÄƒsi pe cel puÅ£in un drum. DCC. Exemplu Fiecare condiÅ£ie din fiecare decizie trebuie sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ cu fiecare din valorile posibile, e.g., true, false. Fiecare decizie trebuie sÄƒ fie executatÄƒ cel puÅ£in o datÄƒ cu fiecare din valorile posibile, e.g., true, false. // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? DCC. Exemplu (cont.) // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? Criteriul de acoperire a deciziilor ÅŸi condiÅ£iilor este Ã®ndeplinit 100%. Toate rezultatele posibile ale evaluÄƒrii condiÅ£iilor din decizie au fost explorate. Ambele ramificaÅ£ii ale deciziei au fost explorate. DCC vs. CC, DCC vs. DC dcc ===> cc; prin acoperirea deciziilor ÅŸi condiÅ£iilor se acoperÄƒ condiÅ£iile; dcc ===> dc; prin acoperirea deciziilor ÅŸi condiÅ£iilor se acoperÄƒ deciziile; caz particular: dcc = dc ÅŸi dcc = cc atunci cÃ¢nd decizia conÅ£ine doar o condiÅ£ie; e.g., decizia y<0 este evaluatÄƒ la true sau false, similar cu evaluarea condiÅ£iei y<0, care este evaluatÄƒ la true sau false ==> acoperirea deciziei ÅŸi condiÅ£iei (dcc) este similarÄƒ cu acoperirea deciziei (dc), care este similarÄƒ cu acoperirea condiÅ£iei (cc); dcc se aplicÄƒ doar atunci cÃ¢nd decizia este formatÄƒ din mai multe condiÅ£ii. DCC. ObservaÅ£ii condiÅ£iile logice care folosesc operatorii && ÅŸi || nu pot fi acoperite prin dcc, deoarece compilatorul realizeazÄƒ diverse optmizÄƒri (scurt-circuitare la evaluare); Este necesarÄƒ acoperirea condiÅ£iilor multiple. Acoperirea condiÅ£iilor multiple. DefiniÅ£ie acoperirea condiÅ£iilor multiple (engl. multiple condition coverage, mcc): proiectarea cazurilor de testare se realizeazÄƒ asfel Ã®ncÃ¢t: toate combinaÅ£iile posibile ale valorilor de ieÅŸire ale unei condiÅ£ii, Ã®n fiecare decizie, sÄƒ fie parcurse cel puÅ£in o datÄƒ; regulÄƒ de selectare: fiecare decizie care conÅ£ine mai multe condiÅ£ii, va combina fiecare condiÅ£ie selectatÄƒ care este evaluatÄƒ la true sau false cu celelalte condiÅ£ii Ã®n toate variantele posibile ÅŸi Ã®mpreunÄƒ cu decizia evaluatÄƒ la true sau false se vor gÄƒsi pe cel puÅ£in un drum. MCC. Exemplu Fiecare condiÅ£ie din fiecare decizie trebuie sÄƒ fie executatÄƒ Ã®n toate combinaÅ£iile posibile cu toate celelalte condiÅ£ii din cadrul aceleaÅŸi decizii. // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? MCC. Exemplu (cont.) // returneazÄƒ true dacÄƒ (x,y) este Ã®n cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numÄƒrul minim de cazuri de testare necesar ? Criteriu de acoperire a condiÅ£iilor multiple Ã®ndeplinit 100%. Toate cominaÅ£iile posibile ale condiÅ£iilor au fost explorate. MCC vs. DCC mcc ===> dcc; prin acoperirea multiplÄƒ a condiÅ£iilor se acoperÄƒ deciziile ÅŸi condiÅ£iile; Testare bazatÄƒ pe acoperirea codului sursÄƒ. Reguli de acoperire minimalÄƒ dacÄƒ programul are o singurÄƒ condiÅ£ie Ã®n fiecare vÃ¢rf de decizie, atunci se aplicÄƒ acoperirea deciziilor (dc), Ã®n acest caz dc = cc; dacÄƒ programul are condiÅ£ii multiple Ã®n vÃ¢rfuri de decizie, atunci se aplicÄƒ acoperirea condiÅ£iilor multiple (mcc). SC vs DC. vs. CC vs. DCC vs. MCC vs. APC Acoperirea buclelor. DefiniÅ£ie acoperirea buclelor (engl. loop coverage, lc); proiectarea cazurilor de testare astfel Ã®ncÃ¢t structurile repetitive sÄƒ fie iterate de un numÄƒr variabil de ori; LC. Clasificarea buclelor. ReprezentÄƒri tipuri de bucle: simple; imbricate; concatenate; nestructurate. LC. Bucle simple bucle simple (n â€“ numÄƒrul maxim de parcurgeri al buclei): omiterea bublei (0 parcurgeri); 1 parcurgere a buclei; 2 parcurgeri ale buclei (evidenÅ£iazÄƒ defecte de iniÅ£ializare); m parcurgeri ale buclei, unde m < n; n-1 parcurgeri ale buclei; n parcurgeri ale buclei; n + 1 parcurgeri ale buclei. LC. Bucle imbricate bucle imbricate: se porneÅŸte de la bucla cea mai interioarÄƒ; toate celelalte bucle sunt setate pe valori minime; se testeazÄƒ bucla cea mai interioarÄƒ ca ÅŸi buclÄƒ simplÄƒ, pÄƒstrÃ¢nd buclele exterioare la valoarea minimÄƒ a parametrului de iteraÅ£ie; se progreseazÄƒ spre exterior, testÃ¢ndu-se urmÄƒtoarea buclÄƒ ÅŸi pÄƒstrÃ¢nd buclele exterioare la valorile minime; se continuÄƒ pÃ¢nÄƒ cÃ¢nd toate buclele sunt testate. LC. Bucle concatenate bucle concatenate: dacÄƒ buclele sunt indepedente unele de altele: se aplicÄƒ testarea buclelor simple; dacÄƒ buclele sunt dependente (e.g., variabila de indexare a primei bucle este valoarea iniÅ£ialÄƒ a celei de a doua): se aplicÄƒ testarea buclelor imbricate. LC. Bucle nestructurate bucle nestructurate: Ã®n general, indicÄƒ folosirea instrucÅ£iunii goto; se recomanda restructurarea acestui tip de buclÄƒ pentru a reflecta elementele programÄƒrii structurate. TESTARE WHITE-BOX VS. TESTARE BLACK-BOX Testare White-Box. Avantaje si dezavantaje Testare White-Box vs. Testare Black-Box Testare White-Box Avantaje cazurile de testare sunt proiectate pe baza structurii interne a codului sursÄƒ, i.e., Ã®n funcÅ£ie de structurile de programare folosite; identificÄƒ disfuncÅ£ionalitÄƒÅ£i Ã®n execuÅ£ia anumitor secvenÅ£e de cod, e.g., unele structuri de programare nu sunt acoperite; permite acoperirea cu teste a codului scris; Dezavantaje nu poate testa cerinÅ£e care nu sunt implementate, nu poate identifica bug-urile din codul sursÄƒ care lipseÈ™te; proiectarea cazurilor de testare poate Ã®ncepe doar dupÄƒ implementare; testerul trebuie sÄƒ cunoascÄƒ limbajul de programare Ã®n care a fost elaborat codul sursÄƒ; ineficientÄƒ pentru module de mari dimensiuni. Testarea Black-Box vs. Testare White-Box Testare Black-Box Testare funcÅ£ionalÄƒ, testare comportamentalÄƒ (engl. behavioral testing); cazurile de testare sunt proiectate pe baza specificaÅ£iilor, nu este necesar sÄƒ avem acces la codul sursÄƒ; suprinde ambiguitÄƒÅ£ile sau inconsistenÅ£ele din specificaÅ£ii; nu se existÄƒ informaÅ£ii despre implementare; activitatea testerului este independentÄƒ de cea a programatorului; testerul poate proiecta cazurile de testare Ã®nainte de finalizarea codului sursÄƒ; eficientÄƒ ÅŸi pentru module de mari dimensiuni. Testare White-Box Testare structuralÄƒ (engl. structural testing); cazurile de testare sunt proiectate pe baza structurii interne a codului sursÄƒ, i.e., Ã®n funcÅ£ie de structurile de programare folosite; nu poate testa cerinÅ£e care nu sunt implementate; proiectarea cazurilor de testare poate Ã®ncepe doar dupÄƒ implementare; ineficientÄƒ pentru module de mari dimensiuni â€“ construirea CFG ÅŸi calculul CC sunt activitÄƒÅ£i costisitoare. Testarea Black-Box vs. Testarea White-Box ÃntrebÄƒri: Ce cazuri de testare trebuie actualizate dupÄƒ modificarea specificaÈ›iilor È™i a codului sursÄƒ asociat? Ce cazuri de testare trebuie actualizate dupÄƒ modificarea codului sursÄƒ, fÄƒrÄƒ modificarea specificaÅ£iilor? PENTRU EXAMEN... Pentru examen... testare white-box: definiÅ£ie, caracteristici, avantaje ÅŸi dezavantaje; CFG (definiÅ£ie ÅŸi construire), drumuri independente (definiÅ£ie), CC (definiÅ£ie, 3 moduri de calcul); construirea CFG, determinarea drumurilor independente ÅŸi calculul CC (3 moduri) pentru metode concrete; criteriile de acoperire apc, sc, dc, cc, dcc, mcc ÅŸi lc (definiÅ£ie, compararea a douÄƒ criterii, relaÅ£iile existente Ã®ntre criterii); testare black-box vs. testare white-box. Cursul urmÄƒtor... Niveluri de testare DefiniÅ£ie. Clasificare Testare unitarÄƒ Testare de integrare Testare funcÅ£ionalÄƒ Testare de sistem Testare funcÅ£ionalÄƒ Testare non-funcÅ£ionalÄƒ Testare de acceptare Nivel de testare vs. Tip de testare ReferinÈ›e bibliografice [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [Collard2003] J. F. Collard, I. Burnstein. Practical Software Testing. Springer-Verlag New York, Inc., 2003. [Beizer1990] Beizer, B., Software Testing Techniques, Van Nostrand Reinhold., New York, 1990. CURS 04. NIVELURI DE TESTARE Verificarea È™i validarea sistemelor soft [18 Martie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut Niveluri de testare DefiniÅ£ie. Clasificare Testare unitarÄƒ DefiniÅ£ie. MotivaÈ›ie. Caracteristici Proiectarea cazurilor de testare Tipuri de bug-uri identificate Reguli generale de aplicare Testare de integrare DefiniÅ£ie. MotivaÈ›ie. Clasificare Integrare non-incrementalÄƒ. Integrare incrementalÄƒ. Integrare mixtÄƒ Compararea strategiilor de integrare Testarea interfeÅ£ei modulelor. DefiniÅ£ie. Clasificare Tipuri de bug-uri identificate Exemplu Testare de sistem DefiniÅ£ie. Caracteristici Testare funcÅ£ionalÄƒ Testare non-funcÅ£ionalÄƒ Testare de acceptare DefiniÅ£ie. Caracteristici. Etape de realizare Clasificare Alpha Testing. Beta Testing Alpha Testing vs Beta Testing Alte tipuri de testare de acceptare DificultÄƒÅ£i de testare Nivel de testare vs. Tip de testare Tip de testare. Nivel de testare. DefiniÅ£ie Obiective de testare. Exemple Retestare. DefiniÅ£ie Testare de regresie. DefiniÅ£ie Retestare vs Testare de regresie Pentru examen... Bibliografie NIVELURI DE TESTARE DefiniÅ£ie. Clasificare Nivel de testare. DefiniÅ£ie. Clasificare nivel de testare (engl. testing level): o serie de activitÄƒÅ£i de testare asociate unei etape din procesul de dezvoltare a produsului soft; clasificare: testare unitarÄƒ / testare de modul (engl. unit testing, module testing); etapa: implementare/codificare; testare de integrare (engl. integration testing); etapa: proiectare; testare de sistem (engl. system testing); etapa: specificarea cerinÈ›elor sistemului = stabilirea obiectivelor de realizat; testare de acceptare (engl. acceptance testing); etapa: descrierea cerinÈ›elor utilizatorului. TESTARE UNITARÄ‚ DefiniÅ£ie. MotivaÈ›ie. Caracteristici Proiectarea cazurilor de testare Tipuri de bug-uri identificate Reguli generale de aplicare Testare unitarÄƒ. DefiniÈ›ie. MotivaÈ›ie. Etape testare unitarÄƒ/ testare de modul (engl. unit testing, module testing) : testarea individualÄƒ a unor unitÄƒÈ›i separate dintr-un sistem software (funcÈ›ie, procedurÄƒ, clasÄƒ, metodÄƒ); motivaÈ›ie: gestionarea eficientÄƒ a modulelor sistemului â€“ mai Ã®ntÃ¢i se testeazÄƒ modulele; proces de depanare eficient â€“ aplicat la nivel de modul; permite paralelizarea procesului de testare â€“ testare simultanÄƒ pentru mai multe module. etape: contextul de testare; proiectarea cazurilor de testare; execuÈ›ia cazurilor de testare È™i evalurea rezultatelor testÄƒrii. la nivelul testÄƒrii unitare se folosesc diferiÅ£i termeni pentru a indica obiecte, stÄƒri sau caracteristici care apar la proiectarea cazurilor de testare; literatura de specialitate indicÄƒ abordÄƒri diferite Ã®n descrierea obiectelor folosite, denumite generic Test Doubles, sugerÃ¢nd funcÅ£ionarea obiectelor utilizate Ã®n realitate ; tipuri de obiecte utilizate de tool-uri: Dummy â€“ obiecte care sunt transmise ca parametri dar care nu sunt folosite de metodele apelate; e.g., diverÅŸi parametri precizaÅ£i doar pentru a respecta signatura metodei apelate; Fake â€“ obiecte cu implementÄƒri funcÅ£ionale/utilizabile, dar simpliste, care nu sunt adecvate pentru a fi incluse Ã®n livrabilul cÄƒtre client; e.g., o colecÅ£ie de date in-memory; Stubs â€“ obiecte sau metode ale unor obiecte care furnineazÄƒ rezultate prestabilite atunci cÃ¢nd sunt apelate Ã®n cadrul unui test; nu au altÄƒ utilitate Ã®n afara contextului testÄƒrii unde au fost definite; Spies â€“ obiecte stub care pot pÄƒstra/reÅ£ine informaÅ£ii referitoare la modul Ã®n care au fost folosite; e.g., un serviciu pentru e-mail care reÅ£ine numÄƒrul de mesaje transmise; Mocks â€“ obiecte pentru care s-a stabilit un anumit comportament (behavior expectations) ÅŸi sunt utilizate pentru a observa interacÅ£iunea cu obiectul supus testÄƒrii. Testare unitarÄƒ. Context de testare tipuri de module: driver (engl. driver): modul apelant al modulului testat, care furnizeazÄƒ datele de intrare modulului testat; stub (engl. dummy subprogram): modul apelat Ã®n cadrul modulului testat, Ã®nlocuieÈ™te modulul apelat Ã®n contextul real; aratÄƒ cÄƒ modulul testat apeleazÄƒ un modul subordonat; returneazÄƒ o valoare prestabilitÄƒ Ã®n modulul testat care sÄƒ Ã®i permitÄƒ sÄƒ Ã®È™i continue execuÈ›ia; pentru fiecare modul testat trebuie sÄƒ existe un driver dedicat È™i mai multe module stub, dacÄƒ este necesar; modulele driver È™i stub sunt create suplimentar (engl. overhead) È™i nu sunt livrate Ã®mpreunÄƒ cu produsul final; Testare unitarÄƒ. Proiectarea cazurilor de testare caracteristici: aplicÄƒ tehnici de testare black-box, grey-box È™i white-box; foloseÈ™te documentele care conÅ£in specificaÈ›ia modulelor; informaÈ›ii necesare proiectÄƒrii unui caz de testare pentru un modul: specificaÈ›ia modulului; codul sursÄƒ pentru modul; tipuri de bug-uri identificate: testarea black-box: nerespectarea condiÈ›iilor impuse Ã®n specificaÅ£ii; Ã®nÈ›elegerea greÈ™itÄƒ a specificaÈ›iilor; testarea white-box: Ã®nÈ›elegerea greÈ™itÄƒ a precedenÈ›ei operatorilor; iniÈ›ializare incorectÄƒ; lipsa acurateÈ›ei/preciziei; operaÈ›ii aplicate eronat. numÄƒr de paÅŸi de executat; execuÅ£ie: planificare ÅŸi duratÄƒ; consecvenÅ£Äƒ; atomicitate; responsabilitate unicÄƒ; izolarea testelor; izolarea de mediul de execuÅ£ie; izolarea claselor; automatizare completÄƒ; self-descriptive; fÄƒrÄƒ condiÅ£ii logice; fÄƒrÄƒ bucle; fÄƒrÄƒ tratarea excepÅ£iilor; utilizarea instrucÅ£iunilor assert; utilizarea de mesaje sugestive; fÄƒrÄƒ testare Ã®n codul sursÄƒ livrat; separarea pe module ÅŸi niveluri ale arhitecturii; gruparea testelor Ã®n funcÅ£ie de tipul de testare. numÄƒr de paÅŸi de executat: 3-5 paÅŸi: set up; date de intrare; apelarea metodei testate; verificarea rezultatului (assert); tear down; timp de execuÅ£ie: frecvenÅ£a de execuÅ£ie: testare dupÄƒ implementare (engl. test after development): de cÃ¢teva ori pe zi; dezvoltare dirijatÄƒ de testare (engl. test driven development): de cÃ¢teva ori pe orÄƒ; execuÅ£ie dupÄƒ salvare, IDE (engl. IDE runs tests after save): la fiecare cÃ¢teva minute; mod de execuÅ£ie (singular sau suitÄƒ de teste): timp de execuÅ£ie pentru 10 teste = timp de execuÅ£ie 1 test x 10; un test care se executÄƒ greu, Ã®ncetineÅŸte Ã®ntreaga suitÄƒ de teste; valori medii: un test < 200 milisecunde; o suitÄƒ cu numÄƒr de redus de teste < 10 secunde; o suitÄƒ cu numÄƒr consistent de teste < 10 minute. consecvenÅ£Äƒ: execuÅ£ia repetatÄƒ a aceluiaÅŸi test ar trebui sÄƒ returneze Ã®n mod repetat acelaÅŸi rezultat, dacÄƒ nu au avut loc modificÄƒri asupra codului sursÄƒ; cod sursÄƒ problematic: Date current Date = new Date(); Int value = random.nextInt(100); soluÅ£ii: utilizarea obiectelor dummy, mock, stub, fake; injectarea dependenÅ£elor. atomicitate: rezultate posibile ale execuÅ£iei unui test: passed; failed; nu existÄƒ teste care â€au trecutâ€ doar parÅ£ial; dacÄƒ un punct de execuÅ£ie este failed ==> Ã®ntregul test este failed. un caz de testare investigheazÄƒ un singur scenariu de execuÅ£ie; se testeazÄƒ comportamentul metodei: o metodÄƒ, mai multe utilizÄƒri (comportamente) ==> mai multe teste ÅŸi cel puÅ£in un test pentru fiecare comportament; mai multe instrucÅ£iuni assert Ã®n acelaÅŸi test â€“ doar dacÄƒ verificÄƒ acelaÅŸi comportament; o utilizare (comportament) descrisÄƒ prin folosirea mai multor metode ==> un singur test; E.g.: o metodÄƒ care apeleazÄƒ metode private/ protected/ publice, simple, e.g., getters, setters, constructori simpli. o metodÄƒ, mai multe utilizÄƒri (comportamente) ==> mai multe teste; o utilizare (comportament) descrisÄƒ prin folosirea mai multor metode ==> un singur test; comportament 1 = condition1 + condition2 + condition3 ; comportament 2 = condition4 + condition5; izolarea testelor (unele de altele): testele trebuie sÄƒ fie independente unele de altele. la execuÅ£ii diferite (la momente de timp diferite, Ã®n ordine diferitÄƒ) ale aceluiaÅŸi test trebuie sÄƒ se obÅ£inÄƒ aceleaÅŸi rezultate. nu se partajeazÄƒ starea/ contextul de execuÅ£ie Ã®ntre teste; variabile folosite la testare, e.g., JUnit â€“ variabile partajate sau nu Ã®ntre teste: @Before, @BeforeClass. testele trebuie izolate de influenÅ£ele mediului de execuÅ£ie; E.g., baze de date; apelarea serviciilor web; Java Naming and Directory Interface (JNDI); variabile de mediu definite local; fiÅŸiere de proprietÄƒÅ£i; configurÄƒrile de datÄƒ ÅŸi orÄƒ ale sistemului. codul sursÄƒ livrabil (engl. production code) foloseÅŸte mediul de execuÅ£ie; la testare se foloseÅŸte un mediu de testare, care nu este Ã®ntotdeauna identic cu mediul de execuÅ£ie de la dezvoltarea codului sursÄƒ sau de la client; soluÅ£ie: se utilizeazÄƒ obiecte mock care indicÄƒ un anumit mediu de utilizare; Avantaje: rapiditate; uÅŸor de dezvoltat; reutilizabilitate; E.g.: biblioteci Java: EasyMock; Jmock; Mockito. izolarea claselor: clase fÄƒrÄƒ dependenÅ£e clase cu dependenÅ£e soluÅ£ie: dependenÅ£e dummy, mock, stub, fake; izolarea claselor: dificil de realizat dacÄƒ avem un cod sursÄƒ greu de testat; se recomandÄƒ: folosirea metodelor Factory sau injectarea dependenÅ£elor, Ã®n locul apelului constructorilor Ã®n cadrul metodelor; folosirea interfeÅ£elor. automatizare completÄƒ: fÄƒrÄƒ paÅŸi executaÅ£i manual pe durata testÄƒrii. se automatizeazÄƒ: execuÅ£ia testelor; colectarea rezultatelor testÄƒrii; stabilirea rezultatului testÄƒrii (passed/ failed); trasmiterea rezultatelor testÄƒrii prin: e-mail, IDE integration, etc; self-descriptive: la nivelul testÄƒrii unitare un test reprezintÄƒ: documentaÅ£ie la nivel de dezvoltare; metodÄƒ de specificare care reflectÄƒ versiunea actualizatÄƒ a cerinÅ£elor; caracteristici: un test trebuie sÄƒ fie uÅŸor de citit ÅŸi Ã®nÅ£eles; denumirile variabilelor, metodelor ÅŸi claselor trebuie sÄƒ fie self-descriptive; nu trebuie sÄƒ conÅ£inÄƒ condiÅ£ii logice sau iteraÅ£ii; numele cazurilor de testare trebuie sÄƒ fie sugestive pentru a indica condiÈ›ia de succes sau eÈ™ec: public void canMakeReservation(); public void cannotAddNewBook(); fÄƒrÄƒ instrucÅ£iuni logice: un caz de testare nu ar trebui sÄƒ conÅ£inÄƒ instrucÅ£iunea if sau switch; nu existÄƒ incertitudini legate de: datele de intrare ==> toate datele de intrare sunt cunoscute; comportamentul aÅŸteptat ==> comportamentul metodei este predictibil; datele de ieÅŸire ==> rezultatele aÅŸteptate ar trebui sÄƒ fie bine definite. fÄƒrÄƒ instrucÅ£iuni logice: mai multe condiÅ£ii trebuie sÄƒ se regÄƒseascÄƒ Ã®n cazuri de testare distincte, nu Ã®n acelaÅŸi test, fiind tratate ca ÅŸi ramificaÅ£ii ale instrucÅ£iunilor alternative, i.e., if, switch; fÄƒrÄƒ instrucÅ£iuni iterative (i.e., while, do while, for): scenarii tipice pentru iteraÅ£ii: cÃ¢teva sute de iteraÅ£ii: dacÄƒ sunt necesare cÃ¢teva sute de iteraÅ£ii, atunci testul este destul de complicat ÅŸi este necesar sÄƒ fie simplificat; cÃ¢teva iteraÅ£ii: se recomandÄƒ refactorizarea codului care trebuie sÄƒ se repete Ã®ntr-o metodÄƒ, care sÄƒ fie apelatÄƒ ulterior explicit de cÃ¢te ori este necesar; numÄƒr de iteraÅ£ii necunoscut: numÄƒrul de iteraÅ£ii este greu de evitat, indicÃ¢nd faptul cÄƒ e posibil ca testul sÄƒ fie incorect ÅŸi se recomandÄƒ specificarea mai clarÄƒ a datelor de intrare; instrucÅ£iunea assert: se recomandÄƒ: utilizarea instrucÅ£iunilor assert disponibile Ã®n platforma de testare; crearea propriilor aserÅ£iuni pentru verificarea condiÅ£iilor complexe care se repetÄƒ Ã®n diferite teste; reutilizarea propriilor metode asertive; utilizarea aserÅ£iunilor Ã®n cadrul buclelor. mesaje sugestive Ã®n instrucÅ£iunea assert: prin citirea mesajului din aserÅ£iune se poate recunoaÅŸte uÅŸor problema care a determinat eÅŸuarea testului; avantaje: permit Ã®mbunÄƒtÄƒÅ£irea documentaÅ£iei codului sursÄƒ; oferÄƒ informaÅ£ii asupra problemei dacÄƒ testul a eÅŸuat (failed). codul sursÄƒ nu include teste: se recomandÄƒ: separarea testelor de codul sursÄƒ livrat; clasele sÄƒ nu defineascÄƒ metode ÅŸi/sau atribute care sunt folosite doar la testare. gruparea testelor Ã®n funcÅ£ie de tipul de testare: dupÄƒ modulul testat: organizarea testelor Ã®n pachete corespunzÄƒtoare modulelor testate; utilizarea unei abordÄƒri ierarhizate; scÄƒderea timpului de execuÅ£ie pentru suitele de teste prin Ã®mpÄƒrÅ£irea acestora Ã®n suite de dimensiuni mai mici, i.e., suitele de mici dimensiuni pot fi executate mai des/frecvent; dupÄƒ tip: scopul / obiectivele testÄƒrii; frecvenÅ£a de execuÅ£ie; momentul execuÅ£iei suitei; acÅ£iunea Ã®n caz de eÅŸec. TESTARE DE INTEGRARE DefiniÅ£ie. MotivaÈ›ie. Clasificare Integrare non-incrementalÄƒ. Integrare incrementalÄƒ. Integrare mixtÄƒ Compararea strategiilor de integrare Testarea interfeÅ£ei modulelor. DefiniÅ£ie. Clasificare Tipuri de bug-uri identificate Exemplu Testare de integrare. DefiniÅ£ie. MotivaÅ£ie testare de integrare (engl. integration testing): nivel de testare Ã®n care modulele individuale se combinÄƒ ÅŸi se testeazÄƒ ca un grup; permite construirea structurii programului pe mÄƒsurÄƒ ce este testat pentru a identifica erorile la nivelul interfeÅ£ei dintre module; motivaÅ£ie: module diferite sunt implementate de programatori diferiÅ£i; testarea unitarÄƒ se desfÄƒÅŸoarÄƒ Ã®ntr-un mediu controlat ÅŸi izolat, folosind entitÄƒÅ£i driver ÅŸi stub (mock, fake, dummy); unele module pot genera mai multe defecÅ£iuni decÃ¢t altele. Testare de integrare. Clasificare abordÄƒri de integrare/ clasificare: non-incrementalÄƒ big-bang; incrementale top-down; bottom-up; mixtÄƒ sandwich. Integrarea Big-bang. Descriere Procesul de integrare Big-bang: testare unitarÄƒ pentru fiecare modul, folosind: un modul driver; cÃ¢teva module stub; se combinÄƒ simultan modulele pentru construirea funcÅ£ionalitÄƒÅ£ii programului; dezavantaje: necesitÄƒ un volum de muncÄƒ ridicat; depanare dificilÄƒ â€“ este dificil de izolat modulul care a determinat defecÅ£iunea; dacÄƒ programul este complex â€“ este dificil de urmÄƒrit modul Ã®n care s-au executat funcÅ£ionalitÄƒÅ£ile. avantaje: dezvoltare ÅŸi testare unitarÄƒ paralelÄƒ. Integrare incrementalÄƒ Top-down. Descriere integrare incrementalÄƒ Top-down (engl. Top- down incremental integration): permite construirea ÅŸi testarea programului adÄƒugÃ¢nd module noi pe parcurs; integrarea modulelor se face de sus Ã®n jos, de la modulul principal, modulele subordonate sunt Ã®ncorporate succesiv; defectele sunt uÅŸor de izolat ÅŸi corectat; testarea este aplicatÄƒ sistematic. tipuri de integrare Top-down: Ã®n adÃ¢ncime (engl. depth-first integration); pe niveluri (engl. breadth-first integration); integrarea depth-first integreazÄƒ toate componentele de pe o ramificaÅ£ie majorÄƒ a arhitecturii aplicaÅ£iei; ordinea de integrare a ramificaÅ£iilor depinde de caracteristicile aplicaÅ£iei; integrarea breadth-first integreazÄƒ toate componentele care se aflÄƒ pe nivelul direct subordonat, i.e., pe orizontalÄƒ; Integrare incrementalÄƒ Top-down. Algoritm dupÄƒ testarea unitarÄƒ a modulului principal folosind stub-uri pentru modulele imediat subordonate, procesul de integrare Top-down constÄƒ Ã®n: Ã®n funcÅ£ie de tipul de integrare ales (depth-first/ breadth-first), se Ã®nlocuieÅŸte un stub cu un modul real; se testeazÄƒ cu modulul subordonat concret care a fost integrat; pentru integrarea unui nou modul se repetÄƒ paÅŸii 1 ÅŸi 2. driver = modulul principal; nu se folosesc alte drivere; stub = Ã®nlocuieÅŸte un modul direct subordonat; E.g., depth-first: M1, M2, M5, M8, M6, M3, M7, M4; breadth-first: M1, M2, M3, M4, M5, M6, M7, M8. Integrare incrementalÄƒ Bottom-up. Descriere integrare incrementalÄƒ Bottom-up (engl. Botton-up incremental integration): permite construirea ÅŸi testarea programului pornind de la modulele atomice, i.e., componentele care nu au module dependente; defectele modulelor aflate pe nivelurile inferioare sunt uÅŸor de izolat ÅŸi corectat. modulele terminale se pot organiza Ã®n grupuri (engl. clusters); driver = se folosesc doar pentru modulele terminale (care nu au module subordonate) sau grupurile de module; stub = nu se folosesc; Integrare incrementalÄƒ Bottom-up. Algoritm Procesul de integrare Bottom-up: pentru toate modulele terminale sau clusteri de module se descriu drivere ÅŸi se testeazÄƒ; module terminale: se Ã®nlocuieÅŸte driver-ul cu modulul de pe nivelul imediat superior ÅŸi se testeazÄƒ, continuÃ¢nd integrarea modulelor spre partea superioarÄƒ a structurii programului; clusteri de module: se Ã®nlÄƒturÄƒ driver-ul, iar clusterul de module se combinÄƒ cu alte module continuÃ¢nd integrarea spre partea superioarÄƒ a structurii programului. componentele se combinÄƒ Ã®n clusterii 1 , 2 ÅŸi 3; clusterii se testeazÄƒ folosind driver-ele D1, D2 ÅŸi D3; se Ã®nlÄƒturÄƒ D1 ÅŸi D2, iar clusterul 1 ÅŸi clusterul 2 sunt integraÅ£i Ã®n Ma; similar, D3 este Ã®nlÄƒturat iar clusterul 3 este integrat cu modulul Mb. Ma ÅŸi Mb se vor integra Ã®n Mc. Integrare Sandwich. Descriere integrare sandwich (engl. sandwich integration): permite construirea ÅŸi testarea programului combinÃ¢nd abordÄƒrile de integrare top-down ÅŸi bottom-up; Procesul de integrare Sandwich: modulele terminale (bottom-layer): integrare bottom-up; modulul principal (top-layer): integrare top-down; celelalte module (middle-layer): integrare big-bang. Testare de integrare. Compararea strategiilor de integrare Testarea interfeÅ£ei modulelor. DefiniÅ£ie. Clasificare testarea interfeÅ£ei modulelor (engl. interface integration testing): se realizeazÄƒ la integrarea mai multor module pentru obÅ£inerea unor sisteme de dimeniuni mai mari; relevantÄƒ Ã®n dezvoltarea orientatÄƒ pe obiecte, comportamentul acestora fiind descris prin intermediul interfeÅ£elor; obiective: identificarea defectelor care pot apÄƒrea la utilizarea unei interfeÅ£e a unui alt modul sau false presupuneri legate de interfaÅ£a unui modul; comunicarea Ã®ntre module poate fi bazatÄƒ pe: parametri: la transmiterea datelor de la o metodÄƒ la alta; memorie partajatÄƒ: o zonÄƒ de memoria este partajatÄƒ Ã®ntre module; comportament: un sub-sistem Ã®ncapsuleazÄƒ un set de metode care sunt apelate de alte sub- sisteme; mesaje: un sub-sistem are nevoie de serviciile altor sub-sisteme; Testarea interfeÅ£ei modulelor. Tipuri de bug-uri identificate tipuri de bug-uri [, pagina 161]: utilizarea greÅŸitÄƒ a interfeÅ£ei (engl. interface misuse): un modul apeleazÄƒ un alt modul eronat, e.g., parametrii sunt transmiÅŸi Ã®n ordinea greÅŸitÄƒ; Ã®nÅ£elegerea greÅŸitÄƒ a semnificaÅ£iei interfeÅ£ei (engl. interface misunderstanding): un modul face presupuneri greÅŸite referitare la comportamentul unui alt modul apelat, e.g., se interpreteazÄƒ cÄƒ mai mulÅ£i parametri de acelaÅŸi tip au altÄƒ semnificaÅ£ie; greÅŸeli de sincronizare (engl. timing errors): modulul apelat ÅŸi modulul apelant folosesc unitÄƒÅ£i de timp diferite, e.g., minute, secunde, milisecunde, iar informaÅ£ia obÅ£inutÄƒ Ã®ÅŸi pierde acurateÅ£ea. Testare de integrare. Reguli generale de aplicare se studiazÄƒ arhitectura aplicaÅ£iei pentru identificarea modulelor critice; aceste module se testeazÄƒ cu prioritate; testerul este familiarizat cu modulele care se integreazÄƒ (arhitectura modulelor); se aplicÄƒ o strategie de integrare care sÄƒ permitÄƒ atingerea obiectivelor testÄƒrii; fiecare modul este testat Ã®nainte de a execuÅ£ia testelor de integrare, i.e., unit testing; se utilizeazÄƒ documentaÅ£ia care descrie interacÅ£iunile dintre fiecare douÄƒ module (interfeÅ£ele acestora ÅŸi modul de colaborare). TESTARE DE SISTEM DefiniÅ£ie. Caracteristici Testare funcÅ£ionalÄƒ Testare non-funcÅ£ionalÄƒ Testare de sistem. DefiniÅ£ie. Caracteristici testare de sistem (engl. system testing): verificÄƒ dacÄƒ produsul dezvoltat respectÄƒ obiectivele iniÅ£iale; elaborarea cazurilor de testare se bazeazÄƒ pe: documentul cu specificaÅ£iile sistemului? nu, deoarece pot apÄƒrea erori Ã®n procesul de transpunere a obiectivelor Ã®n specificaÅ£ii externe; documentele cu obiectivele stabilite? nu, deoarece nu conÅ£in descrierea exactÄƒ a interfeÅ£elor externe ale programului; obiectivele nu oferÄƒ informaÅ£ii cu privire la funcÅ£ionalitatea sistemului (interfeÅ£e ale documentaÅ£ia de utilizare a produsului soft? da; proiectarea testÄƒrii de sistem â€“ pe baza analizei obiectivelor; descrierea cazurilor de testare â€“ pe baza analizei documentaÅ£iei de utilizare. Testare de sistem. Caracteristici nu existÄƒ metodologie pentru proiectarea cazurilor de testare Ã®n testarea de sistem; se proiecteazÄƒ douÄƒ categorii de teste asociate: cerinÅ£ele funcÅ£ionale ==> testare funcÅ£ionalÄƒ; cerinÅ£ele non-funcÅ£ionale ==> testare non-funcÅ£ionalÄƒ (engl. non-functional testing); la acest nivel de testare, proiectarea cazurilor de testare este determinatÄƒ de obiectivele de testare ÅŸi de strategia aleasÄƒ, evidenÅ£iind creativitatea ÅŸi experienÅ£a. Testare de sistem. Testare funcÅ£ionalÄƒ a sistemului testare funcÅ£ionalÄƒ a sistemului (engl. function/functional testing, use case testing): testarea cerinÅ£elor descrise Ã®n specificaÅ£iile sistemului; proces care identificÄƒ neconcordanÅ£ele existente Ã®ntre comportamentul programului ÅŸi specificaÅ£ia acestuia, din punctul de vedere al utilizatorului; elaborarea cazurilor de testare se bazeazÄƒ pe criteriul black-box; foloseÅŸte specificaÅ£ia sistemului. Testare funcÅ£ionalÄƒ a sistemului. Proiectarea cazurilor de testare caz de utilizare vs. caz de testare: cazurile de utilizare descriu fluxul de execuÅ£ie al unui proces Ã®n cadrul sistemului, folosind scenarii de utilizare frecventÄƒ; cazurile de testare sunt derivate din cazurile de utilizare ÅŸi pot indica prezenÅ£a unui bug la utilizarea concretÄƒ a sistemului; fiecare caz de testare se bazeazÄƒ de obicei pe un scenariu ÅŸi acoperÄƒ diferite ramificaÅ£ii de execuÅ£ie (indicate prin cazuri speciale de date de intrare sau condiÅ£ii speciale); pentru un caz de testare specificÄƒ: toate precondiÅ£iile care este necesar sÄƒ fie satisfÄƒcute pentru execuÅ£ia cazului de utilizare cu succes; postcondiÅ£iile impuse asupra rezultatelor obÅ£inute; descrierea stÄƒrii finale a sistemului dupÄƒ ce testarea cazului de utilizare s-a realizat cu succes; Testare de sistem. Testare non-funcÅ£ionalÄƒ. DefiniÅ£ie testare non-funcÅ£ionalÄƒ (engl. non- functional testing): verificÄƒ modul Ã®n care sistemul Ã®ndeplineÅŸte cerinÅ£ele non-funcÅ£ionale; stabileÅŸte dacÄƒ sistemul este pregÄƒtit pentru a fi efectiv utilizat; Ã®n [, Cap 6] sunt descrise 15 tipuri de testare (non-funcÅ£ionalÄƒ) de sistem pentru care se scriu cazuri de testare: Volume testing; Stress testing; Usability testing; Security testing; Performance testing; Storage testing; Configuration testing; Compatibility/Conversion testing; Instability testing; Reliability testing; Recovery testing; Serviceability testing; Documentation testing; Procedure testing; Facility testing. performance testing: - cÃ¢t de bine face sistemul ceea ce trebuie sÄƒ facÄƒ fiecare sistem are cerinÅ£e referitoare la performanÅ£a utilizÄƒrii; e.g., execuÅ£ia unei funcÅ£ionalitÄƒÅ£i sÄƒ fie realizatÄƒ Ã®ntr-un anumit interval de timp, iar resursele sÄƒ nu fie infinite; bug-urile legate de performanÅ£Äƒ indicÄƒ deficienÅ£e la nivel de proiectare care determinÄƒ degradarea performanÅ£ei sistemului soft Ã®n timpul utilizÄƒrii; obiectiv: identificarea blocajelor determinate de reducerea performanÅ£ei componentelor ÅŸi a sistemelor, i.e., bottlenecks; tipuri: Capacity Testing, Load Testing; Volume Testing, Stress Testing; Soak Testing, Spike Testing. capacity testing: permite preveniea eventualelor probleme determinate de creÅŸterea numÄƒrului de utilizatori sau a volumului de date; obiectiv: obÅ£inerea de informaÅ£ii referitoare la nivelul maxim de utilizatori ÅŸi/sau date care nu afecteazÄƒ performanÅ£a: E.g.: cÃ¢te fiÅŸiere pot fi folosite fÄƒrÄƒ a afecta performanÅ£a. load testing: evalueazÄƒ capacitatea sistemului de opera cu volume de date normale sau Ã®n condiÅ£ii de solicitare (vÃ¢rf); obiectiv: obÅ£inerea de informaÅ£ii referitoare la comportamentul sistemului Ã®n anumite condiÅ£ii de utilizare, i.e., normale ÅŸi de solicitare: E.g.: creÅŸterea numÄƒrului de fiÅŸiere folosite. volume testing: evalueazÄƒ comportamentul sistemului atunci cÃ¢nd se gestioneazÄƒ volume mari de date; obiectiv: obÅ£inerea de informaÅ£ii legate de funcÅ£ionarea aplicaÅ£iei cu un volum de date ridicat: E.g.: creÅŸterea dimensiunii fiÅŸierelor folosite. stress testing: - pune presiune asupra limitelor sistemului investigheazÄƒ dacÄƒ comportamentul softului se degradeazÄƒ Ã®n condiÅ£ii extreme de utilizare ÅŸi cÃ¢nd nu are acces la resursele necesare; este de dorit ca degradarea softului cauzatÄƒ de creÅŸterea numÄƒrului de cereri sÄƒ se realizeze acceptabil, fÄƒrÄƒ sÄƒ ducÄƒ la un eÅŸec imediat Ã®n timpul testÄƒrii; sistemul nu trebuie sÄƒ eÅŸueze catrastofal; relevant pentru sistemele distribuite care pot indica o degradare severÄƒ atunci cÃ¢nd reÅ£eaua devine Ã®ncÄƒrcatÄƒ; obiectiv: obÅ£inerea de informaÅ£ii despre modul Ã®n care sistemul funcÅ£ioneazÄƒ Ã®n condiÅ£ii extreme, dincolo de limitele normale: E.g.: creÅŸterea numÄƒrului de fiÅŸiere folosite pÃ¢nÄƒ la failure ÅŸi chiar mai mult; verificÄƒ dacÄƒ are loc o pierdere inacceptabilÄƒ de date ÅŸi/sau imposibilitatea de a utiliza anumite servicii. soak testing: verificÄƒ dacÄƒ sistemul face faÅ£Äƒ unui volum mari de date pentru o perioadÄƒ mai mare de timp; obiectiv: obÅ£inerea de informaÅ£ii legate de posibilitatea de a utiliza volum de date ÅŸi care sunt consecinÅ£ele dacÄƒ se depÄƒÅŸeÅŸte vomulul pentru care a fost proiectat: E.g.: verificÄƒ dacÄƒ creÅŸterea dimensiunii fiÅŸierelor folosite este suportatÄƒ. spike testing: evalueazÄƒ comportamentul sistemului la schimbÄƒri bruÅŸte ÅŸi extreme a condiÅ£iilor de lucru, i.e., puÅ£ine sarcini, multe sarcini; obiectiv: obÅ£inerea de informaÅ£ii legate de punctele slabe ale sistemului determinate de modificarea rapidÄƒ a condiÅ£iilor de lucru: E.g.: creÅŸterea brusc ÅŸi diminuarea rapidÄƒ a numÄƒrului de fiÅŸiere cu care se lucreazÄƒ. reliability testing: investigheazÄƒ capacitatea un soft de a funcÅ£iona conform aÅŸteptÄƒrilor utilizatorului, chiar ÅŸi atunci cÃ¢nd eÅŸueazÄƒ; determinÄƒ cÃ¢t timp ÅŸi cÃ¢t de eficient poate funcÅ£iona sistemul fÄƒrÄƒ eroare; security testing: calitatea, securitatea ÅŸi gradul de Ã®ncredere Ã®n aplicaÅ£ie (engl. reliability) sunt caracteristici depedendente; defectele produsului soft pot fi exploatate pentru a identifica breÅŸe de securitate; presupune simularea unor atacuri la nivel de securitate, avÃ¢nd scopul de a identifica vulnerabilitÄƒÅ£ile softului. TESTARE DE ACCEPTARE DefiniÅ£ie. Caracteristici. Etape de realizare. Clasificare Alpha Testing. Beta Testing Alpha Testing vs Beta Testing Alte tipuri de testare de acceptare DificultÄƒÅ£i de testare Testare de acceptare. DefiniÅ£ie. Clasificare testare de acceptare (engl. user acceptance testing, UAT): procesul de testare prin care se verificÄƒ dacÄƒ programul Ã®ndeplineÅŸte cerinÅ£ele iniÅ£iale ÅŸi nevoile curente ale utilizatorului final; nu este responsabilitatea dezvoltatorului produsului; tester = clientul/ beneficiarul; realizatÄƒ efectiv de cÄƒtre client, care aplicÄƒ tehnici de testare black-box. tipuri de testare de acceptare: alpha testing, beta testing; contract acceptance testing; regulation acceptance testing; operational acceptance testing. Testare de acceptare. Etape de realizare etape de realizare: definirea criteriilor prin care produsul soft este considerat funcÅ£ional; creare unei suite de cazuri de testare pentru UAT; rularea testelor UAT; evaluarea ÅŸi raportarea rezultatelor. Testare de acceptare. Alfa Testing. Beta Testing Testare de acceptare. Alpha Testing vs Beta Testing Testare de acceptare. Tipuri de de testare de acceptare contract acceptance testing: produsul soft este testat din perspectiva Ã®ndeplinirii unor criterii ÅŸi specificaÅ£ii care sunt precizate Ã®ntr-un contract de colaborare Ã®ntre dezvoltator ÅŸi client; criteriile ÅŸi specificaÅ£iile de acceptanÅ£Äƒ sunt stabilite la semnarea contractului, Ã®nainte de dezvoltarea softului; regulation acceptance testing, i.e., compliance acceptance testing: verificÄƒ dacÄƒ produsul soft dezvoltat respectÄƒ regulamentele ÅŸi legile Ã®n vigoare referitoare de utilizarea ÅŸi funcÅ£ionarea unui produs soft specfic; operational acceptance testing, i.e., operational readiness testing, production acceptance testing: verificÄƒ dacÄƒ existÄƒ fluxurile informaÅ£ionale necesare pentru utilizarea produsului soft de cÄƒtre client (e.g., planuri de backup, training pentru utilizatori, diferite procese de Ã®ntreÅ£inere ÅŸi verificÄƒri de securitate). Testare de acceptare. DificultÄƒÅ£i de testare dificultÄƒÅ£i care apar la nivelul testÄƒrii de acceptare: cerinÅ£e care nu sunt descrise satisfÄƒcÄƒtor (clar, complet, corect); planificarea tÃ¢rzie (defectuoasÄƒ) a activitÄƒÅ£ilor de testare; testarea nu este realizatÄƒ riguros, nu este o activitate planificatÄƒ ÅŸi monitorizatÄƒ; identificarea tardivÄƒ a defectelor, cu dificultÄƒÅ£i de eliminare a acestora. TIP DE TESTARE VS NIVEL DE TESTARE Tip de testare. Nivel de testare. DefiniÅ£ie Obiective de testare. Exemple Retestare. DefiniÅ£ie Testare de regresie. DefiniÅ£ie Retestare vs Testare de regresie Tip de testare. Nivel de testare. DefiniÅ£ie nivel de testare (engl. testing level): o serie de activitÄƒÅ£i de testare asociate unei etape din procesul de dezvoltare al produsului soft; Ce testez? tip de testare (engl. testing type): mijlocul prin care un obiectiv al testÄƒrii, stabilit anterior pentru un nivel de testare, poate fi realizat; Cum testez? Tip de testare. Exemple exemple de tipuri de testare: testarea unei metode: se poate realiza prin aplicarea unor criterii de testare (black-box, white-box), la nivelul testÄƒrii unitare sau de integrare; testarea unei caracteristici non-funcÅ£ionale: se realizeazÄƒ prin aplicarea unui anumit tip de testare, e.g., testare de performanÅ£Äƒ, testare de utilizabilitate, cu scopul de a evalua o caracteristicÄƒ a calitÄƒÅ£ii produslui soft, la nivelul testÄƒrii de sistem; testarea dupÄƒ eliminarea unui bug: se realizezÄƒ prin aplicarea re-testÄƒrii (engl. re-testing, confirmation testing) dupÄƒ depanare, la orice nivel de testare; testarea legatÄƒ de eliminarea unui bug: se realizeazÄƒ prin testarea de regresie (engl. regression testing), pentru a verifica dacÄƒ eliminarea unui bug nu are efecte secundare asupra softului, la orice nivel de testare. Re-testare. DefiniÅ£ie re-testare (engl. re-testing, confirmation testing): re-execuÅ£ia testelor care au pus Ã®n evidenÅ£Äƒ anterior un bug ce se presupune cÄƒ a fost eliminat; scop: confirmarea cÄƒ defectul a fost eliminat; cazurile de testare re-executate sunt identice cu cele rulate anterior; Testare de regresie. DefiniÅ£ie testare de regresie (engl. regression testing): re-execuÅ£ia unor teste care au fost rulate anterior cu succes; scop: identificarea efectelor secundare (bug-uri) care pot apÄƒrea Ã®n urma modificÄƒrii unor module; cazurile de testare se pot organiza in teste de regresie, care permit testarea: tuturor funcÅ£ionalitÄƒÅ£ilor sistemului; funcÅ£ionalitÄƒÅ£ilor cu probabilitate ridicatÄƒ de a fi afectate de modificÄƒri; comportamentului componentelor sistemului care au fost modificate. testare de regresie â‰  re-testare; Niveluri de testare. Tipuri de testare PENTRU EXAMEN... Pentru examen... Niveluri de testare. DefiniÅ£ii ÅŸi caracteristici: testare unitarÄƒ; testare de integrare; 4 strategii (big-bang, top-down, bottom-up, sandwich), descriere, comparare; testare de sistem; testare funcÅ£ionalÄƒ; 5 tipuri de testare non-funcÅ£ionalÄƒ (volume, stress, load, usability, security) . testare de acceptare; alpha testing, beta testing. Tip de testare vs Nivel de testare. DefiniÅ£ii ÅŸi caracteristici: re-testare; testare de regresie. Cursul urmÄƒtor... Curs 05: TematicÄƒ Test Automation Demo: Selenium WebDriver + Serenity BDD Performance Testing Companie IT invitatÄƒ: Evozon Data: MarÈ›i, 25 Martie 2025; Orele: 08:00-10:00; DesfÄƒÅŸurare: Sala 6/II (Gh. CÄƒlugareanu), ClÄƒdirea CentralÄƒ a UBB. Cursul urmÄƒtor... Curs 06: Demo Mockito Create and Solve a Puzzle termen: 02 mai 2025, orele 20:00; echipe: max. 3 studenÅ£i/echipÄƒ, i.e., echipe de forma (A, B, C) sau (A, B); echipele participante pot rezolva unul sau ambele task-uri de mai jos; pentru fiecare task rezolvat corect se acordÄƒ cÃ¢te 2 puncte pentru activitatea Games fiecÄƒrui membru din echipÄƒ; Task 01. Create a Puzzle: cu min. 20 concepte studiate la VVSS; se va accesa pagina  ÅŸi se va alege tipul de joc crossword; se va crea un puzzle folosind min. 20 termeni studiaÅ£i Ã®n cadrul disciplinei VVSS; se va genera puzzle-ul pe fundal alb ÅŸi se va posta pe channel-ul #Games; echipa se va Ã®nscrie Ã®n fiÅŸierul  pentru a putea primi punctajul pentru crearea puzzle-ului; pentru acest task se poate folosi orice alt tool care permite obÅ£inerea puzzle-ului Ã®n forma cerutÄƒ. Create and solve a puzzle Task 02. Solve a Puzzle; o echipÄƒ poate rezolva unul sau mai multe puzzle-uri propuse de alte echipe; task-ul se va puncta o singurÄƒ datÄƒ, adicÄƒ doar una dintre soluÅ£iile propuse (cea cu punctaj maxim) va primi puncte; o echipÄƒ poate rezolva un puzzle chiar dacÄƒ nu a propus anterior un puzzle; dupÄƒ rezolvarea puzzle-ului (prin editarea fiÅŸierului sau listare, apoi rezolvare, apoi pozÄƒ/scan) de cÄƒtre echipa (X, Y, Z), acesta se trimite doar echipei (A, B, C) care a propus puzzle-ul, pentru a fi evaluat; fiecare rÄƒspuns corect primeÅŸte 0.10 puncte (0.10x20 Ã®ntrebÄƒri = 2 puncte); echipa (A, B, C) evalueazÄƒ soluÅ£ia primitÄƒ ÅŸi completeazÄƒ Ã®n fiÅŸierul  componenÅ£a echipei care a oferit soluÅ£ia ÅŸi punctajul corespunzÄƒtor (e.g., 2 puncte, 1.8. puncte); dupÄƒ ce au fost evaluate soluÅ£ii oferite de max. 6 echipe participante, echipa care a propus puzzle-ul va posta soluÅ£ia la puzzle Ã®n thread-ul postÄƒrii iniÅ£iale pe channel-ul #Games, indicÃ¢nd prin aceasta faptul cÄƒ nu mai poate primi spre evaluare alte soluÅ£ii. ReferinÈ›e bibliografice [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [MeszarosFowler2006] Meszaros, G., Fowler, M., Test Doubles, Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Universitatea BabeÂ¸s-Bolyai Cluj-Napoca 15 Aprilie 2025 Evaluarea calitË˜aÂ¸tii softului calitatea softului â€“ conformitatea cu cerinÂ¸tele funcÂ¸tionale Â¸si de performanÂ¸tË˜a precizate, documentate explicit Ë†Ä±n standardele de dezvoltare Â¸si caracteristici implicite ale unui produs soft dezvoltat. [Scott Pressman, 2005] corectitudine â€“ proprietate a unui program de a respecta specificaÂ¸tiile Â¸si a oferi rezultate corecte Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Verificarea programelor metode formale pentru verificarea programelor: bazate pe demonstrarea corectitudinii: asistate de calculator, presupune verificarea corectitudinii codului sursË˜a asociat programului ; aplicate programelor care trebuie sË˜a se termine Â¸si sË˜a obÂ¸tinË˜a un rezultat (curs 08); bazate pe modele: automate, presupune verificarea proprietË˜aÂ¸tilor programului ; aplicate sistemelor concurente; se aplicË˜a Ë†Ä±n etapele post-dezvoltare, e.g., verificarea modelelor. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Metode pentru demonstrarea corectitudinii programelor Robert W Floyd (8 Iunie 1936 â€“ 25 Septembrie 2001) Metoda lui Floyd â€“ metoda aserÂ¸tiunilor inductive; Sir Charles Antony Richard Hoare (11 January 1934) Axiomatizarea lui Hoare â€“ axiome Â¸si reguli deductive; dezvoltarea algoritmilor din specificaÂ¸tii; Limbajul lui Dijkstra â€“ instrucÂ¸tiuni cu santinelË˜a; non-determinism; derivarea formalË˜a a programelor. Edsger Wybe Dijkstra (11 Mai 1930 â€“ 6 August 2002) Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Metoda lui Floyd. Metoda aserÂ¸tiunilor inductive Aplicabilitate: pentru a demonstra: parÂ¸tial corectitudinea programului; terminarea programului; total corectitudinea = parÂ¸tial corectitudinea programului + terminarea programului. FoloseÂ¸ste: precondiÂ¸tie â€“ condiÂ¸tia satisfË˜acutË˜a de datele de intrare ale programului; postcondiÂ¸tie â€“ condiÂ¸tia care trebuie satisfË˜acutË˜a de rezultatele programului; algoritmul â€“ descrierea programului (codul sursË˜a); Etape de aplicare: 1 identificarea unui punct de tË˜aieturË˜a Ë†Ä±n fiecare buclË˜a; 2 identificarea unei mulÂ¸timi de aserÂ¸tiuni inductive; 3 construirea Â¸si demonstrarea condiÂ¸tiilor de verificare/terminare. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ParÂ¸tial corectitudine. Etape de realizare 1 se aleg puncte de tË˜aieturË˜a Ë†Ä±n cadrul algoritmului: douË˜a puncte de tË˜aieturË˜a particulare: un punct de tË˜aieturË˜a la Ë†Ä±nceputul algoritmului, un punct de tË˜aieturË˜a la sfË†arÂ¸situl algoritmului; cel puÂ¸tin un punct de tË˜aieturË˜a Ë†Ä±n fiecare instrucÂ¸tiune repetitivË˜a; 2 pentru fiecare punct de tË˜aieturË˜a se alege cË†ate un predicat invariant (aserÂ¸tiune): punctul de intrare - Ï†(X); punctul de ieÂ¸sire - Ïˆ(X,Z); 3 se construiesc Â¸si se demonstreazË˜a condiÂ¸tiile de verificare: 1 âˆ€X âˆ€Y (Pi (X, Y ) âˆ§ RÎ±i,j (X, Y ) â†’ Pj (X, rÎ±i,j (X, Y ))); 2 Y â€“ vector de variabile cu rezultate intermediare; 3 Î±i,j â€“ drumul de la punctul de tË˜aieturË˜a i la punctul de tË˜aieturË˜a j; 4 Pi Â¸si Pj â€“ predicate invariante Ë†Ä±n punctele de tË˜aieturË˜a i Â¸si j asociate; 5 RÎ±i,j (X, Y ) â€“ predicat care dË˜a condiÂ¸tia de parcurgere a drumului Î±; 6 rÎ±i,j (X, Y ) â€“ funcÂ¸tie care indicË˜a transformË˜arile variabilelor Y de pe drumul Î±; Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ParÂ¸tial corectitudine. Exemplu. algoritmul pentru ridicarea la putere prin Ë†Ä±nmulÂ¸tiri repetate: z = xy ; Algoritmul putere(x, y, z) este: A: Ï†(X ) ::= (x > 0 âˆ§ y â‰¥ 0) z := 1; u := x ; v := y ; cattimp (v > 0) executaË˜ B: Î·(X, Y ) ::= z âˆ— uv = xy dacË˜a (v % 2 == 0) atunci u := u âˆ— u; v := v/2; altfel v := v âˆ’ 1; z := z âˆ— u; sfdacaË˜ sfcattimp C: Ïˆ(X, Z ) ::= z = xy sfAlg; se aleg punctele de tË˜aieturË˜a: A, B Â¸si C; se stabilesc predicatele invariante pentru punctele de tË˜aieturË˜a alese: Ï†(X ), Ïˆ(X, Z ) Â¸si Î·(X, Y ); drumurile Î± Ë†Ä±ntre punctele de tË˜aieturË˜a: {Î±AB , Î±BB , Î±BC , Î±AC } â‡’ {Î±AB , Î±BBatunci , Î±BBaltfel , Î±BC , Î±AC } ; RÎ±i,j (X, Y ) â€“ predicate pentru parcurgerea drumurilor Î±i,j ; rÎ±i,j (X, Y ) â€“ funcÂ¸tii care indicË˜a transformË˜arile variabilelor Y de pe drumurile Î±i,j ; pentru fiecare drum Î± se construieÂ¸ste Â¸si se demonstreazË˜a condiÂ¸tia de verificare de forma âˆ€X âˆ€Y (Pi (X, Y ) âˆ§ RÎ±i,j (X, Y ) â†’ Pj (X, rÎ±i,j (X, Y ))); Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Terminarea algoritmului. Etape de realizare. 1 se aleg punctele de tË˜aieturË˜a Ë†Ä±n cadrul algoritmului; 2 pentru fiecare punct de tË˜aieturË˜a se alege cË†ate un predicat invariant; se alege o mulÂ¸time convenabilË˜a M (i.e., o mulÂ¸time parÂ¸tial ordonatË˜a, care nu conÂ¸tine nici un Â¸sir descrescË˜ator infinit) Â¸si o funcÂ¸tie descrescË˜atoare ui ; Ë†Ä±n punctul de tË˜aieturË˜a i funcÂ¸tia aleasË˜a este ui : DX Ã— DY â†’ M; 4 se scriu condiÂ¸tiile de terminare: condiÂ¸tia de terminare pe drumul Î±i,j este: âˆ€X âˆ€Y (Ï†(X ) âˆ§ RÎ±i,j (X, Y ) â†’ (ui (X, Y ) > uj (X, rÎ±i,j (X, Y )))); dacË˜a s-a demonstrat parÂ¸tial corectitudinea, atunci condiÂ¸tia de terminare poate fi: âˆ€X âˆ€Y (Pi (X, Y ) âˆ§ RÎ±i,j (X, Y ) â†’ (ui (X, Y ) > uj (X, rÎ±i,j (X, Y )))); 5 se demonstreazË˜a condiÂ¸tiile de terminare: la trecerea de la un punctul de tË˜aieturË˜a i la j valorile funcÂ¸tiei u descresc, i.e., ui > uj . Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Sistemul axiomatic al lui Hoare RelaÂ¸tii Â¸si notaÂ¸tii: deductibilitate: |=; g1, g2, ..., gm |= h are semnificaÂ¸tia: â€œformula predicativË˜a h (concluzia) este deductivË˜a din formulele predicative g1, g2, ..., gm (premisele)â€œ ; implicaÂ¸tia: â‡’; â€² P â‡’ P â€² are semnificaÂ¸tia: â€œdacË˜a P este satisfË˜acut atunci are loc Â¸si P â€œ ; negaÂ¸tia: Â¬; Â¬b are semnificaÂ¸tia: â€œnegaÂ¸tia expresiei logice bâ€œ ; contribuÂ¸tiile lui Hoare: triplet â€“ precondiÂ¸tie, bloc de instrucÂ¸tiuni, postcondiÂ¸tie; axioma atribuirii pentru: instrucÂ¸tiunea de atribuire; reguli deductive pentru: structura secvenÂ¸tialË˜a, structura alternativË˜a Â¸si structura repetitivË˜a; demonstrarea parÂ¸tial Â¸si total corectitudinii, dezvoltarea corectË˜a a algoritmilor folosind triplete. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Triplete Hoare {Ï†} P {Ïˆ} â€“ triplet Hoare, unde: Ï† este precondiÂ¸tia; Ïˆ este postcondiÂ¸tia; notaÂ¸tia are semnificaÂ¸tia: â€œdacË˜a execuÂ¸tia programului P Ë†Ä±ncepe dintr-o stare care satisface Ï†, atunci starea Ë†Ä±n care se ajunge dupË˜a execuÂ¸tia lui P va satisface Ïˆâ€œ; Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Triplete Hoare. Exemple (1) Care dintre urmË˜atoarele triplete sunt valide? {x = 5} x := x âˆ— 2 {true}; {x = 5} x := x âˆ— 2 {x > 0}; {x = 5} x := x âˆ— 2 {x = 10 || x = 5}; {x = 5} x := x âˆ— 2 {x = 10}; toate tripletele sunt valide; {x = 5} x := x âˆ— 2 {x = 10} â€“ cel mai util triplet; {x = 10} â€“ cea mai puternicË˜a postcondiÂ¸tie. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Triplete Hoare. Exemple (2) Care dintre urmË˜atoarele triplete sunt valide? {x = 5 && y = 10} z := x/y {z < 1}; {x < y && y > 0} z := x/y {z < 1}; {y Ì¸= 0 && x/y < 1} z := x/y {z < 1}; toate tripletele sunt valide; {y Ì¸= 0 && x/y < 1} z := x/y {z < 1} â€“ cel mai util triplet; {y Ì¸= 0 && x/y < 1} â€“ cea mai slabË˜a precondiÂ¸tie. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Semantica tripletelor Hoare corectitudine parÂ¸tialË˜a notaÂ¸tie: |=par {Ï†}P{Ïˆ} tripletul {Ï†}P{Ïˆ} este satisfË˜acut relativ la corectitudinea parÂ¸tialË˜a, dacË˜a pentru orice stare care satisface Ï†, starea rezultatË˜a dupË˜a execuÂ¸tia programului P satisface postcondiÂ¸tia Ïˆ, avË†and condiÂ¸tia cË˜a programul se terminË˜a; nu garanteazË˜a cË˜a P se terminË˜a; corectitudine totalË˜a notaÂ¸tie: |=tot {Ï†}P{Ïˆ} tripletul {Ï†}P{Ïˆ} este satisfË˜acut relativ la corectitudinea totalË˜a, dacË˜a pentru orice stare care satisface Ï†, programul P se terminË˜a, iar starea rezultatË˜a dupË˜a execuÂ¸tia programului P satisface postcondiÂ¸tia Ïˆ; garanteazË˜a cË˜a P se terminË˜a. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ParÂ¸tial corectitudine. Reguli deductive axioma atribuirii; regula compunerii secvenÂ¸tiale; regula consecinÂ¸tei; regula alternanÂ¸tei; regula iteraÂ¸tiei. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Axioma atribuirii |=par {Ï†(x |e)} x := e {Ïˆ(x )} are semnificaÂ¸tia â€œdacË˜a prin Ë†Ä±nlocuirea lui x Ë†Ä±n Ï†(x ) cu e obÂ¸tinem o afirmaÂ¸tie adevË˜aratË˜a, atunci dupË˜a atribuirea x := e afirmaÂ¸tia Ïˆ(x ) va fi adevË˜aratË˜a.â€œ Fie tripletul {P} X := Y + 2 {Q} fiind dat Q, care este predicatul pentru care P are loc? pentru orice P astfel Ë†Ä±ncË†at [P â‡’ âŸ¨X â† Y + 2âŸ© (Q)] Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula compunerii secvenÂ¸tiale dacË˜a |=par {Ï†}S {Ï‰} Â¸si |=par {Ï‰}T {Ïˆ} atunci |=par {Ï†} S ; T {Ïˆ}; Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula consecinÂ¸tei dacË˜a Ï†1 â‡’ Ï†2, |=par {Ï†2}P{Ïˆ2} Â¸si Ïˆ2 â‡’ Ïˆ1 atunci |=par {Ï†1} P{Ïˆ1} Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula alternanÂ¸tei dacË˜a |=par {Ï† âˆ§ cond } S {Ïˆ} Â¸si |=par {Ï† âˆ§ Â¬cond }T {Ïˆ} atunci propoziÂ¸tia {Ï†} IF (cond ) THEN S ELSE T END{Ïˆ} este parÂ¸tial corectË˜a Ë†Ä±n raport cu specificaÂ¸tia (Ï†, Ïˆ). Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei Care sunt condiÂ¸tiile de realizare ale structurii repetitive while, astfel Ë†Ä±ncË†at: {Ï†} WHILE (cond ) DO S END {Ïˆ} presupunem cË˜a instrucÂ¸tiunea while se terminË˜a , i.e., Â¬cond ; Ë†Ä±n general, nu se cunoaÂ¸ste de cË†ate ori se va executa S; considerË˜am un predicat Î· care rË˜amË†ane satisfË˜acut dupË˜a execuÂ¸tia S: {Î·}S {Î·}	Î· este un predicat invariant; la ieÂ¸sirea din buclË˜a avem Î· âˆ§ Â¬cond ; pentru stabilirea post-condiÂ¸tiei, {Î·} trebuie ales astfel Ë†Ä±ncË†at [Î· âˆ§ Â¬cond â‡’ Ïˆ]. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei (cont.) dacË˜a |=par {Ï† âˆ§ cond }S {Ïˆ} atunci {Ï†} WHILE (cond ) DO S END {Ïˆ}, cu condiÂ¸tia cË˜a existË˜a un predicat invariant Î· asociat buclei, astfel Ë†Ä±ncË†at: [Ï† â‡’ Î·]	Î· este satisfË˜acut la intrare Ë†Ä±n buclË˜a; [Î· âˆ§ Â¬cond â‡’ Ïˆ]	Î· obÂ¸tine pe Ïˆ la ieÂ¸sirea din buclË˜a; {cond âˆ§ Î·}S {Î·}	Î· este satisfË˜acut la fiecare iteraÂ¸tie. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei. Exemple Demonstrarea parÂ¸tial corectitudinii folosind regula iteraÂ¸tiei: Exemplu 1. z = 2N ; Dezvoltarea algoritmilor (parÂ¸tial corecÂ¸ti), folosind regula iteraÂ¸tiei: Exemplu 2. R = A âˆ— B; Exemplu 3. R = AB . Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei. Exemplu 1. efectuarea calculului: z = 2N : Ï† : {N â‰¥ 0} m := 0; y := 1; Î· : {y = 2m} WHILE (m! = N) DO Î· : {y = 2m} y := 2 âˆ— y ; m := m + 1 END Ïˆ : {y = 2N } trebuie demonstrat cË˜a invariantul Î· este satisfË˜acut la intrare Ë†Ä±n buclË˜a; rË˜amË†ane satisfË˜acut Ë†Ä±n buclË˜a {Î·} y := 2 âˆ— y ; m := m + 1; {Î·} obÂ¸tine post-condiÂ¸tia [Î· âˆ§ (m = N) â‡’ (y = 2N )]. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei. Exemplu 2. Ë†Ä±nmulÂ¸tire prin adunË˜ari repetate â€“ â€œR este A adunat de B oriâ€œ: R = A âˆ— B: Ï† : {B â‰¥ 0} Ïˆ : {R = A âˆ— B} â‡’ {B â‰¥ 0}S {R = A âˆ— B} rezolvare (dezvoltarea tripletului): Ï† : {B â‰¥ 0} â€œinit Râ€œ WHILE (cond) DO â€œupdate Râ€œ END Ïˆ : {R = A âˆ— B} regulË˜a: se Ë†Ä±nlocuieÂ¸ste Ë†Ä±n postcondiÂ¸tia Ïˆ unul din termeni cu o variabilË˜a pentru a obÂ¸tine predicatul invariant Î· asociat buclei, astfel Ë†Ä±ncË†at [(Î· âˆ§ Â¬cond ) â‡’ Ïˆ]; se introduce variabila b Ë†Ä±n Ïˆ Â¸si se determinË˜a invariantul Î· asociat buclei, descris prin: R = A âˆ— b; pentru a obÂ¸tine postcondiÂ¸tia, se alege cond sË˜a fie (b Ì¸= B), unde [(R = A âˆ— b) âˆ§ Â¬(b Ì¸= B) â‡’ (R = A âˆ— B)]. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iteraÂ¸tiei. Exemplu 2 (cont.) Ë†Ä±nmulÂ¸tire prin adunË˜ari repetate: invariantul â€“ Î·: (R = A âˆ— b); condiÂ¸tia de execuÂ¸tie a buclei (santinela) â€“ cond: (b Ì¸= B); pentru a asigura cË˜a invariantul este satisfË˜acut iniÂ¸tial, se efectueazË˜a iniÂ¸tializarea: R := 0; b := 0; Ë†Ä±n fiecare iteraÂ¸tie: (1) b este incrementat cu 1; (2) R este actualizat, obÂ¸tinË†and: Ï† : {B â‰¥ 0} R := 0; b := 0; WHILE (b Ì¸= B) DO Î· : {R = A âˆ— b} R :=? â‡’ R := R + A b := b + 1 END Ïˆ : {R = A âˆ— B} Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Regula iterativË˜a. Exemplu 3. ridicare la putere prin Ë†Ä±nmulÂ¸tiri repetate â€“ â€œR este A Ë†Ä±nmulÂ¸tit de B oriâ€œ: R = AB ; {Ï† : (A > 0) âˆ§ (B â‰¥ 0)} S {Ïˆ : R = AB } rezolvare (dezvoltarea tripletului): pentru obÂ¸tinerea invariantului se Ë†Ä±nlocuieÂ¸ste Ë†Ä±n Ïˆ o constantË˜a cu o variabilË˜a, obÂ¸tinË†andu-se: Î· : R = Ab; Ï† : {(A > 0) âˆ§ (B â‰¥ 0)} R :=?; b := 0; â‡’ R:=1; WHILE (b Ì¸= B) DO Î· : {R = Ab} R :=?; â‡’ R := R âˆ— A; b := b + 1 END Ïˆ : {R = AB } Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Total corectitudine. Reguli deductive atribuire {Ï†} X := E {Ïˆ} cu condiÂ¸tia cË˜a [Ï† â‡’âŸ¨X â† E âŸ©(Ïˆ)]; compunere {Ï†} S ; T {Ïˆ} cu condiÂ¸tia cË˜a existË˜a R astfel Ë†Ä±ncË†at {Ï†} S {R} Â¸si {R}T {Ïˆ} ; alternanÂ¸tË˜a {Ï†} IF (cond ) THEN S ELSE T END {Ïˆ} cu condiÂ¸tia cË˜a {Ï† âˆ§ cond } S {Ïˆ} Â¸si {Ï† âˆ§ Â¬cond }T {Ïˆ} ObservaÂ¸tie: similar cu regulile corectitudinii parÂ¸tiale! Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Total corectitudine. IteraÂ¸tia. fie tripletul {Ï†} WHILE (cond ) DO S END {Ïˆ} cum demonstrË˜am cË˜a execuÂ¸tia buclei se terminË˜a? soluÂ¸tie: se identificË˜a o expresie Ë†Ä±ntreagË˜a V astfel Ë†Ä±ncË†at: valoarea V este non-negativË˜a (i.e., V â‰¥ 0 ) Â¸si valoarea V este strict descrescË˜atoare la fiecare iteraÂ¸tie, {V = K } S {V < K } V â€“ â€œinvariant al bucleiâ€œ, expresia Ë†Ä±Â¸si pË˜astreazË˜a caracteristicile de la o iteraÂ¸tie la alta. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Total corectitudine. Exemplu ridicare la putere prin Ë†Ä±nmulÂ¸tiri repetate â€“ â€œR este A Ë†Ä±nmulÂ¸tit de B oriâ€œ: R = AB ; {(A > 0) âˆ§ (B â‰¥ 0)} S {R = AB } invariantul buclei este: Î· : R = Ab âˆ§ (B â‰¥ b); Ï† : {(A > 0) âˆ§ (B â‰¥ 0)} R := 1; b := 0; WHILE (b Ì¸= B) DO	Î· : R = Ab âˆ§ (B â‰¥ b); R := R âˆ— A; b := b + 1 END Ïˆ : {R = AB } se defineÂ¸ste V â€“ o construcÂ¸tie care variazË˜a la nivelul buclei â€“ descris prin expresia (B âˆ’ b); V este strict descrescË˜atoare la fiecare iteraÂ¸tie a buclei, deoarece [(B âˆ’ (b + 1)) < (B âˆ’ b)] Cum demonstrË˜am cË˜a V este o expresie non-negativË˜a? demonstrË†and cË˜a (B â‰¥ b) este un invariant al buclei. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Total corectitudine. Regula iteraÂ¸tiei (rezumat) pentru a demonstra |=tot {Ï†} WHILE (cond ) DO S END {Ïˆ} se identificË˜a un predicat invariant Î· al buclei Â¸si o expresie V, invariantË˜a la nivelul buclei, astfel Ë†Ä±ncË†at: Î· este satisfË˜acut iniÂ¸tial [Ï† â‡’ Î·]; Î· determinË˜a obÂ¸tinerea post-condiÂ¸tiei prin condiÂ¸tia de ieÂ¸sire din buclË˜a [(Î· âˆ§ Â¬cond ) â‡’ Ïˆ]; Î· se menÂ¸tine satisfË˜acut dupË˜a execuÂ¸tia blocului S , i.e., {Î·} S {Î·}; expresia V este strict descrescË˜atoare la fiecare iteraÂ¸tie {V = K } S {V < K }; expresia V este Ë†Ä±ntotdeauna non-negativË˜a; [Î· â‡’ (V â‰¥ 0)]. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Pentru examen... metoda lui Floyd: demonstrarea parÂ¸tial corectitudinii, terminË˜arii Â¸si total corectitudinii ([F0], Cap.1) â€“ probleme: cË˜autarea unei valori Ë†Ä±ntr-un Â¸sir ordonat (Seminar 5); determinarea celui mai mare divizor comun a douË˜a numere naturale (Seminar 5); Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu UrmeazË˜a... Limbajul Dijkstra Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Bibliografie I [Fre10] M. Frentiu. Verificarea Â¸si validarea sistemelor soft. Presa UniversitarË˜a ClujeanË˜a, 2010. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Universitatea BabeÂ¸s-Bolyai Cluj-Napoca 15 Aprilie 2025 Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu InstrucÂ¸tiuni cu santinelË˜a instrucÂ¸tiune cu santinelË˜a (engl. guarded command) o listË˜a de instrucÂ¸tiuni prefixatË˜a de o expresie booleanË˜a; dacË˜a expresia booleanË˜a este iniÂ¸tial evaluatË˜a la true atunci lista instrucÂ¸tiunilor este eligibilË˜a pentru execuÂ¸tie; sintaxË˜a: < guarded command >::=< guard >â†’< guarded list > < guard >::=< boolean expression > < guarded list >::=< statement > {; < statement >} < guarded command set >::= < guarded command > {  < guarded command >} < alternative construct >::= if < guarded command set > fi < repetitive construct >::= do < guarded command set > od < statement >::=< alternative construct > | < repetitive construct > | â€œother statementsâ€²â€² Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Non-determinism. Exemple. Exemplu . Maximul a douË˜a numere: if x â‰¥ y â†’ m := x y â‰¥ x â†’ m := y fi Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Cea mai slabË˜a precondiÂ¸tie Hoare â€“ introduce precondiÂ¸tia suficientË˜a astfel Ë†Ä±ncË†at algoritmul sË˜a obÂ¸tinË˜a rezultate corecte; totuÂ¸si nu existË˜a certitudinea cË˜a algoritmul se va termina; Dijkstra â€“ introduce precondiÂ¸tia necesarË˜a Â¸si suficientË˜a astfel Ë†Ä±ncË†at algoritmul sË˜a permitË˜a obÂ¸tinerea rezultatului corect; cea mai slabË˜a precondiÂ¸tie (engl. weakest precondition, wp) wp(S , R), unde S â€“ mulÂ¸time de instrucÂ¸tiuni; R â€“ predicat (condiÂ¸tie) asupra stË˜arii programului; pornind execuÂ¸tia instrucÂ¸tiunilor S dintr-o stare p, execuÂ¸tia se terminË˜a Â¸si starea Ë†Ä±n care se ajunge satisface pe R; wp - transformË˜a o precondiÂ¸tie Ë†Ä±ntr-o postcondiÂ¸tie R (engl. predicate transformer). Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ProprietË˜aÂ¸tile wp [] 1  legi: Legea miracolului exclus; Legea monotoniei; Legea conjuncÂ¸tiei; Legea disjuncÂ¸tiei. 2  operatori: atribuire (:=); concatenare (;); 3  structuri: secvenÂ¸tialË˜a; alternativË˜a; repetitivË˜a. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ProprietË˜aÂ¸tile wp [] 1  Legea miracolului exclus pentru orice S , pentru toate stË˜arile, unde R = FALSE are loc: wp(S , FALSE ) = FALSE ; 2 Legea monotoniei pentru orice S Â¸si orice douË˜a post-condiÂ¸tii, astfel Ë†Ä±ncË†at pentru toate stË˜arile P â‡’ Q, pentru toate stË˜arile are loc: wp(S , P) â‡’ wp(S , Q); 3 Legea conjuncÂ¸tiei pentru orice S Â¸si orice douË˜a post-condiÂ¸tii P Â¸si Q, pentru toate stË˜arile: wp(S , P) âˆ§ wp(S , Q) = wp(S , P âˆ§ Q); 4 Legea disjuncÂ¸tiei pentru orice S determinist Â¸si orice post-condiÂ¸tii P Â¸si Q, pentru toate stË˜arile: (wp(S , P) âˆ¨ wp(S , Q)) â‡’ wp(S , P âˆ¨ Q). Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Operatorul de atribuire Â¸si concatenare operatorul de atribuire (:=) semantica expresiei x := E se poate descrie prin: wp(â€œx := E â€œ, R) = Rx , unde x	E RE â€“ o copie a predicatului R, pentru care, fiecare apariÂ¸tie a variabilei x este Ë†Ä±nlocuitË˜a de E . operatorul de concatenare (;) semantica expresiei de concatenare ; se poate descrie prin: wp(â€œS 1; S 2â€œ, R) = wp(S 1, wp(S 2, R)); S 1, S 2 â€“ blocuri de instrucÂ¸tiuni; R â€“ postcondiÂ¸tie. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Structura alternativË˜a 1. Fie IF descrisË˜a prin if B1 â†’ SL1 ...  Bn â†’ SLn fi. Fie BB descrisË˜a prin (âˆƒi : 1 â‰¤ i â‰¤ n : Bi ), atunci wp(IF , R) = (BB âˆ§ (âˆ€i : 1 â‰¤ i â‰¤ n : Bi â‡’ wp(SLi , R))). SubstituÂ¸tia simplË˜a 1. Pentru (âˆ€i : 1 â‰¤ i â‰¤ n : (Q âˆ§ Bi ) â‡’ wp(SLi , R)) pentru toate stË˜arile, atunci (Q âˆ§ BB) â‡’ wp(IF , R) are loc Ë†Ä±n toate stË˜arile. t : SSet â†’ Z , SSet â€“ domeniul stË˜arilor; Fie wdec(S , t) â€“ cea mai slabË˜a precondiÂ¸tie definitË˜a pentru S , pentru care funcÂ¸tia t descreÂ¸ste Ë†Ä±n starea finalË˜a, faÂ¸tË˜a de cea iniÂ¸tialË˜a. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu ConstrucÂ¸tia repetitivË˜a Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Rafinare Date de intrare: X;	pre-condiÂ¸tie: Ï•(X ) Date de ieÂ¸sire: Z;	post-condiÂ¸tie: Ïˆ(X , Z ) program abstract Z : [Ï•, Ïˆ] rafinare â‰º â€“ are semnificaÂ¸tia se rescrie prin... Z = P0 â‰º P1 â‰º P2 â‰º ... â‰º Pnâˆ’1 â‰º Pn reguli de rafinare regula atribuirii; regula compunerii secvenÂ¸tiale; regula alternanÂ¸tei; regula iteraÂ¸tiei. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Rafinare [] Regula atribuirii: [Ï•(v /e), Ïˆ] â‰º v := e Regula compunerii secvenÂ¸tiale: [Î·1, Î·2] â‰º [Î·1, Î³] [Î³, Î·2] (Î³ - predicat auxiliar (engl. middle predicate)) Regula alternanÂ¸tei: cond = c1 âˆ¨ c2 âˆ¨ ... âˆ¨ cn; [Î·1, Î·2] â‰º if c1 â†’ [Î·1 âˆ§ c1, Î·2] c2 â†’ [Î·1 âˆ§ c2, Î·2] . . . cn â†’ [Î·1 âˆ§ cn, Î·2] fi Regula iteraÂ¸tiei: cond = c1 âˆ¨ c2 âˆ¨ ... âˆ¨ cn [Î·, Î· âˆ§ Â¬cond ] â‰º do c1 â†’ [Î· âˆ§ c1, Î· âˆ§ TC ] c2  â†’ [Î· âˆ§ c2, Î· âˆ§ TC ] . . . cn  â†’ [Î· âˆ§ cn , Î· âˆ§ TC ] od Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Exemple Rafinare.pdf. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Instrumente software pentru analiza staticË˜a Â¸si analiza dinamicË˜a ESC2Java - Extended Static Checker to Java - Seminar 06; JML- Java Modeling Language - Seminar 06; Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Pentru examen... teoria Dijkstra rafinare: definiÂ¸tii reguli; rafinare algoritmi din specificaÂ¸tii (link: Rafinare.pdf) (2 probleme â€“ Seminar 06): Ë†Ä±mpË˜arÂ¸tire Ë†Ä±ntreagË˜a (cË†at Â¸si rest); rË˜adË˜acinË˜a pË˜atratË˜a; Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Bibliografie I [Dij75] E. Dijkstra. Guarded commands, nondeterminacy and formal derivation of programs. CACM, 8(18):453â€“457, 1975. [Fre10] M. Frentiu. Verificarea Â¸si validarea sistemelor soft. Presa UniversitarË˜a ClujeanË˜a, 2010. Lector dr. Camelia ChisË˜aliÂ¸tË˜a-CreÂ¸tu Sumar Exemplul 1. ÃmpÄƒrÅ£ire Ã®ntreagÄƒ (cÃ¢t ÅŸi rest) Specificare Ï†: (xï‚³0) ïƒ™ (y>0) Ïˆ: (x=q*y+r) ïƒ™ (0ï‚£r<y) Fie ï¨: (x=q*y+r) ïƒ™ (0ï‚£r) un predicat intermediar (middle predicate). Prin aplicarea regulii compunerii secvenÅ£iale: Predicatul ï¨ devine true prin atribuirea (q,r):= (0,x). Predicatul ï¨ este un predicat invariant. Prin aplicarea regulii iteraÅ£iei: 1 Pentru ca DO sÄƒ se termine, r trebuie sÄƒ scadÄƒ (sÄƒ descreascÄƒ); deoarece rï‚³y, putem reduce valoarea lui r cu y, adicÄƒ râ†r-y. ï¨ trebuie sÄƒ rÄƒmÃ¢nÄƒ true ÅŸi Ã®n post-condiÅ£ie, deci este necesar ca: q*y+r = q*y+r-y +y=(q+1)*y + (r-y). Astfel, r ÅŸi q Ã®ÅŸi modificÄƒ valoarea. Exemplul 2. RÄƒdÄƒcinÄƒ pÄƒtratÄƒ r = [sqrt(n)]; se ÅŸtie cÄƒ r â‰¤ sqrt(n) < r+1; post-condiÅ£ia este r2 â‰¤ n < (r+1)2; Specificare: Ï†:	n>1 Ïˆ:	r2 â‰¤ n < (r+1)2 A0 Subalgoritmul RadPatrata(n, r) este: [Ï†, Ïˆ] endRadPatrata Rescriem predicatul de ieÅŸire Ã®n forma:	(r2 <= n < q2 ) ïƒ™ (q=r+1). Folosim predicatul intermediar (middle predicate) ï¨ ::= (r2 â‰¤ n < q2). A1 Subalgoritmul RadPatrata (n, r) este: [Ï†, ï¨] [ï¨,ï¹] sfRadPatrata Predicatul ï¨ devine true Ã®n A1 pentru r=0 ÅŸi q=n+1. A2 Subalgoritmul RadPatrata (n, r) este: (q,r) â† (n+1,0) [ï¨,ï¨ ïƒ™ (q=r+1)] {ï¹} sfRadPatrata Pentru A2 se pote aplica regula iteraÅ£iei. A3 Subalgoritmul RadPatrata (n,r) este: (q,r) â† (n+1,0) DO qâ‰ r+1 -> [ï¨ïƒ™ qâ‰ r+1,ï¨ ïƒ™ TC] OD sfRadPatrata Pentru ca DO sÄƒ se termine, este necesar ca r sau q sÄƒ descreascÄƒ; q-r trebuie sÄƒ devinÄƒ 1 la final. 2 Expresia p=(q+r)/2 satisface condiÅ£ia r<p<q; iar (q-r) se actualizeazÄƒ prin modificarea intervalului [r,q] la [r,p] sau [p,q]. Dar ï¨ trebuie sÄƒ rÄƒmÃ¢nÄƒ true Ã®n post-condiÅ£ie, deci este necesar ca: dacÄƒ (p2â‰¤n) atunci atribuirea r â† p satisface invariantul ï¨; dacÄƒ (p2>n) atunci atribuirea q â† p satisfice invariantul ï¨. A4 Subalgoritmul RadPatrata (n,r) este: (q,r) â† (n+1,0) DO q>r+1 -> pâ† (q+r)/2 IF p2ï‚£n ïƒ  râ†p p2<nïƒ  qâ†p FI OD sfRadPatrata Exemplul 3. ÃnmulÅ£ire prin adunÄƒri repetate Specificare: Ï† : (xï‚³0) ïƒ™ (yï‚³0) Ïˆ : z = x*y A0 Subalgoritmul Produs(x,y,z) este: [Ï†, Ïˆ] sfProdus Post-condiÅ£ia Ïˆ este satisfacutÄƒ dacÄƒ se utilizeazÄƒ un predicat intermediar ï¨: ï¨::= (z+u*v = x*y ) ïƒ™ (vâ‰¥0). De asemenea, se aplicÄƒ regula compunerii secvenÅ£iale: A1 Subalgoritmul Produs (x,y,z) este: [Ï†, ï¨] [ï¨,Ïˆ] sfProdus Programul abstract A1 devine true prin atribuirea	(u,v,z) â† (x,y,0). A2 Subalgoritmul Produs (x,y,z) este: (z,u,v) â† (0,x,y) [ï¨,Ïˆ] sfProdus Programul abstract [ï¨,Ïˆ] se poate rescrie prin [ï¨,ï¨ ïƒ™ (v=0)], ceea ce permite aplicarea regulii iteraÅ£iei: A3 3 Pentru ca DO sÄƒ se termine, este necesar sÄƒ micÅŸorÄƒm pe v: prima posibilitate: vïƒŸv-1; dar ï¨ trebuie satisfÄƒcut ÅŸi Ã®n postcondiÅ£ie, deci este necesar ca: z+u*v = z + u + u*(v-1) ÅŸi atribuirea zïƒŸz+u trebuie sÄƒ aibÄƒ loc; a doua posibilitate: vïƒŸv/2, dacÄƒ v este par; dar ï¨ trebuie satisfÄƒcut ÅŸi Ã®n post-condiÅ£ie, deci este necesar ca: z+u*v = z + (u*2)* v/2 ÅŸi atribuirea (u,v):=(u+u, v/2)trebuie realizatÄƒ. A4 Exemplul 4. Cel mai mare divizor comun al douÄƒ numere naturale Specificare: Ï† : x>0, y > 0 Ïˆ : d=cmmmdc(x,y) A0 Subalgoritmul CMMDC(x,y,d) este: [Ï†, Ïˆ] sfCMMDC Predicatul intermediar ï¨::= cmmdc(d,s)=cmmdc(x,y) este utilizat pentru a aplica regula compunerii secvenÅ£iale. A1 Subalgoritmul CMMDC(x,y,d) este: [Ï†, ï¨] [ï¨,Ïˆ] sfCMMDC Programul abstract A1 devine true prin atribuirea (d,s)=(x,y), folosind regula atribuirii: A2 Subalgoritmul CMMDC(x,y,d) este: (d,s) â† (x,y) [ï¨,Ïˆ] sfCMMDC DacÄƒ d=s atunci ï¨ implicÄƒ pe Ïˆ. Astfel, se poate scrie urmÄƒtorul program abstract: A3 Subalgoritmul CMMDC(x,y,d) este: (d,s) â† (x,y) [ï¨,ï¨ ïƒ™ (d=s)] sfCMMDC Prin aplicarea regulii iteraÅ£iei se obÅ£ine: A2 Subalgoritmul CMMDC(x,y,d) este: 4 (d,s) â† (x,y) DO dâ‰ s ïƒ  [ï¨ïƒ™dâ‰ s,ï¨ ïƒ™ TC] OD sfCMMDC Pentru dâ‰ s avem condiÅ£iile d>s ÅŸi d<s. Se ÅŸtie cÄƒ pentru d>s avem cmmdc(d,s)=cmmdc(d-s,s) ÅŸi atribuirea d â†d-s pÄƒstreazÄƒ predicatul ï¨ invariant. A3 Subalgoritmul CMMDC(x,y,d) este: (d,s) â† (x,y) DO dâ‰ s ïƒ  IF d>s ïƒ  dâ†d-s d<s ïƒ  sâ†s-d FI OD CMMDCïƒŸs sfCMMDC Example 5. Raising a number to a power by multiplications Compute z = xy by multiple multiplications Specification: The predicate ï¨ ::=	(z*uv = xy ) ïƒ™ (vâ‰¥0) implies Ïˆ if v=0. Using it as a middle predicate we can apply the sequential composition rule: The ï¨ becomes true if (z,u,v) = (1,x,y) (in the first abstract program): The predicate ï¨ is invariant, we can apply the iteration rule. For the DO to terminate we must decrease v: First possibility: vïƒŸv-1. But ï¨ should hold also in the post-condition, so we must have:	z*uv =	z * u*uv-1. So also the assignment (z,v)â†(z*u,v-1) is needed. 5 Second possibility: vïƒŸv/2, if v is even. . But ï¨ should hold also in the post-condition, so we must have: z*uv = z* (u*u)v/2 .So also the assignment (u,v) â† (u*u,v/2) is needed. Example 6. Insertion A = (a1, a2,...,an) an array with n components ordered in decrease order and x a value. Insert x in A such that A remains ordered and A containes a new value x. The predicate ORD is define by: ORD(n,A) ::= ( ï€¢i,j: 1ï‚£i,jï‚£n, iï‚£j ïƒ aiï‚£aj) Specification: Ï†::= ORD(n,A) ïƒ™ (n natural) Ïˆ ::=ORD(n+1,A) and (A contains the initial elements and a new element x) There are two possibilities (x<an and nï‚¹0) or ( xï‚³an or (n=0) ): A doua propoziÅ£ie nestandard se rafineazÄƒ printr-o atribuire 6 SÄƒ notÄƒm prin Î· urmÄƒtorul predicat ORD(n,A) ïƒ™ [ (x<a1) ïƒ™ (p=1) ïƒš (ap-1ï‚£x<ap) ïƒ™ (1<pï‚£n)] Care este o postconditie pentru o problemÄƒ de cÄƒutare ÅŸi sÄƒ folosim regula secvenÅ£ei. Ajungem la: Vom satisface postcondiÅ£ia Î· Ã®n urma apelului subalgoritmului de cÄƒutare, astfel cÄƒ ajungem la: After the search we know that x is between ap-1 and ap , so x must be inserted on position p, so we have a'i+1 â† ai, for i=n,n-1,...,p and	a'p â† x. n'â†n+1 We use the assignments: iâ†n; DO iï‚³p ïƒ  ai+1â†ai iâ†i-1 OD 7 Another refinement regardi8nt the nïƒŸn+1 assignment: Example 7. InsertionSort Let A = (a1, a2,...,an) be an array with n integer components. The problem requires to order the components of A. Specification Ï†::= nï‚³2, A has integer components Ïˆ ::= ORD(n,A) and A has the same elements as in the precondition We use the middle predicate ORD(k,A) and apply the sequential composition rule: The first abstract program may be refined to an assignment Wer can rewrite the remained abstract program remarking that ORD(k,A) ïƒ™ (k=n) ïƒ Ïˆ We now can apply the iteration rule 8 For the DO to terminate we must increase k: First possibility: kïƒŸk+1. But ï¨(k)::=ORD(k,A) invariant â€“ by modifying k by k+1 the predicate ï¨(k|k+1) must be true. The abstract program [ (k<n) ïƒ™ ORD(k,A), ORD(k+1,A)] Corresponds to the following subproblem: If ORD(k,A) (the first k elements in A are orderes) then modify the A such that the first k+1 elements to be ordered. This can be achieve by calling a subalgorithn that inserts the ak+1 component such that after insertion the postcondition ORD(k+1,A) is true. 9 CURS 09. RAPORTAREA BUG-URILOR Verificarea È™i validarea sistemelor soft [29 Aprilie 2025] Lector dr. Camelia ChisÄƒliÅ£Äƒ-CreÅ£u Universitatea BabeÅŸ-Bolyai ConÅ£inut Ciclul de viaÅ£Äƒ al unui bug Etape ale ciclului de viaÅ£Äƒ al unui bug AbordÄƒri Principii ÅŸi reguli generale de raportare a bugurilor RIMGEA DefiniÅ£ie. Componente Aplicabilitate. Obiective Reprezentare conceptualÄƒ Replicate Isolate Maximize Generalize Externalize Neutral tone Tipuri de bug-uri Bug de implementare Bug de proiectare Exemple Clasificarea bug-urilor pe baza atributelor de calitate Bibliografie CICLUL DE VIAÅ¢Ä‚ AL UNUI BUG Etape ale ciclului de viaÅ£Äƒ al unui bug. AbordÄƒri Principii ÅŸi reguli generale de raportare a bugurilor stÄƒri ale unui bug stabilite de tester: New, Pending Testing, Retest, Reopened, Verified, Closed; stÄƒri ale unui bug stabilite de programator: Assigned, Open (Duplicate, Rejected, Deffered, Not a Bug), Fixed; sursa: [] Principii generale de raportare a unui bug principii de raportare a unui bug [Patton2005]: se raporteazÄƒ imediat dupÄƒ identificare; se realizeazÄƒ o descriere a bug-ului; nu se fac aprecieri subiective referitoare la bug-ul raportat; se urmÄƒreÈ™te starea bug-urilor (corectat sau nu) raportate anterior, i.e., se foloseÈ™te un sistem de monitorizare a bugurilor (engl. bug tracking system); Principii ÅŸi reguli generale de raportare a unui bug Izolarea È™i reproducerea bug-urilor [Patton2005]: fii suspicios â€“ nu te baza pe ceea ce au fÄƒcut sau spus alÈ›ii, fii consecvent È™i riguros; acordÄƒ atenÈ›ie timpului â€“ nu ignora durata de realizare a unei operaÈ›ii (e.g., momentul zilei, utilizarea unui device care lucreazÄƒ Ã®ncet, viteza de prelucrare a datelor, etc.); acordÄƒ atenÈ›ie domeniilor de valori â€“ valori limitÄƒ, volum de date mare, alocare È™i accesare a memoriei; starea unui bug â€“ poate fi mascatÄƒ de Ã®ncheierea aparent cu succes a unei operaÈ›ii; un bug poate fi evidenÈ›iat de execuÈ›ia Ã®ntr-o anumitÄƒ ordine a paÈ™ilor de execuÈ›ie È™i nu de momentul Ã®n care a apÄƒrut; dependenÈ›ele existente Ã®ntre resurse utilizatele È™i interacÈ›iunea cu memoria, partajarea reÈ›elei È™i a componentelor hard; componentele hard nu trebuie ignorate, acestea se pot degrada È™i reacÈ›ioneazÄƒ imprevizibil. RIMGEA DefiniÅ£ie. Componente Aplicabilitate. Obiective Reprezentare conceptualÄƒ Replicate. Isolate. Maximize. Generalize. Externalize. Clear communication Bug de implementare. Bug de proiectare Exemple RIMGEA. DefiniÅ£ie. Componente RIMGEA [] grup de reguli utilizat pentru investigarea ÅŸi Ã®mbunÄƒtÄƒÅ£irea descrierii unui bug; componente Replicate â€“ reproducerea bug-ului; Isolate â€“ izolarea bug-ului; Maximize â€“ maximizarea bug-ului; Generalize â€“ generalizarea bug-ului; Externalize â€“ externalizarea bug-ului; And say it clear and dispassionately â€“ atitudine neutrÄƒ la raportarea bug-ului. RIMGEA. Aplicabilitate tehnica RIMGEA se aplicÄƒ pentru la raportarea: bug-urilor de implementare programul funcÅ£ioneazÄƒ Ã®ntr-o manierÄƒ pe care proiectantul ÅŸi programatorul o considerÄƒ nepotrivitÄƒ, inadecvatÄƒ; pune Ã®n evidenÅ£Äƒ o deficienÅ£Äƒ, i.e., greÅŸealÄƒ, de scriere sau implementare a soluÅ£iei adoptate; A program with a coding error will behave in a way the designer, programmer or tester will agree is improper. bug-urilor de proiectare programul funcÅ£ioneazÄƒ conform proiectÄƒrii ÅŸi implementÄƒrii; pune Ã®n evidenÅ£Äƒ o deficienÅ£Äƒ, i.e., greÅŸealÄƒ, Ã®n abordarea modului de rezolvare; A program with a design error behaves in a way the designer and programmer intended. RIMGEA. Obiective obiective: la raportarea bug-urilor de implementare elaborarea unui raport care sÄƒ conÅ£inÄƒ o listÄƒ minimalÄƒ de paÅŸi care sÄƒ demonstreze cu certitudine existenÅ£a unui bug Ã®n codul sursÄƒ; la raportarea bug-urilor de proiectare elaborarea unui raport care sÄƒ precizeze clar care este aspectul de proiectare defecturos ÅŸi felul Ã®n care acesta reduce nejustificat calitatea softului. RIMGEA. Reprezentare conceptualÄƒ sursa: [] RIMGEA. Replicate reproducerea (engl. replicate): activitate de testare prin care se identificÄƒ ce este necesar pentru ca bug-ul sÄƒ aparÄƒ de fiecare datÄƒ cÃ¢nd se doreÅŸte manifestarea lui; pune Ã®n evidenÅ£Äƒ ÅŸi cazurile Ã®n care bug-ul nu poate fi reprodus la cerere ÅŸi descrie factorii care ar indicÄƒ posibilitatea apariÅ£iei acestuia. RIMGEA. Isolate izolarea (engl. isolate): activitate de testare prin care se identificÄƒ cea mai scurtÄƒ secvenÅ£Äƒ de paÅŸi necesarÄƒ pentru ca bug-ul sÄƒ fie reprodus ÅŸi raportat Ã®ntr-o formÄƒ clarÄƒ, astfel Ã®ncÃ¢t sÄƒ se punÄƒ Ã®n evidenÅ£Äƒ defecÅ£iunea apÄƒrutÄƒ; un raport al unui bug prezintÄƒ o singurÄƒ defecÅ£iune a produsului soft. RIMGEA. Maximize maximizarea (engl. maximize): activitate de testare prin care se identificÄƒ cele mai importante (grave) consecinÅ£e ale existenÅ£ei bug-ului; se recomandÄƒ prezentarea consecinÅ£elor frecvent Ã®ntÃ¢lnite, determinate de prezenÅ£a bug-ului, Ã®n cel mai des utilizate configuraÅ£ii de rulare, prelucrÃ¢nd date reale. RIMGEA. Generalize generalizarea (engl. generalize): activitate de testare prin care se identificÄƒ ÅŸi se clasificÄƒ situaÅ£iile Ã®n care acest bug va cauza o defecÅ£iune; RIMGEA. Externalize externalizarea (engl. externalize): activitate de testare prin care se identificÄƒ consecinÅ£ele prezenÅ£ei bug-ului din perspective diferite: utilizatorul propriu-zis: Cum este afectat factorul uman? beneficiarul, clientul: Cum este afectatÄƒ reputaÅ£ia companiei clientului sau business-ul acestuia? dezvoltator, furnizor: Cum este afectatÄƒ reputaÅ£ia companiei dezvoltatorului sau business-ul acestuia? terÅ£, competitor: CÃ¢t de important este acest bug? RIMGEA. And use a constructive communication comunicare clarÄƒ ÅŸi constructivÄƒ/neutrÄƒ (engl. and say it clearly and dispassionately, neutral tone): raportul unui bug conÅ£ine date concrete sau speculative Ã®ntr-o manierÄƒ constructivÄƒ, imparÅ£ialÄƒ ÅŸi corectÄƒ; raportul unui bug nu conÅ£ine nu se criticÄƒ, nu se insultÄƒ persoane; nu se includ aspecte irelevante, care pot afecta alte persoane, doar dacÄƒ ele sunt esenÅ£iale pentru descrierea problemei ÅŸi condiÅ£iilor care determinÄƒ defecÅ£iunea. Bug de implementare vs. Bug de proiectare RIMGEA. Exemple produs software testat: Apache Open Office: ; tool pentru managementul bug-urilor Bugzilla: ; configuraÅ£ie de rulare folositÄƒ la testare ÅŸi identificarea bug-urilor: sistem de operare: Windows 10 Home, 64-bit; procesor: Intel Core i5, 1.7GHz; memorie RAM: 4Gb; versiune Open Office Writer: 4.1.3. Open Office Writer. Bug-uri investigate bug-uri de implementare: Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Bug 2. inconsistenÅ£Äƒ de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); bug-uri de proiectare: Bug 3. inconsistenÅ£Äƒ de proiectare: Issue 126371 â€“ Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Open Office Writer. Bug 1 (1) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Replicate â€“ reproducerea bug-ului; Isolate â€“ izolarea bug-ului; Maximize â€“ maximizarea bug-ului; Generalize â€“ generalizarea bug-ului; Externalize â€“ externalizarea bug-ului; And say it clear and dispassionately â€“ atitudine neutrÄƒ la raportarea bug-ului. Open Office Writer. Bug 1 (2) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Replicate â€“ reproducerea bug-ului; Scenariu A: Size curent: 20; fereastra principalÄƒ setare Size: 10.23: fereatra principalÄƒ: Size = 10.1; fereastra Format: Size = 10.2; Scenariu B: Size curent: 20; fereastra Format setare Size: 10.23: fereatra principalÄƒ: Size = 10.1; fereastra Format: Size = 10.2; Open Office Writer. Bug 1 (3) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Isolate â€“ izolarea bug-ului; identificarea celei mai scurte secvenÅ£e de paÅŸi prin care se evidenÅ£iazÄƒ bug-ul; E.g., Scenariu A, Scenariu B; Open Office Writer. Bug 1 (4) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Maximize â€“ maximizarea bug-ului; maximizarea impactului negativ: impact negativ = inconsistenÅ£a dintre cele douÄƒ scenarii; Ã®ntrebÄƒri: unde este aplicat algoritmul de rotunjire? cÃ¢Å£i/care sunt algoritmii de rotunjire folosiÅ£i? eroarea de aproximare este mai puÅ£in importantÄƒ faÅ£Äƒ de inconsistenÅ£a evidenÅ£iatÄƒ de scenariile A ÅŸi B ---> variabila Font Size are douÄƒ valori simultan 10.1 ÅŸi 10.2; Open Office Writer. Bug 1 (5) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Generalize â€“ generalizarea bug-ului; toate platformele au acelaÅŸi bug: eroarea de aproximare raportatÄƒ este micÄƒ; puÅ£ini utilizatori folosesc size cu zecimale. Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Externalize â€“ externalizarea bug-ului; utilizatorul identificÄƒ eroarea de aproximare ---> utilizatorul devine suspicios cu privire corectitudinea aproximÄƒrilor efectuate de OO Writer; dacÄƒ scenariul B oferÄƒ o aproximare corectÄƒ din perspectiva utilizatorului, atunci experienÅ£a ca utilizator Ã®i va fi afectatÄƒ ---> va trebui sÄƒ Ã®ÅŸi aminteascÄƒ de fiecare datÄƒ cÃ¢nd seteazÄƒ Font Size cÄƒ Scenariul A nu este potrivit ÅŸi sÄƒ Ã®l evite; modul de abordare a acestor probleme de aproximare de cÄƒtre produsele concurente, e.g., Microsoft Office Word; Bug 2. inconsistenÅ£Äƒ de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate â€“ reproducerea bug-ului; Isolate â€“ izolarea bug-ului; Maximize â€“ maximizarea bug-ului; Generalize â€“ generalizarea bug-ului; Externalize â€“ externalizarea bug-ului; And say it clear and dispassionately â€“ atitudine neutrÄƒ la raportarea bug-ului; Open Office Writer. Bug 2 (2) Bug 2. inconsistenÅ£Äƒ de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate â€“ reproducerea bug-ului; Open Office Writer. Bug 2 (3) Bug 2. inconsistenÅ£Äƒ de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate â€“ reproducerea bug-ului; Bug 2. inconsistenÅ£Äƒ de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Isolate â€“ izolarea bug-ului; Scenariu A: indicÄƒ cea mai scurtÄƒ secvenÅ£Äƒ de paÅŸi prin care bug-ul este evidenÅ£iat; Scenariu B: indicÄƒ faptul cÄƒ bug-ul apare indiferent de formatul de pagina ales iniÅ£ial, i.e., A4 (scenariu A) sau Letter ÅŸi apoi A4 (scenariu B); indicÄƒ faptul cÄƒ bug-ul apare la prima activare a opÅ£iunii Header Height; Bug 3. inconsistenÅ£Äƒ de proiectare: Issue 126371 â€“ Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Se va investiga dacÄƒ OO Writer ar trebui sÄƒ aibÄƒ un anumit comportament ÅŸi NU dacÄƒ acest comportament este corect sau nu. Replicate â€“ reproducerea bug-ului; Isolate â€“ izolarea bug-ului; Maximize â€“ maximizarea bug-ului; Generalize â€“ generalizarea bug-ului; Externalize â€“ externalizarea bug-ului; And say it clear and dispassionately â€“ atitudine neutrÄƒ la raportarea bug-ului; Open Office Writer. Bug 3 (2) Bug 3. inconsistenÅ£Äƒ de proiectare: Issue 126371 â€“ Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Replicate â€“ reproducerea bug-ului; butonul Vertical Text: disponibil cÃ¢nd Asian Language Support din meniul Tools Options | Language Settings | Languages este activat ---> scrierea de sus Ã®n jos, pe verticalÄƒ este posibilÄƒ; Open Office Writer. Bug 3 (3) Bug 3. inconsistenÅ£Äƒ de proiectare: Issue 126371 â€“ Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Isolate â€“ izolarea bug-ului; Scenariu A Asian Language Support nu este activat; se Ã®ncearcÄƒ adÄƒugarea butonului Vertical Text din Drawing toolbar ---> butonul apare ÅŸi dispare imediat; dacÄƒ butonul este deja selectat, el nu apare Ã®n Drawing toolbar; Scenariu B Asian Language Support este activat; se Ã®ncearcÄƒ eliminarea butonulului Vertical Text din Drawing toolbar ---> butonul dispare ÅŸi apare imediat; dacÄƒ butonul este deja deselectat, el apare totuÅŸi Ã®n Drawing toolbar; Open Office Writer. Bug 3 (4) Bug 3. inconsistenÅ£Äƒ de proiectare: Issue 126371 â€“ Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Externalize â€“ externalizarea bug-ului; impactul asupra utilizatorului: calitatea produsului este afectatÄƒ, utilizatorul devine frustrat pentru eÅŸecul de adÄƒugare sau eliminare a butonului Vertical Text din Drawing toolbar; alte produse similare, e.g., Microsoft Office Word, nu constrÃ¢ng utilizarea butonului Vertical Text doar Ã®n prezenÅ£a unor setÄƒri specifice legate de limbÄƒ; calitatea produsului este afectatÄƒ prin forÅ£area utilizatorului sÄƒ Ã®ÅŸi aducÄƒ aminte sÄƒ modifice setÄƒrile de limbÄƒ pentru a realiza scrierea unui text vertical, dupÄƒ care sÄƒ revinÄƒ la setÄƒrile de limbÄƒ iniÅ£iale; dacÄƒ utilizatorul uitÄƒ sÄƒ revinÄƒ la setÄƒrile iniÅ£iale, acesta poate Ã®ntÃ¢mpina dificultÄƒÅ£i ÅŸi la alte configurÄƒri care sunt afectate de anumite setÄƒri de limbÄƒ ---> utilizatorul nu beneficiazÄƒ de caracteristicile produsului Ã®n maniera doritÄƒ; CLASIFICAREA BUG-URILOR PE BAZA ATRIBUTELOR DE CALITATE by Claudiu Draghia FuncÅ£ionalitate - Functionality bug; LasÄƒ impresia unei funcÅ£ionÄƒri normale: most human like shape; curious with funny eyes; Impact vizual iniÅ£ial pozitiv: Dressed to impress. source [] Testabilitate - CHAOS UI; ImpresioneazÄƒ ÅŸi se deghizeazÄƒ: Confident eyes; Camouflaged; Controllability; Heterogeneity; Automatability; Observability; Separation of concerns; Understandability; Isolateability.	source [] PerformanÅ£Äƒ - HaSo; Bug hibrid: Hardware; Software; source [Draghia2023] Securitate â€“ CIAn; bug dezastruos; Confidentiality; Integrity; Availability; non-repudiation. source [Draghia2023] Investigarea bug-urilor source [Draghia2023] Pentru examen... Ciclul de viaÅ£Äƒ al unui bug: Cele douÄƒ variante discutate la curs (simplu ÅŸi detaliat); RIMGEA descrierea semnificaÅ£iei acronimului: replicate, isolate, maximize, generalize, externalize, communicate it clear; Tipuri de bug-uri: Coding bug; Design bug; Coding bug vs design bug. A bug story Termen: Vineri, 16 Mai 2025, orele 20:00; Echipe: max. 3 studenÅ£i/echipÄƒ, i.e., echipe de forma (A, B, C), (A, B); se acordÄƒ 2 puncte pentru activitatea Bug Story; dacÄƒ bug-ul este se regÄƒseÅŸte printre primele 3 cele mai votate bug-uri, se acordÄƒ suplimentar 1 punct. PaÅŸi de rezolvare: Pas 1: alegerea unui produs soft; alegeÅ£i un produs soft, e.g.: MS Office Word, Google Mail, Google Sheets, OO Writer, proiectul dezvoltat la disciplina Proiect Colectiv, etc; se va realiza o scurtÄƒ descriere a produsului soft (1-2 paragrafe) È™i se va include Ã®n document nou creat. Pas 2: descrierea poveÅŸtii unui bug asociat softului ales; creaÅ£i/imaginaÅ£i/identificaÅ£i un bug ÅŸi realizaÅ£i o descriere a acestuia (text, 1-2 paragrafe), atribuindu-i diferite Ã®nsuÅŸiri/caracteristici de manifestare asupra produsului soft (vezi Ã®nsuÅŸirile bugurilor descrise Ã®n secÅ£iunea Clasificarea bug-urilor Ã®n Curs10. Raportea bug-urilor); furnizaÈ›i È™i o descriere graficÄƒ expresivÄƒ (desen, imagine) a bugului, alegeÈ›i un nume sugestiv; descrierea/povestea bugului va fi inclusÄƒ Ã®n fiÅŸierul creat la Pasul 1; Ã®n descrierea graficÄƒ se pot folosi atÃ¢t insecte, pÄƒsÄƒri sau animale, dar ÅŸi personaje (negative sau nu) din literatura universalÄƒ, filme, desene animate, etc. PaÅŸi de rezolvare: Pas 3: postarea poveÅŸtii bugului; fiÅŸierul finalizat la Pasul 2 se Ã®ncarcÄƒ Ã®n channel-ul #BugStories Ã®n cadrul unei postÄƒri (pentru a putea fi votat ulterior); fiÅŸierul va conÅ£ine ÅŸi detaliile referitoare la componenÅ£a echipei care a dezvoltat bug-ul (nume student, grupÄƒ); Pas 4: votarea celei mai interesante poveÈ™ti/descrieri postate; voturile se acordÄƒ individual, de cÄƒtre fiecare student Ã®nscris la VVSS care a participat sau nu la elaborarea poveÅŸtii unui bug; un student poate vota mai multe poveÈ™ti postate; studenÅ£ii se vor asigura cÄƒ au acordat votul/rile lor pÃ¢nÄƒ Ã®n Vineri, 16 Mai 2025, orele 20:00; pentru acordarea punctului suplimentar se vor lua Ã®n considerare doar voturile exprimate Ã®n channel-ul #BugStories prin react-ul Like (	); ca feedback, se pot adÄƒuga ÅŸi alte reactions la postarea poveÅŸtii unui bug, inclusiv mesaj scris Ã®n postarea asociatÄƒ descrierii bug-ului. ReferinÈ›e bibliografice [ISTQBCertification2025] ISTQB Exam Certification,  . [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [BBST2008] Black-Box Software Testing (BBST), Bug Advocacy, . [Altom2016] Levente Balint, BLOG : RIMGEN, How Well Do you Advocate For Your Bugs?, . [Draghia2023] Claudiu Draghia, .