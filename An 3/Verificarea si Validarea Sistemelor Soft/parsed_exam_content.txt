CURS 01A. VERIFICARE ŞI VALIDARE Verificarea şi validarea sistemlor soft [25 Februarie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Calitatea produselor soft Stakeholders Definiţii ale calităţii produselor soft Activități asociate calității Verificare şi validare Defect software Terminologie Costul unui bug software Bug-uri software celebre Bibliografie CALITATEA PRODUSELOR SOFT Stakeholders Definiții ale calităţii produselor soft Activități asociate controlului calității unui produs soft Stakeholders stakeholder (rom. beneficiar, utilizator) o persoană care manifestă un interes particular pentru succesul sau eşecul unui produs soft . Tipuri de Stakeholders primar/secundar (engl., primary, secondary) : beneficiar primar – direct afectat de succesul sau eşecul produsului; beneficiar secundar – nu este afectat direct de succesul sau eşecul produşului. preferat/nedorit (engl., favored, disfavored) , : beneficiar preferat (avantajat) – produsul este proiectat pentru a fi utilizat de acesta; beneficiar nedorit (dezavantajat) - produsul este proiectat sa creeze dificultăţi în utilizare; beneficiar neutru – produsul nu este proiectat pentru acesta şi nu îl poate influenţa; beneficiar ignorat (neglijat) – produsul nu este proiectat pentru fi utilizat de acest tip de utilizator. “produsul soft este conform cu cerințele documentate” []: conformitatea cu cerințele funcționale și de performanţă precizate şi documentate explicit în standarde de dezvoltare și caracteristicile implicite pe care un produs soft dezvoltat le are; “produsul soft este conform cu cerințele reale ale utilizatorului” []: conformitatea cu cerințele reale ale utilizatorului care pot fi incluse sau nu în specificațiile scrise; conformitate cu cerințele (nevoile) reale, nu doar cu cerinţele documentate; “produsul soft este adecvat pentru a fi utilizat” []: satisfiers – orice aspect care îl mulțumește pe beneficiar; dissatisfiers – orice aspect care îl nemulțumește pe beneficiar; “produsul soft este relevant/important pentru o persoană” []: calitatea este subiectivă; un aspect care are relevanță/importanță însemnată pentru un utilizator poate fi mai puțin important pentru un alt utilizator din aceeaşi categorie de utilizatori. Activităţi asociate calităţii în procesul de dezvoltare, calitatea este abordată din perspectiva: procesului ===> asigurarea calităţii (engl. quality assurance): Obiectiv: asigură respectarea standardelor, planurilor și etapelor proceselor de dezvoltare necesare elaborării adecvate a produsului cerut; Întrebare: Cum se asigură calitatea activităților desfășurate în procesul dezvoltare? produsului ===> controlul calităţii (engl. quality control): Obiectiv: identifică deficienţele în produsul obținut; Întrebare: Cum se controlează calitatea rezultatelor obținute (e.g., work products) în urma activităților desfășurate? Activități asociate controlului calității Analiza statică examinarea unor documente (specificații, modele conceptuale, diagrame de clase, cod sursă, planuri de testare, documentații de utilizare); exemple: activități de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; NU presupune execuția propriu-zisă a programului dezvoltat; Analiza dinamică examinarea comportamentului programului cu scopul de a evidenția defecțiuni posibile; exemple: tipuri de testare (de regresie, funcţională, non-funcţională), niveluri de testare (testare unitară, testare de integrare, testare de sistem, testare funcţională, testare de accpetare); include activitatea de execuție propriu- zisă a programului (testare); VERIFICARE ŞI VALIDARE Verificare Validare Verificare vs. Validare Verificare și Validare. Definiţie SEI SEI (Software Engineering Institute) [] Verificare procesul prin care se asigură că produsul este dezvoltat conform cerinţelor, specificaţiilor şi standardelor; întrebare asociată: Dezvoltăm corect produsul? (Are we building the product right?) Validare procesul prin care se asigură că produsul dezvoltat satisface cerinţele utilizatorului; întrebare asociată: Dezvoltăm produsul corect (de care are nevoie clientul)? (Are we building the right product?) Verificare şi Validare în modelul V sursa: [] Verificare vs. Validare Verificare stabilește dacă rezultatul unei etape de dezvoltare satisface cerințele acelei etape; asigurare a consistenței, completitudinii, corectitudinii; aplică metode de control al calităţii; Validare confirmă că produsul satisface cerințele de utilizare; se desfășoară spre sfârșitul procesului de dezvoltare, cu scopul de a demonstra că întregul sistem satisface nevoile și așteptările; se aplică asupra întregului sistem, în contextul real în care va funcționa, folosind diferite tipuri de testare. Activităţi de Verificare şi Validare sursa: [] DEFECT SOFTWARE Terminologie Când apare un bug într-un produs soft? De ce apare un bug în procesul de dezvoltare software? Costul unui bug software Defecte/Buguri software celebre eroare (engl. error, mistake; greșeală): o acțiune umană care are ca rezultat un defect în produsul software []; defect (engl. fault, i.e., bug): consecință a unei erori []; un defect poate fi latent: nu cauzează probleme până când nu apar anumite condiții (engl. failure triggers) care determină execuția anumitor linii de cod sursă; defecțiune (engl. failure): devierea de la comportamentul obișnuit al unei componente software; apare atunci când comportamentul observabil al programului nu corespunde specificației sale; procesul de manifestare a unui defect: când execuția programului întâlnește un defect, acesta provoacă o defecțiune []; defect (engl. bug, software error) orice aspect al unui produs soft care cauzează reducerea inutilă și inadecvată a calității produsului soft []; constituie o amenințare asupra imaginii produsului []; exemple: deficiențe de proiectare, greșeli în documentații, utilizare cu dificultate a programului; totuși, anumite aspecte ale produsului pot limita calitatea acestuia, dar nu pot fi considerate defecte! exemplu: constrângeri de utilizare precizate sau nu în specificații; În cadrul acestui curs, orice deficiență sau problemă a produsului soft este denumită bug (defect). sinonime pentru bug: engl. variance, problem, inconsistency, error, incident, anomaly [Patton2005]. De ce apare un bug într-un produs soft? Un bug software apare atunci când cel puțin una din următoarele situații are loc []: Produsul soft nu face ce este precizat în specificația lui. Produsul soft face ce nu este precizat în specificație. Produsul soft face ce specificația precizează că nu trebuie făcut. Produsul soft nu face ceea ce specificația ar trebui să precizeze. Produsul soft este dificil de înțeles, greu de utilizat, lent. Testerul pune în evidență perspectiva utilizatorului final asupra podusului soft, adică produsul nu funcționează conform așteptărilor lui. În ce etapă a procesului de dezvoltare software apar bug-urile? specificarea cerințelor: nu se scriu specificațiile, sunt superficiale, se schimbă continuu, nu sunt comunicate corespunzător întregii echipe de dezvoltare; proiectare: sunt superficiale, nu se comunică eficient, se modifică; implementare: complexitatea produsului soft, lipsa documentației (pentru codul sursă îmbunătățit), erori de redactare, presiunea termenului limită. Care este etapa de dezvoltare în care se introduc cele mai multe defecte? Cât costă eliminarea unui bug? Care sunt costurile de eliminare a unui bug software? costul eliminării bug-urilor crește pe măsură ce produsul soft este dezvoltat. BUG-URI SOFTWARE CELEBRE Activitate de seminar 9+ bug-uri software celebre Activitate de seminar. Bug Poster Bug Poster CE? Descrieţi un bug faimos (celebru) într-un poster (1 pagină A4, portret/landscape, Ro/En); CUM? Elementele posterului: denumirea bug-ului, anul apariţiei bug-ului, descrierea contextului (a aplicaţiei) în care a apărut bug-ul, descrierea bug-ului (pe scurt), consecinţele (impactul) apariţiei bug-ului din diferite perspective (costuri de depanare, scăderea credibilității, etc.), o imagine sugestivă a bug-ului; CINE? Perechi de 2 studenţi; înscrierea se face în fişierul de la acest ; la completarea datelor, studenţii sunt rugaţi să se asigure că bug-ul propus nu este ales deja de alţi colegi care apar în listă; CÂND? Posterul va fi prezentat în timpul orelor de seminar la grupa din care fac parte membrii echipei; maxim 2 postere/seminar; CÂT? timp alocat: maxim 5 minute/poster; înainte de prezentare, poster-ul va fi încărcat în MS Teams, în channel-ul BugPosters, secțiunea Files; DE CE? Studenţii primesc maxim 2 puncte de activitate pentru activitatea Bug Poster, inclusă în nota de la seminar. Naveta spațială Mariner 1 – 1962 naveta spațială Mariner 1 a deviat de la traiectoria ei la scurt timp după lansarea spre planeta Venus; a fost distrusă la 293 secunde după lansare; cauza: eroare la scrierea unei instrucțiuni în limbajul FORTRAN, determinând calculul eronat al traiectoriei; cost: 18.5 milioane $ DO 10 I=1.10 ..... compilatorul Fortran ignoră spaţiile, iar instrucţiunea a fost considerată corectă; astfel: DO10I = 1.10 ---> se iniţializează o variabilă nedeclarată intenţia programatorului a fost: DO 10 I = 1, 10 ...... Tratamente împotriva cancerului – 1985 dispozitivul Therac-25 fost folosit în terapia prin radiații; cauza: programul a calculat greșit doza de radiații pe baza datelor de intrare, unii pacienți primind o doză de câteva ori mai mare decât cea normală; cost: 3 pacienți decedați, 3 răniți prin iradiere. Sistemul de apărare american anti-rachetă – 1991 sistemul american de apărare antirachetă MIM-104 Patriot situat în Arabia Saudită nu a reușit să detecteze atacuri cu rachete Scud irakiene; cauza: o eroare de rotunjire la ceasul sistemului (un sfert de secundă) s-a cumulat, astfel încât la 14 ore, sistemul de urmărire își pierdea acuratețea, devenind incapabil să localizeze și să intercepteze rachetele; cost: în atacul asupra unei cazarme din Dhahran au decedat 28 soldați americani; eroarea fusese deja remediată de experții armatei americane, iar noua versiune a softului urma să ajungă cu o zi mai târziu. Jocul asociat desenului animat Disney Lion King – 1995 la prima apariție pe piață a companiei Disney cu un joc pentru copii - The Lion King Animated Storybook - unii utilizatori nu au reușit să folosească produsul soft achiziționat; cauza: compania Disney nu a testat produsul pe diferite modele de calculatoare personale existente pe piață; cost: credibilitatea companiei, schimbarea unităților CD-ROM. Naveta spațială Mars Climate Orbiter – 1998 obiectiv: orbitarea planetei Marte și transmiterea informațiilor despre condițiile meteo; eveniment: după o călătorie de 286 zile de pe Pământ, la intrarea în atmosfera planetei Marte, motoarele au deviat traiectoria navetei; rezultat: dezintegrarea navetei în atmosferă; cauza:	două	dintre	echipele	implicate	în	dezvoltarea	aplicației	foloseau	sisteme	de măsurare a distanței diferite, imperial (inch, feet) și cel metric (m, km). Naveta spațială Mars Polar Lander – 1998 obiectiv: studierea solului și a climei din regiunea Planum Australe de pe Marte; pentru mecanismul de identificare a momentului când mototarele trebuie să fie oprite, NASA nu a folosit radare costisitoare, ci un senzor pe talpa picioarelor navetei, care determina oprirea alimentării cu combustibil; eveniment: la intrarea în atmosfera planetei Marte, programul a interpretat vibrațiile navetei – cauzate de turbulențele din atmosferă – că aceasta ar fi aterizat și a oprit motoarele navetei; rezultat: prăbuşirea navetei de înălţimea de 40m faţă de suprafaţa planetei Marte; cauza: testare incompletă – procedura de aterizare a fost împărțită în două etape, care au fost testate independent; nu s-a realizat testarea de integrare. Knight Capital Group – 2012 casa de brokeraj Knight Capital Group a suferit o pierdere consistentă la bursa din New York; cauza: sistemul a introdus pe bursa de la New York tranzacții care au provocat fluctuații violente ale prețurilor multor acțiuni; cost: pierderi de 440 milioane $ în doar 45 minute. Termostatul Nest – 2016 termostatul Nest Learning Thermostat (achiziţionat de Google în 2014 pentru 3.2 mld $) nu a permis controlul temperaturii în locuinţele în care a fost instalat – imposibilitatea de a-l utiliza pentru încălzire sau prepararea apei calde în timpul unui weekend friguros; cauza: update-ul de firmware pentru device împreună cu existenţa unor filtre necurăţate şi centrale termice incompatibile; aceşti factori au dus la descărcarea bateriei device-ului. Beresheet („In the beginning...”) – 2019 în 11 aprilie 2019 a avut loc tentativa eşuată a Israelului de a trimite pe Lună o naveta spaţială fără oameni a bord; cauza: un bug la sistemul de control al motorului care l-a împiedicat să reducă viteza în timpul aselenizării; inginerii au încercat sa corecteze bug-ul de la distanţă prin restartarea motorului, dar la preluarea controlului asupra motorului era prea târziu pentru ca Beresheet sa poată fi încetinită şi s-a dezintegrat la prăbuşire. Referințe bibliografice [Firesmith2015] Donald Firesmith, Four Types of Shift Left Testing, [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [NASA] NASA, . [Crosby1980] Philip B. Crosby, Quality Is Free, Signet Shakespeare, 1980. [Juran1998] A. Blanton Godfrey, Joseph Juran, JURANS QUALITY HANDBOOK, McGraw-Hill, 1998. [Weinberg1992] Gerald Weinberg, Quality Software Management , Vol. 1: Systems Thinking, Dorset House Publishing, 1992. [Pressman2000] Roger S. Pressman, Software Engineering: A Practitioner’s Approach, McGraw-Hill, Inc., 2000. [BBST] BBST – Bug Advocacy Course, (. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [Easterbrook2010] S. Easterbrook, Software Testing, . [CFI2022] Stakeholders, . [StakeholderMap2019] Stakeholders, . [GauseWeinberg2011] Donald C. Gause, Gerald M. Weinberg, Exploring Requirements: Quality Before Design, Dorset House, 2011. [KanerBach2005] Kaner, C., Bach, J., Requirements Analysis for Test Documentation, . CURS 01B. INSPECTARE Verificarea şi validarea sistemelor soft [25 Februarie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Calitatea produselor soft Activități asociate controlului calității Analiza statică. Clasificare Metode bazate pe factorul uman Definiție. Motivație. Caracteristici Inspectare Fagan Walkthroughs Technical Review Pair-Programming Pentru examen... Bibliografie CALITATEA PRODUSELOR SOFT Activități asociate controlului calității unui produs soft Analiza statică. Clasificare Activităţi asociate calităţii în procesul de dezvoltare, calitatea este abordată din perspectiva: procesului ===> asigurarea calităţii (engl. quality assurance): Obiectiv: asigură respectarea standardelor, planurilor și etapelor proceselor de dezvoltare necesare elaborării adecvate a produsului cerut; Întrebare: Cum se asigură calitatea activităților desfășurate în procesul dezvoltare? produsului ===> controlul calităţii (engl. quality control): Obiectiv: identifică deficienţele în produsul obținut; Întrebare: Cum se controlează calitatea rezultatelor obținute (e.g., work products) în urma activităților desfășurate? Analiză statică (static testing) examinarea unor documente (specificații, modele conceptuale, diagrame de clase, cod sursă, planuri de testare, documentații de utilizare); exemple: activități de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; se pot baza pe factorul uman (reviews) sau utilizarea tool-urilor (analiza statică). Analiză dinamică (dynamic testing) examinarea comportamentului programului cu scopul de a evidenția defecțiuni posibile; exemple: tipuri de testare (de regresie, funcţională, non-funcţională), niveluri de testare (testare unitară, testare de integrare, testare de sistem, testare funcţională, testare de acceptare); se bazează întotdeauna pe execuţia programului. Analiză statică (static testing) permit identificarea mai multor erori (greşeli) care pot fi corectate simultan; NU presupune execuția propriu-zisă a programului dezvoltat; Analiză dinamică (dynamic testing) sugerează doar un simptom, fiecare eroare identificată fiind eliminată individual; include activitatea de execuție propriu-zisă a programului (testare); poate să evidenţieze o defecţiune doar în anumite situaţii. Analiză statică preconcepţie (anii ’60) – „singura modalitate de a verificare a unui program este execuţia pe calculator” [, Cap.3]; se presupunea că un program este scris doar pentru execuția de către calculator și nu este util și necesar să fie citit și înțeles de o persoană, e.g., programator, tester; metode de analiză statică bazate pe: factorul uman (engl. human-based testing, HbT); instrumente specializate (engl. computer-based testing, CbT). Analiză statică. Clasificare metode de analiză statică bazate pe: factorul uman (engl. human-based testing, HbT), i.e., reviews: formale: inspectare Fagan, technical review, walkthroughs; informale: buddy check, pairing, pair review, over-the-shoulder, e-mail pass-around; instrumente specializate (engl. computer-based testing, CbT), i.e., static analysis: tool-assisted: style checker, corecteness checker; metode hibride: pair-programming. METODE BAZATE PE FACTORUL UMAN Definiție. Motivaţie. Obiective Avantaje și dezavantaje. HbT vs CbT Inspectare Walhthroughs Pair-Programming Metode bazate pe factorul uman. Definiţie metodă HbT [, ] verificare efectuată de o persoană sau un grup persoane la sfârșitul unei etape a procesului de dezvoltare și înainte de a demara următoarea fază de dezvoltare; exemplu: activitate: inspectarea codului sursă; se efectuează după etapa de implementare și înainte de începerea testării. Metode HbT. Obiective. Motivație obiective identificarea defectelor; motivaţie utilizarea metodelor HbT contribuie la creșterea productivităţii şi a gradului de încredere că rezultatul obţinut îndeplineşte cerinţele: costul de corectare (eliminare) al defectelor creşte odată cu parcurgerea etapelor de dezvoltare a softului; modificarea comportamentului programatorilor la demararea analizei dinamice, i.e., la depanare se introduc mai multe bug-uri. Metode HbT. Avantaje și dezavataje Avantaje sunt implicate în proces şi alte persoane pe lângă autorul documentului verificat; permite localizarea defectelor; identifică între 30% şi 70% din bug- urile de proiectare şi implementare ale produselor soft. Dezavantaje nu sunt eficiente la identificarea erorilor majore de proiectare; nu pot evidenţia situaţii excepţionale care apar în utilizarea propriu-zisă a softului. INSPECTARE FAGAN Definiție. Caracteristici Echipa de inspectare. Atribuţiile membrilor Activităţi de inspectare Checklists. Definiţie. Motivaţie. Tipuri de checklists Avantaje Inspectare Fagan. Definiție. Caracteristici 1976 – Fagan [] introduce la IBM procesul de inspectare; Inspectare proces structurat prin care se încearcă identificarea defectelor din documentele elaborate pe parcursul etapelor de dezvoltare a softului, pe baza unor criterii prestabilite; Caracteristici echipa de inspectare (4 membri): moderator, autor, secretar, prezentator; activităţi de inspectare (6 etape): planificarea, prezentarea, pregătirea, şedinţa de analiză, corectarea, reinspectarea; tipuri de erori căutate: checklists, adaptate tipului de document inspectat; timp de desfăşurare: 90-120 minute. Echipa de inspectare. Atribuţiile membrilor moderator distribuie materialele şi planifică sesiunile de inspectare; conduce sesiunea de inspectare; urmăreşte modul în care sunt corectate erorile; autorul documentului inspectat (analist, proiectant, programator, tester); răspunde la întrebările adresate de membrii echipei, clarifică nelămuririle semnalate de către aceştia; participă la discuţiile purtate în timpul şedinţei de analiză; remediază defecţiunile constatate; secretar redactează concluziile şedinţei de analiză; înregistrează defectele semnalate şi problemele discutate într-un document (raport de inspectare); prezentator (reader) citeşte în cadrul şedinţei de analiză părţi ale documentului inspectat; inspectori – cu excepţia autorului, toţi ceilalţi sunt consideraţi inspectori; analizează documentul primit cu scopul de a identifica cât mai multe defecte (bug-uri). planificarea (engl. planning) moderatorul alege membrii echipei de inspectare; distribuie materialele tuturor membrilor echipei şi atribuie sarcini de inspectare; verifică dacă documentul care trebuie inspectat este complet şi acceptabil pentru a fi inspectat; prezentarea (engl. overview) – nu este obligatorie se prezentă detaliile materialului inspectat tuturor membrilor echipei de inspectare; moderatorul poate decide dacă este necesară etapa de prezentare sau se trece direct la pregătirea individuală; pregătirea individuală (engl. preparation) citirea atentă şi înţelegerea documentului primit pentru inspectare; inspectorii reţin toate observaţiile critice şi formulează întrebări referioare la aspectele care nu sunt clare. şedinţa de inspectare (engl. inspection meeting) se discută observaţiile critice ale fiecărui inspector; secretarul notează observaţiile considerate prin consens ca fiind defecte şi ulterior redactează concluziile inspectării; concluziile inspectării sunt predate autorului documentului inspectat pentru a corecta greşelile; corectarea (engl. rework) autorul efectuează modificările necesare şi corectează erorile; reinspectarea (engl. follow-up) se verifică dacă modificările efectuate au eliminat erorile; se poate reduce la o întâlnire între autor şi moderator. Checklists. Definiţie. Motivaţie. Tipuri de checklists checklist = listă cu defecte frecvent întâlnite într-un anumit tip de document; motivaţie obiectivul inspectării: identificarea defectelor; în raport cu documentul analizat, se urmăreşte identificarea unor bug-uri specifice; tipuri de checklists pentru inspectarea: documentelor cu cerințele aplicației; documentelor cu arhitectura aplicației; codului sursă; documentelor corespunzătoare testării (proiectarea testelor, date de testare alese). Fiecare checklist conţine aspecte particulare documentelor inspectate şi sunt rezultatul experienţei acumulate în identificarea greşelilor întâlnite frecvent în desfăşurarea unor etape de dezvoltare software. Inspectare Fagan. Avantaje avantaje permite descoperirea defectelor devreme; reducere costul şi timpul de dezvoltare; metodă de grup – membrii echipei conlucrează; modalitate de învăţare la nivelului echipei; stabileşte sursa defecţiunii, nu oferă doar indicii referitoare la existenţa lor, e.g., testarea; elimină stresul depanării într-un timp foarte scurt. Inspectare vs. Testare [] identificarea, localizarea şi eliminarea defectului; abordare aplicată în două etape (individual şi apoi în grup); checklists se focalizează pe anumite părţi ale documentului care sunt predispuse la introducerea de defecte pe parcursul dezvoltării softului. WALKTHROUGHS Definiţie. Caracteristici Walkthroughs vs Inspectare Walkthroughs. Definiție. Caracteristici walkthroughs [] procesul prin care se încearcă identifcarea defectelor din documentele elaborate pe parcursul etapelor de dezvoltare a softului sub îndrumarea autorului documentului; caracteristici [, ] echipa de realizare (3-5 membri) : secretar, inspectori şi moderator (autorul documentului inspectat, i.e., analist, proiectant, programator, tester); activităţile de walkthrough (4 etape): planning, meeting, rework, follow-up; aplică tehnici de identificare a erorilor diferite de inspectarea Fagan, i.e., nu se folosesc checklists; timp de realizare: 90-120 minute. Walkthroughs vs Inspectare Fagan Walkthroughs activitate mai puţin riguroasă; echipa este formată din 3-5 membri; se desfăşoară în 4 etape; nu are pretenţia identificării tuturor defectelor; autorul conduce echipa de walkthrough; se folosesc scenarii prestabilite. Inspectare Fagan activitate riguroasă; echipa este formată din 4 membri; se desfăşoară în 6 etape; identifică defectele des întâlnite; moderatorul conduce echipa de inspectare; foloseşte checklists pentru identificarea defectelor. TECHNICAL REVIEW Definiţie. Caracteristici Technical review vs Inspectare Technical Review. Definiție. Caracteristici technical review [] tip de review formal realizat de o echipă formată din personal calificat tehnic care examinează conformitatea unui document (work product) cu scopul pentru care este utilizat şi identifică diferenţele faţă de specificaţii şi standarde; caracteristici echipa de realizare (3-5 membri) : secretar, inspectori, moderator (conduce echipa) şi autorul documentului inspectat (toţi fiind persoane calificate în acelaşi domeniu şi fiind considerate peer reviewers faţă de autor); autorul nu este şi secretar; activităţile de technical review (3-4 etape): planning, preparation (obligatoriu), meeting (opţional), rework; timp de realizare: 60-90 minute. Technical Review vs Inspectare Fagan Technical Review activitate mai puţin riguroasă; echipa este formată din 3-5 membri; se desfăşoară în 4 etape; obiective: identificarea unui consens, identificarea posibilelor defecte, identificarea de idei noi şi motivarea autorului să îmbunătăţească documentele elaborate folosind implementări alternative; utilizarea checklists este opţională. Inspectare Fagan activitate riguroasă; echipa este formată din 4 membri; se desfăşoară în 6 etape; obiective: evaluarea calităţii, identifică defectele des întalnite; foloseşte checklists pentru identificarea defectelor. INFORMAL REVIEW Definiţie. Caracteristici Informal Review vs Inspectare Informal Review. Definiție. Caracteristici informal review [] se realizează fără o procedură formală sau documentată; exemple: buddy check, pairing, pair review, over-the-shoulder, e-mail pass-around. caracteristici realizare în pereche (2 persoane) sau echipe (>2 persoane): autorul, inspectori (cel puţin unul, toţi sunt peer reviewers faţă de autor); activităţile asociate unui review informal (1-2 etape): meeting (opţională), rework; timp de realizare: 15-60 minute. Informal Review vs Inspectare Fagan Informal Review activitate se scurtă durată, puţin riguroasă; perechi (autor, inspector) sau echipe de membri; se desfăşoară în 1-2 etape; obiective: identificarea posibilelor defecte, identificarea de idei noi, rezolvarea unor probleme minore; inspectorul este un coleg; utilizarea checklists este opţională, rezultatele se pot documenta; gradul de utilitate depinde de inspector; utilizată frecvent metodologiile Agile. Inspectare Fagan activitate riguroasă; echipa este formată din 4 membri; se desfăşoară în 6 etape; obiective: evaluarea calităţii, identifică defectele des întalnite; moderatorul conduce echipa de inspectare; foloseşte checklists pentru identificarea defectelor. PAIR-PROGRAMMING Definiţie. Caracteristici Pair-Programming. Definiție. Caracteristici pair-programming metodă de elaborare a programelor, în care două persoane lucrează împreună; caracteristici combină activităţile: inspectarea codului şi implementarea (codificarea); programatorii alternează rolurile; activităţi de inspectare: nu sunt determinate de checklists; se bazează pe împărtăşirea aceloraşi principii de programare şi a unui stil de programare asemănător; timp de desfăşurare: durata unei zile normale de muncă, fără exces de ore suplimentare sau presiunea unui program de lucru strict; nu există mediatori, iar responsabilitatea pentru atmosfera de lucru deschisă şi non-agresivă depinde de programatori. PENTRU EXAMEN... Pentru examen... concepte, caracteristici, asemănări şi diferenţe: verificare, validare; verificare vs. validare; eroare, defect/bug, defecţiune; eroare vs. defect/bug vs. defecţiune; stakeholders, calitate, QA, QC; analiza statică vs analiza dinamică; HbT, motivaţie; inspectare Fagan, walkthroughs, technical review, informal review: descriere, rolurile membrilor echipei, activităţile asociate şi descrierea lor, avantaje; pair-programming: caracteristici, avantaje. Cursul următor... Testare modele folosite în testare; planuri de testare; cazuri de testare; Technici de testare Black-box împărţirea în clase de echivalenţă; analiza valorilor limită; Testing Management Tool – TestLink prezentare tool. Referințe bibliografice [Crosby1980] Philip B. Crosby, Quality Is Free, Signet Shakespeare, 1980. [Juran1998] A. Blanton Godfrey, Joseph Juran, JURANS QUALITY HANDBOOK, McGraw-Hill, 1998. [Weinberg1992] Gerald Weinberg, Quality Software Management , Vol. 1: Systems Thinking, Dorset House Publishing, 1992. [Pressman2000] Roger S. Pressman, Software Engineering: A Practitioner’s Approach, McGraw-Hill, Inc., 2000. [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Fagan1976] M. E. Fagan, Design and code inspections to reduce errors in program development, IBM Systems Journal, pages 182–211, 1976. [Collard2003] J. F. Collard, I. Burnstein. Practical Software Testing. Springer-Verlag New York, Inc., 2003. [Yourdon1979] E. Yourdon, Structured Walkthroughs, Prentice-Hall,Englewood Cliffs, NJ, 1979. [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Young2008] M. Pezzand, M. Young. Software Testing and Analysis: Process, Principles and Techniques. John Wiley and Sons, 2008. [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [TechReview2019] Cania Consulting, Informal and formal testing reviews, CURS 02A. TESTARE Verificarea şi validarea sistemelor soft [04 Martie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Evaluarea calității unui produs soft Activităţi asociate calităţii Controlul calităţii. Activităţi asociate Metode de verificare și validare Testare Program. Program testat Definiții ale testării Caz de testare. Definiţii. Caracteristici Tipuri de testare Principii de testare. Axiome de testare Procesul de testare Întrebări fundamentale Activități ale procesului de testare Bibliografie EVALUAREA CALITĂȚII UNUI PRODUS SOFT Activităţi asociate calităţii Controlul calităţii. Activităţi asociate Metode de verificare și validare Activităţi asociate calităţii în procesul de dezvoltare, calitatea este abordată din perspectiva: procesului ===> asigurarea calităţii (engl. quality assurance): Obiectiv: asigură respectarea standardelor, planurilor și etapelor proceselor de dezvoltare necesare elaborării adecvate a produsului cerut; Întrebare: Cum se asigură calitatea activităților desfășurate în procesul dezvoltare? produsului ===> controlul calităţii (engl. quality control): Obiectiv: identifică deficienţele în produsul obținut; Întrebare: Cum se controlează calitatea rezultatelor obținute (e.g., work products) în urma activităților desfășurate? Analiză statică (static testing) examinarea unor documente (specificații, modele conceptuale, diagrame de clase, cod sursă, planuri de testare, documentații de utilizare); exemple: activități de inspectare a codului, analiza algoritmului, demonstrarea corectitudinii; se pot baza pe factorul uman (reviews) sau utilizarea tool-urilor (analiza statică). Analiză dinamică (dynamic testing) examinarea comportamentului programului cu scopul de a evidenția defecțiuni posibile; exemple: tipuri de testare (de regresie, funcţională, non-funcţională), niveluri de testare (testare unitară, testare de integrare, testare de sistem, testare funcţională, testare de acceptare); se bazează întotdeauna pe execuţia programului. Analiză statică (static testing) permit identificarea mai multor erori (greşeli) care pot fi corectate simultan; NU presupune execuția propriu-zisă a programului dezvoltat; Analiză dinamică (dynamic testing) sugerează doar un simptom, fiecare eroare identificată fiind eliminată individual; include activitatea de execuție propriu-zisă a programului (testare); poate să evidenţieze o defecţiune doar în anumite situaţii. Metode de Verificare şi Validare sursa: [] TESTARE Program. Program testat Testare. Definiții Caz de testare. Definiţii. Caracteristici Tipuri de testare Principii de testare. Axiome de testare Program. Definiţie program (engl. computer program, software application, software product): listă de instrucţiuni sau o mulţime de metode sau module care permit execuţia de către un calculator; un program este o comunicare între persoane şi calculatoare care sunt separate în timp şi spaţiu şi conţine instrucţiuni care sunt executate de către calculator. [BBST2010] Program testat. Definiţie program testat (engl. software under test, SUT): ≈ funcţie matematică; P : D --> R, unde D – mulţimea datelor de intrare; R – mulţimea datelor de ieşire aşteptate. Testare. Definiții. Caracteristici semnalează prezența defectelor unui program, fără a garanta absența acestora [Dijkstra1969]. procesul de execuție al unui program cu scopul de a identifica erori []. observarea comportării unui program în mai multe execuții []. investigaţie tehnică și empirică realizată cu scopul de a oferi beneficiarilor testării informații referitoare la programul testat []. Testarea este un proces distructiv; se poate finaliza cu succes (passed) sau eşec (failed). Caz de testare. Definiţie caz de testare (engl. test case) – mulțime de date de intrare, condiții de execuție și rezultate așteptate, proiectate cu un anumit scop (e.g., cum ar fi parcurgerea unui drum particular în execuția programului sau pentru a verifica respectarea unei cerințe specifice) []; o interogare adresată de tester programului testat ; este relevant obiectivul informaţional, i.e., informaţia pe care o descoperim prin testare, e.g., testul este passed sau failed, timpul de execuţie asociat testului este foarte mare. notație: (i , r), i ϵ D, r ϵ R; pentru intrarea i se așteaptă să se obțină rezultatul r. Tipuri de testare. Definiţii testare exhaustivă (testare completă, engl. exhaustive testing, complete testing): testare cu toate cazurile de testare posibile, folosind toate datele și scenariile de utilizare posibile; dacă D este finit atunci P se poate executa pentru fiecare i ϵ D; în majoritatea situațiilor D nu este finit, deci testarea exhaustivă nu este posibilă și nici eficace; testare selectivă (engl. selective testing): testare cu o submulțime de cazuri de testare; dacă D nu este finit, atunci se aleg o parte din elementele i , unde i ϵ S, S⊂D . depanare (engl. debugging, bug fixing): proces de localizare și eliminare al unui bug care a fost evidențiat prin testarea programului; se formulează ipoteze asupra comportamentului programului, se corectează defectele și apoi se reia procesul de testare. Principii de testare [] [Cap2. sectiunea Software Testing Principles] Defineşte rezultatele aşteptate în urma testării. Evită să testezi programelor proprii. Analizează riguros rezultatele fiecărui test. Scrie cazuri de testare atât pentru condiţii de intrare valide cât şi pentru cele non- valide. Testează dacă programul nu face ceea ce se precizează în specificaţie, dar şi dacă ceea ce face programul nu este descris în specificaţii. Păstrează întotdeauna cazurile de testare. Organizează şi planifică procesul de testare, considerând că se vor identifica bug-uri. Testarea este o activitate de stimulare a creativităţii. The goal of a software tester is to find bugs, find them as early as possible, and make sure they get fixed. Axiome ale testării [] [Cap.3. sectiunea Testing Axioms] Este imposibil ca un program să fie complet (exhaustiv) testat. Testarea softului presupune asumarea unui risc. Testarea nu poate demonstra ca bug-urile nu există. Numărul mare de bug-uri asociat unei funcţionalităţi este un indicator al prezenţei altor bug-uri – bug-urile pot fi grupate în anumite funcţionalităţi, nu sunt izolate. Paradoxul pesticidului (în testare): cu cât un program este testat mai mult folosind aceleaşi teste (tehnici de testare), imunitatea la testare creşte (nu se descoperă bug-uri noi). Nu orice bug identificat va fi eliminat. Specificaţia produsului soft se schimbă în permanenţă. Testerii nu sunt cei mai apreciaţi membri ai echipei de dezvoltare. PROCESUL DE TESTARE Întrebări fundamentale Activități ale procesului de testare De ce este necesar sa testăm un produs soft ? Care este scopul testării ? evaluarea unor caracteristici sau atribute are calităţii produsului soft; descoperirea unor informaţii referitoare la produsul soft []; obiective ale testării = aspectele de interes care vor fi investigate (evaluate) în procesul de testare; Cum se organizează procesul de testare ? contextul aplicaţiei = particularităţi de realizare a testării, e.g., componenta testată, beneficiarul testării (stakeholder), diverse constrângeri, etc; misiunea testării = acţiunea desfăşurată prin testare pentru a atinge obiectivele testării; strategie de testare = cadru general prin care se determină care sunt cele mai potrivite teste care trebuie proiectate (i.e., ce tehnici de testare se aplică), astfel încât testarea să îşi atingă obiectivele informaţionale, luând în considerare contextul aplicaţiei în care se desfăşoară testarea; tehnică de testare = metodă de proiectare, implementare şi interpretare a rezultatelor unui test; abordare a testării = modalitate de aplicare a unei tehnici de testare, e.g., black-box testing, white-box testing, grey-box testing, exploratory testing, scripted testing. Cum determinăm momentul în care putem realiza testarea? Care sunt condiţiile care trebuie îndeplinite pentru a demara procesul de testare? criterii de începere a testării (engl. entry criteria); Cum determinăm momentul în care testarea efectuată este suficientă? Cât timp testăm, câte teste executăm? criterii de terminare a testării (engl. exit criteria). Întrebări fundamentale. Exemplu Exemplu. Criteriu de terminare a testării într-o strategie bazată pe risc: Se analizează relaţia dintre numărul de teste executate, i.e., amount of testing, şi numărul de bug-uri identificate, i.e., quantity; Over testing: Dacă se testează tot/mult: costurile cresc, numărul de bug-uri scade raportul 𝑏𝑢𝑔𝑠 𝑓𝑜𝑢𝑛𝑑 𝑡𝑒𝑠𝑡𝑖𝑛𝑔 𝑐𝑜𝑠𝑡𝑠 Under testing: devine mic ===> eficienţa testării scade; Dacă se testează puţin sau se iau decizii nepotrivite legate de CE se va testa: costurile sunt mici, numărul de bug-uri rămâne ridicat raportul 𝑏𝑢𝑔𝑠 𝑓𝑜𝑢𝑛𝑑 𝑡𝑒𝑠𝑡𝑖𝑛𝑔 𝑐𝑜𝑠𝑡𝑠 rămâne mare ===> calitate redusă; Fiecare proiect soft are un cost de testare optim. Activități ale procesului de testare planificare (engl. test planning): stabilirea obiectivelor (de ce testăm); stabilirea terminării testării (cât testăm); identificarea unității de program care trebuie testată (ce testăm); elaborarea strategiei de testare (cum testăm, ce tehnici aplicăm, ce abordare folosim); proiectare (engl. test design): stabilirea datelor de intrare; stabilirea rezultatului așteptat; configurarea mediului de execuție pentru program; testare (engl. test execution): execuția programului, i.e, rularea testelor; analiza (engl. test result analysis): analiza rezultatului testului (evaluarea rezultatului); raportarea bug-urilor; monitorizare (engl. test control and monitoring): supravegherea procesului de testare; evaluarea și îmbunătățirea procesului de testare. QA vs QC în procesul de testare: activități QC: 2 .. 4; activități QA: 1, 5; Referințe bibliografice [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Dijkstra1969] E.W. Dijkstra, Software engineering techniques, Report on a conference sponsored by the NATO Science Committee, Rome, Italy, 27-31 October 1969. [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [BBST2010] Black-Box Software Testing (BBST), Foundations, . [IEEE990] IEEE, IEEE STD 610, In IEEE Standard Glossary of Software Engineering Terminology, 1990. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [ISTQBCertification2020] ISTQB Exam Certification, . [BBST2011] BBST – Test Design, Cem Kaner, CURS 02B. TESTARE BLACK-BOX Verificarea şi validarea sistemelor soft [04 Martie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Abordări ale testării Testare Black-Box Definiţie. Caracteristici. Clasificare. Tehnici de testare black-box Partiţionarea în clase de echivalenţă. Exemple Analiza valorilor limită. Exemple Partiţionarea în clase de echivalenţă vs Analiza valorilor limită Avantaje şi dezavantaje Pentru examen... Bibliografie ABORDĂRI ALE TESTĂRII Abordări ale testării. Clasificare Tehnici de testare asociate Abordări ale testării. Clasificare abordare a testării modalitate de realizare a testării în care se aplică una sau mai multe tehnici de testare în cadrul unei straegii de testare stabilită anterior; clasificare testare Black-box (criteriul cutiei negre, engl. Black-box testing); testare White-box (criteriul cutiei transparente, engl. White-box testing); testare Grey-box (criteriul cutiei gri, engl. Grey-box testing); testare exploratorie (engl. Exploratory testing); testare bazată pe scripturi (engl. Scripted testing); Abordări ale testării. Tehnici de testare asociate Testare Black-Box – testare funcţională: Partiţionarea în clase de echivalenţă; Analiza valorilor limită; Tabele de decizie, Cazuri de utilizare, Scenarii de utilizare, etc.; Testare White-box – testare structurală: Acoperirea fluxului de control (e.g., instrucţiuni, ramificaţii, decizii, condiţii, bucle, drumuri); Acoperirea fluxului de date; Testare Grey-box – testare mixtă: folosirea simultană a avantajelor abordărilor black-box şi white-box pentru proiectarea cazurilor de testare. TESTARE BLACK-BOX Definiţie. Caracteristici. Tehnici de testare black-box Partiţionarea în clase de echivalenţă. Exemple Analiza valorilor limită. Exemple Partiţionarea în clase de echivalenţă vs Analiza valorilor limită Avantaje şi dezavantaje Definiţie. Caracteristici testare black-box (engl. black-box testing, data driven testing, input/output driven testing): testare funcţională; datele de intrare se aleg pe baza specificaţiei problemei, programul fiind văzut ca o cutie neagră; nu se utilizează informaţii referitoare la structura internă a programului, i.e., codul sursă; permite identificarea situaţiilor în care programul nu funcţionează conform specificaţiilor. Tehnici de testare black-box tehnici de proiectare a cazurilor de testare bazate pe criteriul black-box: Partiţionarea în clase de echivalenţă; Analiza valorilor limită; Testarea domeniului de valori; Tabele de decizie; Testarea bazată pe cazuri de utilizare; Testarea bazată pe scenarii de utilizare; alte tehnici. Partiţionarea în clase de echivalenţă. Motivaţie în general, testarea exhausivă nu este posibil de realizat, e.g.: există un set consistent de date de intrare sau domeniul de valori testat este infinit; există restricţii, e.g., timp, buget, resursa umană. partiţionarea în clase de echivalenţă (engl. Equivalence Class Partitioning, ECP) este eficientă pentru reducerea numărului de cazuri de testare care trebuie proiectate; Etape: identificarea claselor de echivalenţă disjuncte: se evită redundanţa cazurilor de testare; proiectarea cazurilor de testare: se alege un singur element din fiecare clasă de echivalenţă; Partiţionarea în clase de echivalenţă. Definiţie clasă de echivalenţă (engl. equivalence class, EC): mulţimea datelor de intrare/ieșire pentru care programul are comportament similar []; procesul de partiţionare în clase de echivalenţă (engl. equivalence class partitioning, ECP): împărţirea (divizarea) domeniului datelor de intrare/ieșire în EC, astfel încât, dacă programul va rula corect pentru o valoare dintr-o EC, atunci va rula corect pentru orice valoare din acea EC. ECP. Exemplu 1. Identificarea ECs Se consideră un formular de înscriere la un concurs. Pentru data naşterii se introduce ziua, luna şi anul. Identificaţi clasele de echivalenţă corespunzătoare câmpului lună calendaristică (pentru data naşterii). Domeniul de valori valide este [1, 12]. ECP. Exemplu 1. Proiectarea cazurilor de testare ECs identificate: 1 EC validă, EC1: D1 =[1, 12]; 3 EC non-valide, EC2: D2= {luna| luna<1} = (-∞, 1), EC3: D3= {luna| luna>12} = (12, +∞), EC4: D4 = simboluri alfanumerice; Cazuri de testare proiectate: 1 EC validă ==> 1 caz de testare valid, e.g., TC01: luna = 2; 3 EC non-valide ==> 3 cazuri de testare non-valide, e.g., TC02: luna =-2, TC03: luna = 15, TC04: luna = ”%L10”; Din fiecare EC de intrare identificată se alege o singură valoare. ECP consideră că fiecare EC tratează în manieră similară toate valorile din acea EC. ECP. Exemplu 2. Identificarea ECs Pentru constituirea unui depozit bancar se consideră următoarea ofertă de dobânzi: 0,50% dacă valoarea depozitului este până la 1000,00 Euro; 1,00% dacă valoarea depozitului este până la 2000,00 Euro, dar mai mult de 1000,00 Euro; 1,50% dacă valoarea depozitului este peste 2000,00 Euro; Care sunt clasele de echivalenţă valide şi non-valide pentru valoarea depozitului constituit? Clase de echivalenţă valide: EC1: 0,00 Euro – 1000,00 Euro; EC2: 1000,01 Euro – 2000,00 Euro; EC3: >= 2000,01 Euro. Clase de echivalenţă non-valide: EC4: < 0,00 Euro; EC5: > valoarea maximă admisă pentru un depozit. EC6: caractere din alfabet. ECP. Exemplu 2. Proiectarea cazurilor de testare ECs identificate: 3 ECs valide: EC1: 0,00 Euro – 1000,00 Euro; EC2: 1000,01 Euro – 2000,00 Euro; EC3: >= 2000,01 Euro. 3 ECs non-valide: EC4: < 0,00 Euro; EC5: > valoarea maximă admisă pentru un depozit; EC6: caractere din alfabet. Cazuri de testare proiectate: 3 ECs valide ==> 3 cazuri de testare valide,e.g.: TC01: amount= 678,99; TC02: amount = 1742,81; TC03: amount = 5213,00; 3 ECs non-valide ==> 3 cazuri de testare non- valide, i.e., câte un TC care corespunde fiecărei EC non-valide identificate, e.g.: TC04: amount = -0,79; TC05: amount = 9876543210,123; TC06: amount = #12a. ECP. Algoritm Algoritm de aplicare a ECP (identificarea ECs şi proiectarea TCs): se identifică clasele de echivalenţă pe baza condiţiilor de intrare/ieşire; se clasifică clasele de echivalență în: valide – formate din datele de intrare/ieșire valide pentru program; non-valide – formate din datele de intrare/ieșire eronate, corespunzătoare tuturor celorlalte stări ale condiției de intrare/ieșire. se asociază un identificator unic fiecărei clase de echivalență (e.g., EC1, EC2, etc.); câttimp (nu au fost descrise cazuri de testare pentru toate clasele de echivalență valide/non-valide): scrie (un nou caz de testare care corespunde la cât mai multe clase de echivalență valide încă neacoperite); scrie (un nou caz de testare care corespunde doar uneia dintre clasele de echivalență de non-valide încă neacoperite). dacă o condiție de intrare precizează apartenența la un interval de valori [a,b]: • ==> 1 EC validă, 2 EC non-valide; E.g.: luna, o valoare intervalul [1, 12]; dacă o condiție de intrare precizează o mulțime finită de valori de intrare: • ==> 1 EC validă pentru fiecare valoare, 1 EC non-validă; E.g.: tip curs ϵ CourseType = {opțional, obligatoriu, facultativ}; 1 EC validă pentru fiecare element din CourseType: EC1: {opțional}, EC2: {obligatoriu}, EC3: {facultativ} ===> 3 ECs valide; 1 EC non-validă: EC4: M=  𝑒	𝑒 ∉ CourseType}; dacă o condiție de intrare precizează numărul de valori: • ==> 1 EC validă, 2 EC non-valide; E.g.: “de la 1 până la 5 studenți”; 1 EC validă: EC1: D=[1,5]; 2 EC non-valide: EC2: nici un student; EC3: mai mult de 5 studenți; dacă o condiție de intrare precizează o situație de tipul “must be”: • ==> 1 EC validă, 1 EC non-validă. E.g.,: “primul caracter din parolă trebuie să fie un simbol numeric”; 1 EC validă: EC1: primul caracter este un simbol numeric; 1 EC non-validă: EC2: primul caracter nu este un simbol numeric. Dacă există argumente că programul nu tratează similar toate elementele dintr- o EC, atunci ECs se împart în ECs mai mici. ECP. Acoperirea testării ECs calculul acoperirii (engl. coverage) testării ECs pentru tehnica de testare ECP: Acoperirea ECs = numărul de ECs testate numărul de ECs identificate x 100 E.g.: pe baza specificaţiilor au fost identificate 18 ECs (pentru datele de intrare şi ieşire); pentru 15 ECs s-au proiectat, implementat şi executat teste; Acoperirea ECs= (15/18)*100 = 83,33%. Acoperirea ECs poate fi folosită ca şi criteriu de terminare a testării, i.e., exit criteria. Este ECP eficientă la limita dintre ECs ? ECP presupune că programul are un comportament similar pentru toate valorile dintr-o EC; ECP nu garantează că programul este testat şi la limitele ECs identificate; există greşeli de programare tipice care apar la limita ECs identificate; e.g., pentru x≥3	if (x>3) y++;  //bug if (x>=3) y++; [ECP]: pentru EC1: [3, MaxInt] se alege TC01: x=4, dar TC01 nu surprinde bug-ul de implementare. Analiza valorilor limită. Motivaţie analiza valorilor limită investighează posibilele bug-uri existente la limita dintre ECs identificate; E.g.: pentru x≥3	if (x>3) y++;  //bug if (x>=3) y++; [ECP]: pentru EC1: [3, MaxInt] se alege TC01: x=4, dar TC01 nu surprinde bug-ul de implementare; [BVA]: pentru EC1: [3, MaxInt] se alege TC02: x=3; Etape: identificarea condiţiilor asociate valorilor limită: proiectarea cazurilor de testare: se aleg date test pentru fiecare condiţie limită identificată; Analiza valorilor limită. Definiţie analiza valorilor limită (engl. boundary value analysis, BVA) []: testarea realizată prin alegerea datelor de test pe baza limitelor ECs de intrare/ieşire; valoare limită (engl. boundary value, BV): valoare a domeniului pentru care comportamentul programului se modifică. BVA. Exemplu 1. Condiţii BVA Limitele unei EC valide indică situaţiile în care comportamentul programului se schimbă! ECs identificate: 1 EC validă: EC1: D1 =[1, 12]; 3 EC non-valide: D2= {luna| luna<1} = (-∞, 1), D3= {luna| luna>12} = (12, +∞), D4 = simboluri alfanumerice; Condiţii BVA, construite pentru limitele ECs valide: BVA. Exemplu 1. Proiectarea cazurilor de testare ECs valide identificate: 1 EC validă: EC1: D1 = [1, 12]; Cazuri de testare proiectate pe baza condiţiilor BVA identificate: Limita inferioară a EC1: 1. luna = 0 ==> TC01: luna = 0; (non-valid) 2. luna = 1 ==> TC02: luna = 1; (valid) 3. luna = 2 ==> TC03: luna = 2; (valid) Limita superioară a EC1: 4. luna = 11 ==> TC04: luna = 11; (valid) 5. luna = 12 ==> TC05: luna = 12; (valid) 6. luna = 13 ==> TC06: luna = 13; (non-valid) BVA. Exemplu 2. Condiţii BVA ECs valide identificate: EC1: 0,00 Euro – 1000,00 Euro; EC2: 1000,01 Euro – 2000,00 Euro; EC3: >= 2000,01 Euro. Condiţii BVA identificate: Limita inferioară a EC1: 1. amount = -0,01; (non-validă) 2. amount = 0,00; 3. amount = 0,01; Limita superioară a EC1: 4. amount = 999,99; 5. amount = 1000,00; 6. amount = 1000,01; (non-validă) Limita inferioară a EC2: 1. amount = 1000,00; (non-validă) 2. amount = 1000,01; 3. amount = 1000,02; Limita superioară a EC2: 4. amount = 1999,99; 5. amount = 2000,00; 6. amount = 2000,01; (non-validă) Limita inferioară a EC3: 1. amount = 2000,00; (non-validă) 2. amount = 2000,01; 3. amount = 2000,02; Limita superioară a EC3, MAX_VALUE (float): 4. amount = MAX_VALUE-0,01; 5. amount = MAX_VALUE; 6. amount = MAX_VALUE+0,01; (non-validă) BVA. Exemplu 2. Proiectarea cazurilor de testare ECs valide identificate: EC1: 0,00 Euro – 1000,00 Euro; EC2: 1000,01 Euro – 2000,00 Euro; similar, se proiectează cazuri de testare valide şi non-valide pentru limitele inferioare şi superioare ale EC şi EC ; EC 3: >= 2000,01 Euro. Cazuri de testare proiectate pe baza condiţiilor BVA identificate: Limita inferioară a EC1: 1. amount = -0,01; TC01: amount = -0,01; (non-valid) 2. amount = 0,00; TC02: amount = 0,00 (valid) 3. amount = 0,01; TC03: amount = 0,01; (valid) Limita superioară a EC1: 4. amount = 999,99; TC04: amount = 999,99; (valid) 5. amount = 1000,00; TC05: amount = 1000,00; (valid) 6. amount = 1000,0; TC06: amount = 1000,01; (non valid) Condiţii BVA. Excepţii de identificare a condiţiilor BVA există ECs care nu au limite: E.g.: mulţimea {Dl, Dna, Dra, Dr.} sau CourseType = {opțional, obligatoriu, facultativ}; există ECs (ordonate) care nu au două limite (inferioară şi superioară); E.g.: valoarea unei depuneri într-un cont bancar; variabile multiple dependente: E.g.: variabilele: număr card bancar, data eliberare, data expirare, nume titular; toate variabilele au valori valide şi toate constrângerile existente între acestea sunt satisfăcute <==> card valid; dacă variabilele au valori valide dar constrângerile nu sunt satisfăcute ==> card non-valid; dacă variabilele au valori non-valide ==> card non-valid; ECs dependente – valoarea unei variabile depinde de/ influenţează valoarea alteia: E.g.:, în OpenOffice Writer există mai multe tipuri de pagină: format_pagină = {A2, A3, A4}; formatul A4 constrânge dimensiunea header-ului paginii (header height) maximă 20.56 cm. Condiţii BVA. Sumar BVA. Algoritm Algoritm de aplicare a BVA (identificarea condiţiilor BVA şi proiectarea TCs): se identifică limitele tuturor ECs valide de intrare/ieşire; se scriu condiţii BVA pentru fiecare limită a fiecărei EC identificate, astfel încât: valoarea să fie sub limită (mai mică decât limita), e.g., x < 2; valoarea să fie pe limită (egală cu limita) , e.g., x = 2; valoarea să fie deasupra limitei (mai mare decât limita), e.g., x > 2; se clasifică condiţiile BVA în valide – corespund unor date de intrare/ieşire valide pentru program; non-valide – corespund unor date de intrare/ieşire non-valide pentru program. se asociază un identificator unic fiecărei condiţii BVA (e.g., c1, c2, etc.); câttimp (nu au fost descrise cazuri de testare pentru toate condiţiile BVA valide/non-valide): scrie (un caz de testare nou, care corespunde la cât mai multe condiţii BVA valide încă neacoperite); scrie (un caz de testare nou, care corespunde doar uneia dintre condiţiile BVA non-valide încă neacoperite). BVA. Proiectarea cazurilor de testare. Reguli dacă o condiţie de intrare/ieșire precizează apartenența la un interval de valori [a,b]: •	==> cazuri de testare pentru: (1) condiții BVA valide - limitele intervalului (e.g., a, a+1; b-1, b); (2) condiții BVA non-valide - valori aflate în afara intervalului (e.g., a-1, b+1); dacă o condiție de intrare/ieșire precizează o mulțime de valori ordonată: •	==> cazuri de testare pentru: (1) condiții BVA valide - primul și ultimul element din mulțime; (2) condiții BVA non-valide – valoarea imediat mai mică decât cea mai mică valoare din mulțime și valoarea imediat mai mare decât cea mai mare valoare in mulțime; dacă o condiție de intrare/ieșire precizează numărul de valori (e.g., “de la 1 până la 5 studenți”): •	==> cazuri de testare pentru: (1) condiții BVA valide – numărul minim și maxim de valori, i.e., 1 și 5; (2) condiții BVA non-valide – valoarea imediat mai mică și imediat mai mare, i.e. 0 și 6; BVA. Acoperirea testării condiţiilor BVA calculul acoperirii (engl. coverage) testării condiţiilor BVA: Acoperirea BVAs = numărul de condiţii BVA testate numărul de condiţii BVA identificate x 100 E.g.: pe baza specificaţiilor au fost identificate 64 BVAs (pentru datele de intrare şi ieşire, corespunzător ECs valide); 48 BVAs au fost testate prin cazurile de testare proiectate; Acoperirea BVAs= (48/64)*100 = 75%. Acoperirea BVAs poate fi folosită ca şi criteriu de terminare a testării, i.e., exit criteria. ECP vs BVA ECP presupune că programul tratează similar toate valorile din aceeaşi EC; se poate selecta orice valoare din EC; se alege o singură valoare din EC, considerată reprezentativă pentru a acoperi testarea acelei EC; ECs se construiesc pentru condiţii de intrare/ieșire valide şi non-valide; obiectiv al testării = verificarea respectării specificaţiilor pentru valori uzuale, i.e., building confidence in software; BVA valorile identificate de condiţiile BVA sunt prelucrate individual, nu în grup; valorile se găsesc la limitele dintre ECs, acolo unde programul îşi schimbă comportamentul; se iau în considerare valori egale cu limita, valori imediat inferioare şi valori imediat superioare limitei; sunt luate în considerare atât datele de intrare cât şi cele de ieşire, corespunzătoare fiecărei EC valide; obiectiv al testării = căutarea bug-urilor uzuale, i.e., bug hunting; Testarea Black-box Avantaje nu se există informaţii despre implementare; activitatea testerului este independentă de cea a programatorului; reflecta punctul de vedere al utilizatorului; suprinde ambiguităţile sau inconsistenţele din specificaţii; începe imediat după finalizarea specificaţiilor. Dezavantaje daca specificaţia nu este clară ==> dificultate de construire a cazurilor de testare; la execuţia programului, multe drumurile din graful de execuţie asociat codului rămân netestate ==> secvenţele de cod sursă corespunzătoare pot conţine bug-uri care nu sunt identificate; doar un număr foarte mic de date de intrare va fi efectiv testat. PENTRU EXAMEN… Pentru examen... testare: definiţii ale testării (4); terminologie: program, program testat, caz de testare; tipuri de testare: exhaustivă, selectivă; testare black-box: definiţie, caracteristici; ECP, BVA, ECP vs. BVA; aplicarea ECP şi BVA pentru probleme concrete; avantaje şi dezavanataje BBT. Cursul următor... Testare White-Box Tehnici de testare white-box Testare bazată pe fluxul de control. Componente Graful fluxului de control. Drumuri în CFG. Complexitatea ciclomatică Testare bazată pe acoperirea drumurilor Testare bazată pe acoperirea codului sursă Acoperirea instrucţiunilor, deciziilor, condiţiilor, deciziilor şi condiţiilor, condiţiilor multiple, drumurilor, buclelor Testare White-box vs Testare Black-box Referințe bibliografice [Pal2013] Kaushik Pal, Software Testing: Verification and Validation, [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004 [Frentiu2010] M. Frentiu, Verificarea si validarea sistemelor soft, Presa Universitara Clujeana, 2010. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [BBST2010] Black-Box Software Testing (BBST), Foundations, . CURS 03. TESTARE WHITE-BOX Verificarea şi validarea sistemelor soft [11 Martie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Abordări ale testării Testare White-Box Definiţie. Caracteristici Tehnici de testare white-box Testare bazată pe fluxul de control. Componente Definiţie. Caracteristici. Avantaje şi dezavantaje Graful fluxului de control. Exemple Drumuri în CFG. Exemple Complexitatea ciclomatică. Exemple Testare bazată pe acoperirea drumurilor Definiţie. Algoritm. Exemplu Testare bazată pe acoperirea codului sursă Definiţie. Criterii de acoperire Acoperirea instrucţiunilor, deciziilor, condițiilor, deciziilor şi condiţiilor, condiţiilor multiple, buclelor Testare White-box vs Testare Black-box Avantaje şi dezavantaje ale Testării White-Box Testare Black-box vs. Testare White-box Bibliografie ABORDĂRI ALE TESTĂRII Abordări ale testării. Clasificare Tehnici de testare asociate Abordări ale testării. Clasificare abordare a testării modalitate de realizare a testării în care se aplică una sau mai multe tehnici de testare în cadrul unei straegii de testare stabilită anterior; clasificare testare Black-box (criteriul cutiei negre, engl. Black-box testing); testare White-box (criteriul cutiei transparente, engl. White-box testing); testare Grey-box (criteriul cutiei gri, engl. Grey-box testing); testare bazată pe experienţă (engl. Experienced-based testing); testare bazată pe scripturi (engl. Scripted-based testing); Abordări ale testării. Tehnici de testare asociate Testare Black-Box – testare funcţională: Partiţionarea în clase de echivalenţă; Analiza valorilor limită; Tabele de decizie, Cazuri de utilizare, Scenarii de utilizare, etc.; Testare White-box – testare structurală: Acoperirea fluxului de control (e.g., drumuri, instrucţiuni, ramificaţii, decizii, condiţii, bucle); Acoperirea fluxului de date; Testare Grey-box – testare mixtă: folosirea simultană a avantajelor abordărilor black-box şi white-box pentru proiectarea cazurilor de testare. TESTARE WHITE-BOX Definiţie. Caracteristici Tehnici de testare white-box Quiz WBT Quiz WBT CE? Completați quiz-ul WBT cu întrebări referitoare la testarea white-box, disponibil la acest . CUM? Activitatea este facultativă. Fiecare întrebare din quiz are o singură variantă de răspuns corectă. CINE? Activitatea se adresează tuturor studenților înscriși la disciplina VVSS (IR, MIR). CÂND? Quiz-ul trebuie completat până cel târziu Vineri, 04 Aprilie 2025, orele 20:00. CÂT? Sunt necesare max. 15 minute pentru completarea quiz-ului. DE CE? Studenţii primesc 2 puncte pentru activitatea Quiz WBT, inclusă în nota de la seminar. Punctele pentru această activitate se acordă indiferent de numărul de răspunsuri corecte indicate. Testare White-Box. Definiţie. Caracteristici criteriul cutiei transparente (engl. white-box testing, logic driven testing): testare structurală; datele de intrare se aleg pe baza instrucţiunilor care trebuie executate, programul este văzut ca o cutie transparentă; avem acces la structura internă a programului (codul sursă); permite identificarea situaţiilor în care execuţia programului nu acoperă diferite structuri ale acestuia. Tehnici de testare white-box tehnici de proiectare a cazurilor de testare white-box bazate pe: fluxul de control: acoperirea drumurilor []; acoperirea codului sursă: instrucţiunilor, ramificaţiilor, deciziilor, condiţiilor, deciziilor şi condiţiilor, condiţiilor multiple [], condiţiilor/deciziilor modificate; buclelor []; acoperirea predicatelor (engl. predicate complete coverage); acoperirea prin mutaţii; fluxul de date []. TESTARE BAZATĂ PE FLUXUL DE CONTROL. COMPONENTE Definiţie. Caracteristici Graful fluxului de control. Exemple Drumuri în CFG. Exemple Complexitatea ciclomatică. Exemple Testare bazată pe fluxul de control – Avantaje şi dezavantaje Testarea bazată pe fluxul de control testarea bazată pe fluxul de control utilizează structurile de control pentru proiectarea cazurilor de testare; scop: acoperirea prin cazuri de testare la un nivel statisfăcator a structurilor de control din programul testat; componente: graful fluxului de control; complexitatea ciclomatică. Graful fluxului de control. Definiţie graful fluxului de control (engl. Control Flow Graph, CFG): reprezentare grafică detaliată a unei unităţi de program; permite vizualizarea tuturor drumurilor din unitatea de program; graf orientat: vârf (engl. node): indică structuri secvenţiale şi condiţiile din structurile alternative sau repetitive; arc (engl. edge): indică sensul transmiterii controlului logic în cadrul programului. CFG. Caracteristici permite reprezentarea grafică a structurilor de programare; tipuri de vârfuri: decizie: are o condiţie prin care se permite ramificarea execuţiei prin cel puţin două căi; e.g., instrucţiunile if, while, repeat/until, case; instrucţiune/calcul: conţine o secvenţă de instrucţiuni; conector: nu conţine o instrucţiune şi reprezintă un punct al programului care uneşte mai multe ramificaţii; intrare, ieşire: există un singur vârf intrare şi un singur vârf ieşire; în vârful de intrare nu întră nici un arc; din vârful de ieşire nu iese nici un arc. CFG. Construire paşi de elaborare a unui CFG: se numerotează unic fiecare element de structură secvenţială (calcul) şi condiţională (decizie); se începe pornind de la vârful de intrare, care are (de obicei) numărul 1; se adaugă celelalte vărfuri corespunzătoare structurilor numerotate şi se unesc prin arce, evidenţiind transmiterea controlului în cadrul programului; la final, toate ieşirile posibile din program se unesc în vârful de ieşire; condiţii complexe care conţin atribuiri ==> CFG are o descriere complexă []; e.g., if (((fptr1 = fopen(’’file1’’, ’’r’’ )) != NULL) && (i++) && (0)){...}. CFG. Complexitatea construirii pentru metoda openfiles(), avem CFG alăturat; CFG. Exemple de notaţii CFG. Exemple (1) CFG. Exemple (2) CFG. Drumuri în CFG drum: execuţia unei secvenţe de instrucţiuni de la punctul de intrare până la punctul de ieşire al CFG asociat unei unităţi de program; drum independent (engl. independent path): orice drum în CFG care introduce cel puţin o instrucţiune nouă sau o condiţie nouă, care este executată cel puţin o dată; mulţimea drumurilor independente formează mulţimea drumurilor de bază (engl. basis path set) a unui CFG; indică numărul minim de cazuri de testare care trebuie executate pentru ca fiecare instrucţiune să fie executată cel puţin o dată. drumuri independente: drum 1: 1(F)-11. drum 2: 1(T)-2-3(T)-4-5-10-1(F)-11. drum 3: 1(T)-2-3(F)-6(T)-8-9-10-1(F)-11. drum 4: 1(T)-2-3(F)-6(F)-7-9-10-1(F)-11. drumuri independente: drum 1: A-B-D-E-G-K-M; drum 2: A-C-D-E-G-K-M; drum 3: A-B-D-F-I-L-M;. drum 4: A-B-D-E-H-K-M; drum 5: A-C-D-F-J-L-M. CFG. Algoritm de construire a drumurilor independente Algoritmul lui McCabe [McCabe1984, McCabe Baseline Method] se alege un drum normal (numit drum iniţial, D1); se recomandă ca acesta să aibă cât mai multe decizii este posibil; pentru generarea următorului drum (D2), se modifică rezultatul evaluării primei decizii de pe D1 și păstrând numărul de decizii ale drumului D1; pentru generarea următorului drum (D3), se modifică rezultatul evaluării celei de a doua decizii de pe D1; se repetă pasul 3 până când toate deciziile de pe D1 au fost modificate/inversate; se reiau paşii de la 1..4 considerând ca drum iniţial pe D2, modificând/inversând deciziile, până când toate se obţin toate drumurile independente din mulţimea de bază a CFG. Complexitatea ciclomatică. Definiţie complexitatea ciclomatică (engl. McCabe’s cyclomatic complexity, CC): metrică software aplicată pentru măsurarea cantitativă a complexităţii logice a unui program; permite determinarea numărului de drumuri independente din mulţimea de bază a unui CFG; modalităţi de calcul a CC la nivelul CFG: CC = numărul de regiuni din CFG; CC = E − N + 2, unde E - #arce, N - #vârfuri ; CC = P + 1, unde P - #vârfuri condiţie. regiune: zonă a CFG marginită parţial sau în totalitate de arce şi vârfuri; CC. Exemple (1) CC pentru CFG: CC = numărul de regiuni = 4 regiuni = 4. CC = E − N + 2 = 14 arce - 12 vârfuri + 2 = 4. CC = P + 1 = 3 vârfuri condiţie + 1 = 4. drumuri independente: drum 1: 1(F)-11. drum 2: 1(T)-2-3(T)-4-5-10-1(F)-11. drum 3: 1(T)-2-3(F)-6(T)-8-9-10-1(F)-11. drum 4: 1(T)-2-3(F)-6(F)-7-9-10-1(F)-11. CC. Exemple (2) drumuri independente: drum 1: A-B-D-E-G-K-M; drum 2: A-C-D-E-G-K-M; drum 3: A-B-D-F-I-L-M;. drum 4: A-B-D-E-H-K-M; drum 5: A-C-D-F-J-L-M. CC pentru CFG: CC = numărul de regiuni = 5 regiuni = 5; CC = E − N + 2 = 16 arce - 13 vârfuri + 2 = 5; CC = P + 1 = 4 vârfuri condiţie + 1 = 5. Utilizarea CFG în testare. Avantaje şi dezavantaje Avantaje Testarea de bază aplicată în testarea unitară, care sunt dezvoltate la momentul curent; Se aplică pentru modulele pentru care prin inspectare nu pot fi suficient verificate; Limbajele orientate-obiect reduc numărul de bug-uri la nivelul fluxului de control. Dezavantaje Dacă este aplicată de tester şi nu de programator, este necesar ca testerul să aibă abilităţi de programare pentru a înţelege codul sursă şi modul de execuţie al acestuia; Tehnică de testare consumatoare de timp, deoarece mai întâi se elaborează CFG, CC, drumuri independente şi ulterior se proiectează cazurile de testare; Consideră că: Specificaţiile sunt corecte; Datele sunt definite şi accesate corespunzător; Nu există alte bug-uri pe lângă cele determinate de fluxul de control. TESTARE BAZATĂ PE ACOPERIREA DRUMURILOR Definiţie Algoritm Exemplu Testare bazată pe acoperirea drumurilor. Definiţie acoperirea tuturor drumurilor (engl. all path coverage, apc): testarea tuturor drumurilor programului; avantaje şi dezavantaje: permite identificarea tuturor defectelor, dar nu şi de pe drumurile care lipsesc; dificil de realizat în practică pentru programe cu structuri repetitive ===> se alege un număr redus de drumuri; Testare bazată pe acoperirea drumurilor. Algoritm Algoritmul de proiectare a cazurilor de testare bazat pe drumuri este: Se elaborează CFG; Se calculează CC pe baza CFG; Se determină mulţimea de bază a CFG (cu drumuri independente, liniare); Se proiectează câte un caz de testare pentru fiecare drum independent identificat. ordinea de selectare a drumurilor: drumuri scurte; drumuri de lungime crescândă; drumuri lungi, complexe, alese arbitrar. Testare bazată pe acoperirea drumurilor. Exemplu Câte cazuri de testare sunt necesare pentru acoperira drumurilor? Testare bazată pe acoperirea drumurilor. Exemplu (cont) CC pentru CFG: CC = numărul de regiuni = 3 regiuni = 3; CC = E − N + 2 = 7 arce - 6 vârfuri + 2 = 3; CC = P + 1 = 2 vârfuri condiţie + 1 = 3. drumuri independente: drum 1: 1-2(F)-6. drum 2: 1-2(T)-3(F)-5-2(F)-6. drum 3: 1-2(T)-3(T)-4-5-2(F)-6. TESTARE BAZATĂ PE ACOPERIREA CODULUI SURSĂ Definiţie. Criterii de acoperire Acoperirea instrucţiunilor. Definiţie. Exemplu Acoperirea deciziilor. Definiţie. Exemplu Acoperirea condiţiilor. Definiţie. Exemplu Acoperirea deciziilor şi condiţiilor. Definiţie. Exemplu Acoperirea condiţiilor multiple. Definiţie. Exemplu Acoperirea buclelor. Definiţie. Exemplu Testare bazată pe acoperirea codului sursă. Definiţie acoperirea codului sursă: testarea tuturor structurilor de control folosind un număr minim de teste, astfel încât să fie satisfăcute criteriile: acoperirea instrucţiunilor (engl. statement/line/node coverage); acoperirea ramificaţiilor: acoperirea deciziilor (arcelor) (engl. decision/branch/edge coverage); acoperirea condiţiilor (engl. condition coverage); acoperirea deciziilor şi condiţiilor (engl. decision-condition coverage); acoperirea condiţiilor multiple (engl. multiple condition coverage); acoperirea structurilor repetitive: acoperirea buclelor (engl. loop coverage). Acoperirea instrucţiunilor. Definiţie acoperirea instrucţiunilor (engl. statement/line/node coverage, sc): proiectarea cazurilor de testare astfel încât toate instrucţiunile sunt executate cel puţin o dată, adică fiecare vârf al CFG este vizitat; cel mai slab criteriu de acoperire în testare; o mulţime de teste care nu realizează acoperire 100% a vârfurilor nu este considerată acceptabilă. SC. Exemplu Fiecare intrucţiune trebuie să fie executată cel puţin o dată. // returnează valoarea absolută a lui y int abs (int y) { if (y<0) y = -y; return y; } Care este numărul minim de cazuri de testare necesar? Criteriul de acoperire a instrucţiunilor este îndeplinit 100%. SC. Observaţii cel mai slab criteriu de acoperire deoarece: nu acoperă ramificaţia else pentru instrucţiunile if care nu descriu explicit această ramificaţie; nu evdenţiază implicit prezenţa posibilelor bug-uri de pe aceste ramificaţii; SC se recomandă doar atunci când nu există alte criterii de acoperire care se pot aplica. // returnează valoarea absolută a lui y int abs (int y) { if (y<0) y = -y; return y; } Este necesară acoperirea deciziilor. Acoperirea deciziilor. Definiţie ramificaţie (engl. branch/edge): arc care porneşte dintr-un vârf; din fiecare vârf porneşte cel mult un arc, mai puţin din vârful de ieşire al CFG; din vârfurile de decizie pornesc două arce, etichetate cu true şi false; acoperirea deciziilor (engl. branch/edge/decision coverage, dc): acoperirea unui arc a = drum care parcurge arcul a; proiectarea cazurilor de testare se face astfel încât fiecare arc de decizie să fie parcurs cel puţin o dată; regulă de selectare: fiecare decizie selectată, evaluată la true sau false, trebuie să se găsească pe cel puţin un drum. DC. Exemplu Pentru fiecare decizie, fiecare ramificaţie (true, false) trebuie să fie executată cel puţin o dată. // returnează valoarea absolută a lui y int abs (int y) { if (y<0) y = -y; return y; } Care este numărul minim de cazuri de testare necesar ? Criteriul de acoperire a deciziilor este îndeplinit 100%. Ambele ramificaţii ale deciziei au fost explorate. DC vs. SC dc ===> sc; instrucţiunile se află pe arce; dacă se parcurge fiecare arc atunci se execută şi instrucţiunile asociate; DC. Observaţii e.g.,	y = fou(x); if (x<10 || y>20) {z=fie(x, y);} else {z=foo(x,y);} pentru x=1 şi y=2 nu mai este relevantă evaluarea condiţiei y>20; în deciziile formate din mai multe condiţii, unele condiţii pot să rămână neacoperite fiind irelevante pentru rezultatul final al deciziei; dacă condiţia este scrisă greşit, e.g., y<20 în loc de y>20, cazuri de testare ca x=1, y=2 nu evidenţiază defectul. Este necesară acoperirea condiţiilor. Acoperirea condiţiilor. Definiţie condiţie: expresie logică dintr-un vârf de decizie; o decizie este formată din una mai mai multe condiţii; acoperirea condiţiilor (engl. condition coverage, cc): proiectarea cazurilor de testare se realizează astfel încât fiecare condiţie din fiecare decizie ia fiecare dintre valorile posibile, cel puţin o dată; regulă de selectare: pentru fiecare decizie care conţine mai multe condiţii, fiecare condiţie selectată va fi evaluată la true sau false şi se va găsi pe cel puţin un drum. CC. Exemplu Fiecare condiţie din fiecare decizie trebuie să fie executată cel puţin o dată cu fiecare din valorile posibile (e.g., true, false) // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? CC. Exemplu (cont.) // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? Criteriul de acoperire a condiţiilor este îndeplinit 100%. Toate rezultatele posibile ale evaluării condiţiilor din decizie au fost explorate. CC. Observaţii e.g., if (x<10 && y>20) {z=fie(x, y);} else {z=foo(x,y);} pentru x=11 şi y=21, avem false && true = false; pentru x=1	şi y=1,	avem true && false = false; fiecare condiţie selectată este acoperită prin evaluarea la true şi false, dar decizia nu este acoperită, doar ramificaţia false este explorată; Este necesară acoperirea deciziilor şi condiţiilor. CC vs. DC în general, cc ===> dc; prin acoperirea condiţiilor se poate acoperi şi decizia; caz particular: cc = dc atunci când decizia conţine doar o condiţie; e.g., decizia	y<0 este evaluată la true sau false, similar cu evaluarea condiţiei y<0, care este evaluată la true sau false ==> acoperirea condiţiei este similară cu acoperirea deciziei; Acoperirea deciziilor şi condiţiilor. Definiţie acoperirea deciziilor şi condiţiilor (engl. decision and condition coverage, dcc): proiectarea cazurilor de testare astfel încât: fiecare condiţie din fiecare decizie ia toate valorile posibile, cel puţin o dată; fiecare decizie ia toate valorile posibile cel puţin o dată; regulă de selectare: pentru fiecare decizie care conţine mai multe condiţii, fiecare condiţie selectată va fi evaluată la true sau false şi împreună cu decizia evaluată la true sau false se vor găsi pe cel puţin un drum. DCC. Exemplu Fiecare condiţie din fiecare decizie trebuie să fie executată cel puţin o dată cu fiecare din valorile posibile, e.g., true, false. Fiecare decizie trebuie să fie executată cel puţin o dată cu fiecare din valorile posibile, e.g., true, false. // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? DCC. Exemplu (cont.) // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? Criteriul de acoperire a deciziilor şi condiţiilor este îndeplinit 100%. Toate rezultatele posibile ale evaluării condiţiilor din decizie au fost explorate. Ambele ramificaţii ale deciziei au fost explorate. DCC vs. CC, DCC vs. DC dcc ===> cc; prin acoperirea deciziilor şi condiţiilor se acoperă condiţiile; dcc ===> dc; prin acoperirea deciziilor şi condiţiilor se acoperă deciziile; caz particular: dcc = dc şi dcc = cc atunci când decizia conţine doar o condiţie; e.g., decizia y<0 este evaluată la true sau false, similar cu evaluarea condiţiei y<0, care este evaluată la true sau false ==> acoperirea deciziei şi condiţiei (dcc) este similară cu acoperirea deciziei (dc), care este similară cu acoperirea condiţiei (cc); dcc se aplică doar atunci când decizia este formată din mai multe condiţii. DCC. Observaţii condiţiile logice care folosesc operatorii && şi || nu pot fi acoperite prin dcc, deoarece compilatorul realizează diverse optmizări (scurt-circuitare la evaluare); Este necesară acoperirea condiţiilor multiple. Acoperirea condiţiilor multiple. Definiţie acoperirea condiţiilor multiple (engl. multiple condition coverage, mcc): proiectarea cazurilor de testare se realizează asfel încât: toate combinaţiile posibile ale valorilor de ieşire ale unei condiţii, în fiecare decizie, să fie parcurse cel puţin o dată; regulă de selectare: fiecare decizie care conţine mai multe condiţii, va combina fiecare condiţie selectată care este evaluată la true sau false cu celelalte condiţii în toate variantele posibile şi împreună cu decizia evaluată la true sau false se vor găsi pe cel puţin un drum. MCC. Exemplu Fiecare condiţie din fiecare decizie trebuie să fie executată în toate combinaţiile posibile cu toate celelalte condiţii din cadrul aceleaşi decizii. // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? MCC. Exemplu (cont.) // returnează true dacă (x,y) este în cadranul (5,5). boolean in5By5 (int x, int y) { boolean ret; if (x<5 && y<5) ret = true; else ret = false; return ret; } Care este numărul minim de cazuri de testare necesar ? Criteriu de acoperire a condiţiilor multiple îndeplinit 100%. Toate cominaţiile posibile ale condiţiilor au fost explorate. MCC vs. DCC mcc ===> dcc; prin acoperirea multiplă a condiţiilor se acoperă deciziile şi condiţiile; Testare bazată pe acoperirea codului sursă. Reguli de acoperire minimală dacă programul are o singură condiţie în fiecare vârf de decizie, atunci se aplică acoperirea deciziilor (dc), în acest caz dc = cc; dacă programul are condiţii multiple în vârfuri de decizie, atunci se aplică acoperirea condiţiilor multiple (mcc). SC vs DC. vs. CC vs. DCC vs. MCC vs. APC Acoperirea buclelor. Definiţie acoperirea buclelor (engl. loop coverage, lc); proiectarea cazurilor de testare astfel încât structurile repetitive să fie iterate de un număr variabil de ori; LC. Clasificarea buclelor. Reprezentări tipuri de bucle: simple; imbricate; concatenate; nestructurate. LC. Bucle simple bucle simple (n – numărul maxim de parcurgeri al buclei): omiterea bublei (0 parcurgeri); 1 parcurgere a buclei; 2 parcurgeri ale buclei (evidenţiază defecte de iniţializare); m parcurgeri ale buclei, unde m < n; n-1 parcurgeri ale buclei; n parcurgeri ale buclei; n + 1 parcurgeri ale buclei. LC. Bucle imbricate bucle imbricate: se porneşte de la bucla cea mai interioară; toate celelalte bucle sunt setate pe valori minime; se testează bucla cea mai interioară ca şi buclă simplă, păstrând buclele exterioare la valoarea minimă a parametrului de iteraţie; se progresează spre exterior, testându-se următoarea buclă şi păstrând buclele exterioare la valorile minime; se continuă până când toate buclele sunt testate. LC. Bucle concatenate bucle concatenate: dacă buclele sunt indepedente unele de altele: se aplică testarea buclelor simple; dacă buclele sunt dependente (e.g., variabila de indexare a primei bucle este valoarea iniţială a celei de a doua): se aplică testarea buclelor imbricate. LC. Bucle nestructurate bucle nestructurate: în general, indică folosirea instrucţiunii goto; se recomanda restructurarea acestui tip de buclă pentru a reflecta elementele programării structurate. TESTARE WHITE-BOX VS. TESTARE BLACK-BOX Testare White-Box. Avantaje si dezavantaje Testare White-Box vs. Testare Black-Box Testare White-Box Avantaje cazurile de testare sunt proiectate pe baza structurii interne a codului sursă, i.e., în funcţie de structurile de programare folosite; identifică disfuncţionalităţi în execuţia anumitor secvenţe de cod, e.g., unele structuri de programare nu sunt acoperite; permite acoperirea cu teste a codului scris; Dezavantaje nu poate testa cerinţe care nu sunt implementate, nu poate identifica bug-urile din codul sursă care lipsește; proiectarea cazurilor de testare poate începe doar după implementare; testerul trebuie să cunoască limbajul de programare în care a fost elaborat codul sursă; ineficientă pentru module de mari dimensiuni. Testarea Black-Box vs. Testare White-Box Testare Black-Box Testare funcţională, testare comportamentală (engl. behavioral testing); cazurile de testare sunt proiectate pe baza specificaţiilor, nu este necesar să avem acces la codul sursă; suprinde ambiguităţile sau inconsistenţele din specificaţii; nu se există informaţii despre implementare; activitatea testerului este independentă de cea a programatorului; testerul poate proiecta cazurile de testare înainte de finalizarea codului sursă; eficientă şi pentru module de mari dimensiuni. Testare White-Box Testare structurală (engl. structural testing); cazurile de testare sunt proiectate pe baza structurii interne a codului sursă, i.e., în funcţie de structurile de programare folosite; nu poate testa cerinţe care nu sunt implementate; proiectarea cazurilor de testare poate începe doar după implementare; ineficientă pentru module de mari dimensiuni – construirea CFG şi calculul CC sunt activităţi costisitoare. Testarea Black-Box vs. Testarea White-Box Întrebări: Ce cazuri de testare trebuie actualizate după modificarea specificațiilor și a codului sursă asociat? Ce cazuri de testare trebuie actualizate după modificarea codului sursă, fără modificarea specificaţiilor? PENTRU EXAMEN... Pentru examen... testare white-box: definiţie, caracteristici, avantaje şi dezavantaje; CFG (definiţie şi construire), drumuri independente (definiţie), CC (definiţie, 3 moduri de calcul); construirea CFG, determinarea drumurilor independente şi calculul CC (3 moduri) pentru metode concrete; criteriile de acoperire apc, sc, dc, cc, dcc, mcc şi lc (definiţie, compararea a două criterii, relaţiile existente între criterii); testare black-box vs. testare white-box. Cursul următor... Niveluri de testare Definiţie. Clasificare Testare unitară Testare de integrare Testare funcţională Testare de sistem Testare funcţională Testare non-funcţională Testare de acceptare Nivel de testare vs. Tip de testare Referințe bibliografice [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [Collard2003] J. F. Collard, I. Burnstein. Practical Software Testing. Springer-Verlag New York, Inc., 2003. [Beizer1990] Beizer, B., Software Testing Techniques, Van Nostrand Reinhold., New York, 1990. CURS 04. NIVELURI DE TESTARE Verificarea și validarea sistemelor soft [18 Martie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Niveluri de testare Definiţie. Clasificare Testare unitară Definiţie. Motivație. Caracteristici Proiectarea cazurilor de testare Tipuri de bug-uri identificate Reguli generale de aplicare Testare de integrare Definiţie. Motivație. Clasificare Integrare non-incrementală. Integrare incrementală. Integrare mixtă Compararea strategiilor de integrare Testarea interfeţei modulelor. Definiţie. Clasificare Tipuri de bug-uri identificate Exemplu Testare de sistem Definiţie. Caracteristici Testare funcţională Testare non-funcţională Testare de acceptare Definiţie. Caracteristici. Etape de realizare Clasificare Alpha Testing. Beta Testing Alpha Testing vs Beta Testing Alte tipuri de testare de acceptare Dificultăţi de testare Nivel de testare vs. Tip de testare Tip de testare. Nivel de testare. Definiţie Obiective de testare. Exemple Retestare. Definiţie Testare de regresie. Definiţie Retestare vs Testare de regresie Pentru examen... Bibliografie NIVELURI DE TESTARE Definiţie. Clasificare Nivel de testare. Definiţie. Clasificare nivel de testare (engl. testing level): o serie de activităţi de testare asociate unei etape din procesul de dezvoltare a produsului soft; clasificare: testare unitară / testare de modul (engl. unit testing, module testing); etapa: implementare/codificare; testare de integrare (engl. integration testing); etapa: proiectare; testare de sistem (engl. system testing); etapa: specificarea cerințelor sistemului = stabilirea obiectivelor de realizat; testare de acceptare (engl. acceptance testing); etapa: descrierea cerințelor utilizatorului. TESTARE UNITARĂ Definiţie. Motivație. Caracteristici Proiectarea cazurilor de testare Tipuri de bug-uri identificate Reguli generale de aplicare Testare unitară. Definiție. Motivație. Etape testare unitară/ testare de modul (engl. unit testing, module testing) : testarea individuală a unor unități separate dintr-un sistem software (funcție, procedură, clasă, metodă); motivație: gestionarea eficientă a modulelor sistemului – mai întâi se testează modulele; proces de depanare eficient – aplicat la nivel de modul; permite paralelizarea procesului de testare – testare simultană pentru mai multe module. etape: contextul de testare; proiectarea cazurilor de testare; execuția cazurilor de testare și evalurea rezultatelor testării. la nivelul testării unitare se folosesc diferiţi termeni pentru a indica obiecte, stări sau caracteristici care apar la proiectarea cazurilor de testare; literatura de specialitate indică abordări diferite în descrierea obiectelor folosite, denumite generic Test Doubles, sugerând funcţionarea obiectelor utilizate în realitate ; tipuri de obiecte utilizate de tool-uri: Dummy – obiecte care sunt transmise ca parametri dar care nu sunt folosite de metodele apelate; e.g., diverşi parametri precizaţi doar pentru a respecta signatura metodei apelate; Fake – obiecte cu implementări funcţionale/utilizabile, dar simpliste, care nu sunt adecvate pentru a fi incluse în livrabilul către client; e.g., o colecţie de date in-memory; Stubs – obiecte sau metode ale unor obiecte care furninează rezultate prestabilite atunci când sunt apelate în cadrul unui test; nu au altă utilitate în afara contextului testării unde au fost definite; Spies – obiecte stub care pot păstra/reţine informaţii referitoare la modul în care au fost folosite; e.g., un serviciu pentru e-mail care reţine numărul de mesaje transmise; Mocks – obiecte pentru care s-a stabilit un anumit comportament (behavior expectations) şi sunt utilizate pentru a observa interacţiunea cu obiectul supus testării. Testare unitară. Context de testare tipuri de module: driver (engl. driver): modul apelant al modulului testat, care furnizează datele de intrare modulului testat; stub (engl. dummy subprogram): modul apelat în cadrul modulului testat, înlocuiește modulul apelat în contextul real; arată că modulul testat apelează un modul subordonat; returnează o valoare prestabilită în modulul testat care să îi permită să își continue execuția; pentru fiecare modul testat trebuie să existe un driver dedicat și mai multe module stub, dacă este necesar; modulele driver și stub sunt create suplimentar (engl. overhead) și nu sunt livrate împreună cu produsul final; Testare unitară. Proiectarea cazurilor de testare caracteristici: aplică tehnici de testare black-box, grey-box și white-box; folosește documentele care conţin specificația modulelor; informații necesare proiectării unui caz de testare pentru un modul: specificația modulului; codul sursă pentru modul; tipuri de bug-uri identificate: testarea black-box: nerespectarea condițiilor impuse în specificaţii; înțelegerea greșită a specificațiilor; testarea white-box: înțelegerea greșită a precedenței operatorilor; inițializare incorectă; lipsa acurateței/preciziei; operații aplicate eronat. număr de paşi de executat; execuţie: planificare şi durată; consecvenţă; atomicitate; responsabilitate unică; izolarea testelor; izolarea de mediul de execuţie; izolarea claselor; automatizare completă; self-descriptive; fără condiţii logice; fără bucle; fără tratarea excepţiilor; utilizarea instrucţiunilor assert; utilizarea de mesaje sugestive; fără testare în codul sursă livrat; separarea pe module şi niveluri ale arhitecturii; gruparea testelor în funcţie de tipul de testare. număr de paşi de executat: 3-5 paşi: set up; date de intrare; apelarea metodei testate; verificarea rezultatului (assert); tear down; timp de execuţie: frecvenţa de execuţie: testare după implementare (engl. test after development): de câteva ori pe zi; dezvoltare dirijată de testare (engl. test driven development): de câteva ori pe oră; execuţie după salvare, IDE (engl. IDE runs tests after save): la fiecare câteva minute; mod de execuţie (singular sau suită de teste): timp de execuţie pentru 10 teste = timp de execuţie 1 test x 10; un test care se execută greu, încetineşte întreaga suită de teste; valori medii: un test < 200 milisecunde; o suită cu număr de redus de teste < 10 secunde; o suită cu număr consistent de teste < 10 minute. consecvenţă: execuţia repetată a aceluiaşi test ar trebui să returneze în mod repetat acelaşi rezultat, dacă nu au avut loc modificări asupra codului sursă; cod sursă problematic: Date current Date = new Date(); Int value = random.nextInt(100); soluţii: utilizarea obiectelor dummy, mock, stub, fake; injectarea dependenţelor. atomicitate: rezultate posibile ale execuţiei unui test: passed; failed; nu există teste care „au trecut” doar parţial; dacă un punct de execuţie este failed ==> întregul test este failed. un caz de testare investighează un singur scenariu de execuţie; se testează comportamentul metodei: o metodă, mai multe utilizări (comportamente) ==> mai multe teste şi cel puţin un test pentru fiecare comportament; mai multe instrucţiuni assert în acelaşi test – doar dacă verifică acelaşi comportament; o utilizare (comportament) descrisă prin folosirea mai multor metode ==> un singur test; E.g.: o metodă care apelează metode private/ protected/ publice, simple, e.g., getters, setters, constructori simpli. o metodă, mai multe utilizări (comportamente) ==> mai multe teste; o utilizare (comportament) descrisă prin folosirea mai multor metode ==> un singur test; comportament 1 = condition1 + condition2 + condition3 ; comportament 2 = condition4 + condition5; izolarea testelor (unele de altele): testele trebuie să fie independente unele de altele. la execuţii diferite (la momente de timp diferite, în ordine diferită) ale aceluiaşi test trebuie să se obţină aceleaşi rezultate. nu se partajează starea/ contextul de execuţie între teste; variabile folosite la testare, e.g., JUnit – variabile partajate sau nu între teste: @Before, @BeforeClass. testele trebuie izolate de influenţele mediului de execuţie; E.g., baze de date; apelarea serviciilor web; Java Naming and Directory Interface (JNDI); variabile de mediu definite local; fişiere de proprietăţi; configurările de dată şi oră ale sistemului. codul sursă livrabil (engl. production code) foloseşte mediul de execuţie; la testare se foloseşte un mediu de testare, care nu este întotdeauna identic cu mediul de execuţie de la dezvoltarea codului sursă sau de la client; soluţie: se utilizează obiecte mock care indică un anumit mediu de utilizare; Avantaje: rapiditate; uşor de dezvoltat; reutilizabilitate; E.g.: biblioteci Java: EasyMock; Jmock; Mockito. izolarea claselor: clase fără dependenţe clase cu dependenţe soluţie: dependenţe dummy, mock, stub, fake; izolarea claselor: dificil de realizat dacă avem un cod sursă greu de testat; se recomandă: folosirea metodelor Factory sau injectarea dependenţelor, în locul apelului constructorilor în cadrul metodelor; folosirea interfeţelor. automatizare completă: fără paşi executaţi manual pe durata testării. se automatizează: execuţia testelor; colectarea rezultatelor testării; stabilirea rezultatului testării (passed/ failed); trasmiterea rezultatelor testării prin: e-mail, IDE integration, etc; self-descriptive: la nivelul testării unitare un test reprezintă: documentaţie la nivel de dezvoltare; metodă de specificare care reflectă versiunea actualizată a cerinţelor; caracteristici: un test trebuie să fie uşor de citit şi înţeles; denumirile variabilelor, metodelor şi claselor trebuie să fie self-descriptive; nu trebuie să conţină condiţii logice sau iteraţii; numele cazurilor de testare trebuie să fie sugestive pentru a indica condiția de succes sau eșec: public void canMakeReservation(); public void cannotAddNewBook(); fără instrucţiuni logice: un caz de testare nu ar trebui să conţină instrucţiunea if sau switch; nu există incertitudini legate de: datele de intrare ==> toate datele de intrare sunt cunoscute; comportamentul aşteptat ==> comportamentul metodei este predictibil; datele de ieşire ==> rezultatele aşteptate ar trebui să fie bine definite. fără instrucţiuni logice: mai multe condiţii trebuie să se regăsească în cazuri de testare distincte, nu în acelaşi test, fiind tratate ca şi ramificaţii ale instrucţiunilor alternative, i.e., if, switch; fără instrucţiuni iterative (i.e., while, do while, for): scenarii tipice pentru iteraţii: câteva sute de iteraţii: dacă sunt necesare câteva sute de iteraţii, atunci testul este destul de complicat şi este necesar să fie simplificat; câteva iteraţii: se recomandă refactorizarea codului care trebuie să se repete într-o metodă, care să fie apelată ulterior explicit de câte ori este necesar; număr de iteraţii necunoscut: numărul de iteraţii este greu de evitat, indicând faptul că e posibil ca testul să fie incorect şi se recomandă specificarea mai clară a datelor de intrare; instrucţiunea assert: se recomandă: utilizarea instrucţiunilor assert disponibile în platforma de testare; crearea propriilor aserţiuni pentru verificarea condiţiilor complexe care se repetă în diferite teste; reutilizarea propriilor metode asertive; utilizarea aserţiunilor în cadrul buclelor. mesaje sugestive în instrucţiunea assert: prin citirea mesajului din aserţiune se poate recunoaşte uşor problema care a determinat eşuarea testului; avantaje: permit îmbunătăţirea documentaţiei codului sursă; oferă informaţii asupra problemei dacă testul a eşuat (failed). codul sursă nu include teste: se recomandă: separarea testelor de codul sursă livrat; clasele să nu definească metode şi/sau atribute care sunt folosite doar la testare. gruparea testelor în funcţie de tipul de testare: după modulul testat: organizarea testelor în pachete corespunzătoare modulelor testate; utilizarea unei abordări ierarhizate; scăderea timpului de execuţie pentru suitele de teste prin împărţirea acestora în suite de dimensiuni mai mici, i.e., suitele de mici dimensiuni pot fi executate mai des/frecvent; după tip: scopul / obiectivele testării; frecvenţa de execuţie; momentul execuţiei suitei; acţiunea în caz de eşec. TESTARE DE INTEGRARE Definiţie. Motivație. Clasificare Integrare non-incrementală. Integrare incrementală. Integrare mixtă Compararea strategiilor de integrare Testarea interfeţei modulelor. Definiţie. Clasificare Tipuri de bug-uri identificate Exemplu Testare de integrare. Definiţie. Motivaţie testare de integrare (engl. integration testing): nivel de testare în care modulele individuale se combină şi se testează ca un grup; permite construirea structurii programului pe măsură ce este testat pentru a identifica erorile la nivelul interfeţei dintre module; motivaţie: module diferite sunt implementate de programatori diferiţi; testarea unitară se desfăşoară într-un mediu controlat şi izolat, folosind entităţi driver şi stub (mock, fake, dummy); unele module pot genera mai multe defecţiuni decât altele. Testare de integrare. Clasificare abordări de integrare/ clasificare: non-incrementală big-bang; incrementale top-down; bottom-up; mixtă sandwich. Integrarea Big-bang. Descriere Procesul de integrare Big-bang: testare unitară pentru fiecare modul, folosind: un modul driver; câteva module stub; se combină simultan modulele pentru construirea funcţionalităţii programului; dezavantaje: necesită un volum de muncă ridicat; depanare dificilă – este dificil de izolat modulul care a determinat defecţiunea; dacă programul este complex – este dificil de urmărit modul în care s-au executat funcţionalităţile. avantaje: dezvoltare şi testare unitară paralelă. Integrare incrementală Top-down. Descriere integrare incrementală Top-down (engl. Top- down incremental integration): permite construirea şi testarea programului adăugând module noi pe parcurs; integrarea modulelor se face de sus în jos, de la modulul principal, modulele subordonate sunt încorporate succesiv; defectele sunt uşor de izolat şi corectat; testarea este aplicată sistematic. tipuri de integrare Top-down: în adâncime (engl. depth-first integration); pe niveluri (engl. breadth-first integration); integrarea depth-first integrează toate componentele de pe o ramificaţie majoră a arhitecturii aplicaţiei; ordinea de integrare a ramificaţiilor depinde de caracteristicile aplicaţiei; integrarea breadth-first integrează toate componentele care se află pe nivelul direct subordonat, i.e., pe orizontală; Integrare incrementală Top-down. Algoritm după testarea unitară a modulului principal folosind stub-uri pentru modulele imediat subordonate, procesul de integrare Top-down constă în: în funcţie de tipul de integrare ales (depth-first/ breadth-first), se înlocuieşte un stub cu un modul real; se testează cu modulul subordonat concret care a fost integrat; pentru integrarea unui nou modul se repetă paşii 1 şi 2. driver = modulul principal; nu se folosesc alte drivere; stub = înlocuieşte un modul direct subordonat; E.g., depth-first: M1, M2, M5, M8, M6, M3, M7, M4; breadth-first: M1, M2, M3, M4, M5, M6, M7, M8. Integrare incrementală Bottom-up. Descriere integrare incrementală Bottom-up (engl. Botton-up incremental integration): permite construirea şi testarea programului pornind de la modulele atomice, i.e., componentele care nu au module dependente; defectele modulelor aflate pe nivelurile inferioare sunt uşor de izolat şi corectat. modulele terminale se pot organiza în grupuri (engl. clusters); driver = se folosesc doar pentru modulele terminale (care nu au module subordonate) sau grupurile de module; stub = nu se folosesc; Integrare incrementală Bottom-up. Algoritm Procesul de integrare Bottom-up: pentru toate modulele terminale sau clusteri de module se descriu drivere şi se testează; module terminale: se înlocuieşte driver-ul cu modulul de pe nivelul imediat superior şi se testează, continuând integrarea modulelor spre partea superioară a structurii programului; clusteri de module: se înlătură driver-ul, iar clusterul de module se combină cu alte module continuând integrarea spre partea superioară a structurii programului. componentele se combină în clusterii 1 , 2 şi 3; clusterii se testează folosind driver-ele D1, D2 şi D3; se înlătură D1 şi D2, iar clusterul 1 şi clusterul 2 sunt integraţi în Ma; similar, D3 este înlăturat iar clusterul 3 este integrat cu modulul Mb. Ma şi Mb se vor integra în Mc. Integrare Sandwich. Descriere integrare sandwich (engl. sandwich integration): permite construirea şi testarea programului combinând abordările de integrare top-down şi bottom-up; Procesul de integrare Sandwich: modulele terminale (bottom-layer): integrare bottom-up; modulul principal (top-layer): integrare top-down; celelalte module (middle-layer): integrare big-bang. Testare de integrare. Compararea strategiilor de integrare Testarea interfeţei modulelor. Definiţie. Clasificare testarea interfeţei modulelor (engl. interface integration testing): se realizează la integrarea mai multor module pentru obţinerea unor sisteme de dimeniuni mai mari; relevantă în dezvoltarea orientată pe obiecte, comportamentul acestora fiind descris prin intermediul interfeţelor; obiective: identificarea defectelor care pot apărea la utilizarea unei interfeţe a unui alt modul sau false presupuneri legate de interfaţa unui modul; comunicarea între module poate fi bazată pe: parametri: la transmiterea datelor de la o metodă la alta; memorie partajată: o zonă de memoria este partajată între module; comportament: un sub-sistem încapsulează un set de metode care sunt apelate de alte sub- sisteme; mesaje: un sub-sistem are nevoie de serviciile altor sub-sisteme; Testarea interfeţei modulelor. Tipuri de bug-uri identificate tipuri de bug-uri [, pagina 161]: utilizarea greşită a interfeţei (engl. interface misuse): un modul apelează un alt modul eronat, e.g., parametrii sunt transmişi în ordinea greşită; înţelegerea greşită a semnificaţiei interfeţei (engl. interface misunderstanding): un modul face presupuneri greşite referitare la comportamentul unui alt modul apelat, e.g., se interpretează că mai mulţi parametri de acelaşi tip au altă semnificaţie; greşeli de sincronizare (engl. timing errors): modulul apelat şi modulul apelant folosesc unităţi de timp diferite, e.g., minute, secunde, milisecunde, iar informaţia obţinută îşi pierde acurateţea. Testare de integrare. Reguli generale de aplicare se studiază arhitectura aplicaţiei pentru identificarea modulelor critice; aceste module se testează cu prioritate; testerul este familiarizat cu modulele care se integrează (arhitectura modulelor); se aplică o strategie de integrare care să permită atingerea obiectivelor testării; fiecare modul este testat înainte de a execuţia testelor de integrare, i.e., unit testing; se utilizează documentaţia care descrie interacţiunile dintre fiecare două module (interfeţele acestora şi modul de colaborare). TESTARE DE SISTEM Definiţie. Caracteristici Testare funcţională Testare non-funcţională Testare de sistem. Definiţie. Caracteristici testare de sistem (engl. system testing): verifică dacă produsul dezvoltat respectă obiectivele iniţiale; elaborarea cazurilor de testare se bazează pe: documentul cu specificaţiile sistemului? nu, deoarece pot apărea erori în procesul de transpunere a obiectivelor în specificaţii externe; documentele cu obiectivele stabilite? nu, deoarece nu conţin descrierea exactă a interfeţelor externe ale programului; obiectivele nu oferă informaţii cu privire la funcţionalitatea sistemului (interfeţe ale documentaţia de utilizare a produsului soft? da; proiectarea testării de sistem – pe baza analizei obiectivelor; descrierea cazurilor de testare – pe baza analizei documentaţiei de utilizare. Testare de sistem. Caracteristici nu există metodologie pentru proiectarea cazurilor de testare în testarea de sistem; se proiectează două categorii de teste asociate: cerinţele funcţionale ==> testare funcţională; cerinţele non-funcţionale ==> testare non-funcţională (engl. non-functional testing); la acest nivel de testare, proiectarea cazurilor de testare este determinată de obiectivele de testare şi de strategia aleasă, evidenţiind creativitatea şi experienţa. Testare de sistem. Testare funcţională a sistemului testare funcţională a sistemului (engl. function/functional testing, use case testing): testarea cerinţelor descrise în specificaţiile sistemului; proces care identifică neconcordanţele existente între comportamentul programului şi specificaţia acestuia, din punctul de vedere al utilizatorului; elaborarea cazurilor de testare se bazează pe criteriul black-box; foloseşte specificaţia sistemului. Testare funcţională a sistemului. Proiectarea cazurilor de testare caz de utilizare vs. caz de testare: cazurile de utilizare descriu fluxul de execuţie al unui proces în cadrul sistemului, folosind scenarii de utilizare frecventă; cazurile de testare sunt derivate din cazurile de utilizare şi pot indica prezenţa unui bug la utilizarea concretă a sistemului; fiecare caz de testare se bazează de obicei pe un scenariu şi acoperă diferite ramificaţii de execuţie (indicate prin cazuri speciale de date de intrare sau condiţii speciale); pentru un caz de testare specifică: toate precondiţiile care este necesar să fie satisfăcute pentru execuţia cazului de utilizare cu succes; postcondiţiile impuse asupra rezultatelor obţinute; descrierea stării finale a sistemului după ce testarea cazului de utilizare s-a realizat cu succes; Testare de sistem. Testare non-funcţională. Definiţie testare non-funcţională (engl. non- functional testing): verifică modul în care sistemul îndeplineşte cerinţele non-funcţionale; stabileşte dacă sistemul este pregătit pentru a fi efectiv utilizat; în [, Cap 6] sunt descrise 15 tipuri de testare (non-funcţională) de sistem pentru care se scriu cazuri de testare: Volume testing; Stress testing; Usability testing; Security testing; Performance testing; Storage testing; Configuration testing; Compatibility/Conversion testing; Instability testing; Reliability testing; Recovery testing; Serviceability testing; Documentation testing; Procedure testing; Facility testing. performance testing: - cât de bine face sistemul ceea ce trebuie să facă fiecare sistem are cerinţe referitoare la performanţa utilizării; e.g., execuţia unei funcţionalităţi să fie realizată într-un anumit interval de timp, iar resursele să nu fie infinite; bug-urile legate de performanţă indică deficienţe la nivel de proiectare care determină degradarea performanţei sistemului soft în timpul utilizării; obiectiv: identificarea blocajelor determinate de reducerea performanţei componentelor şi a sistemelor, i.e., bottlenecks; tipuri: Capacity Testing, Load Testing; Volume Testing, Stress Testing; Soak Testing, Spike Testing. capacity testing: permite preveniea eventualelor probleme determinate de creşterea numărului de utilizatori sau a volumului de date; obiectiv: obţinerea de informaţii referitoare la nivelul maxim de utilizatori şi/sau date care nu afectează performanţa: E.g.: câte fişiere pot fi folosite fără a afecta performanţa. load testing: evaluează capacitatea sistemului de opera cu volume de date normale sau în condiţii de solicitare (vârf); obiectiv: obţinerea de informaţii referitoare la comportamentul sistemului în anumite condiţii de utilizare, i.e., normale şi de solicitare: E.g.: creşterea numărului de fişiere folosite. volume testing: evaluează comportamentul sistemului atunci când se gestionează volume mari de date; obiectiv: obţinerea de informaţii legate de funcţionarea aplicaţiei cu un volum de date ridicat: E.g.: creşterea dimensiunii fişierelor folosite. stress testing: - pune presiune asupra limitelor sistemului investighează dacă comportamentul softului se degradează în condiţii extreme de utilizare şi când nu are acces la resursele necesare; este de dorit ca degradarea softului cauzată de creşterea numărului de cereri să se realizeze acceptabil, fără să ducă la un eşec imediat în timpul testării; sistemul nu trebuie să eşueze catrastofal; relevant pentru sistemele distribuite care pot indica o degradare severă atunci când reţeaua devine încărcată; obiectiv: obţinerea de informaţii despre modul în care sistemul funcţionează în condiţii extreme, dincolo de limitele normale: E.g.: creşterea numărului de fişiere folosite până la failure şi chiar mai mult; verifică dacă are loc o pierdere inacceptabilă de date şi/sau imposibilitatea de a utiliza anumite servicii. soak testing: verifică dacă sistemul face faţă unui volum mari de date pentru o perioadă mai mare de timp; obiectiv: obţinerea de informaţii legate de posibilitatea de a utiliza volum de date şi care sunt consecinţele dacă se depăşeşte vomulul pentru care a fost proiectat: E.g.: verifică dacă creşterea dimensiunii fişierelor folosite este suportată. spike testing: evaluează comportamentul sistemului la schimbări bruşte şi extreme a condiţiilor de lucru, i.e., puţine sarcini, multe sarcini; obiectiv: obţinerea de informaţii legate de punctele slabe ale sistemului determinate de modificarea rapidă a condiţiilor de lucru: E.g.: creşterea brusc şi diminuarea rapidă a numărului de fişiere cu care se lucrează. reliability testing: investighează capacitatea un soft de a funcţiona conform aşteptărilor utilizatorului, chiar şi atunci când eşuează; determină cât timp şi cât de eficient poate funcţiona sistemul fără eroare; security testing: calitatea, securitatea şi gradul de încredere în aplicaţie (engl. reliability) sunt caracteristici depedendente; defectele produsului soft pot fi exploatate pentru a identifica breşe de securitate; presupune simularea unor atacuri la nivel de securitate, având scopul de a identifica vulnerabilităţile softului. TESTARE DE ACCEPTARE Definiţie. Caracteristici. Etape de realizare. Clasificare Alpha Testing. Beta Testing Alpha Testing vs Beta Testing Alte tipuri de testare de acceptare Dificultăţi de testare Testare de acceptare. Definiţie. Clasificare testare de acceptare (engl. user acceptance testing, UAT): procesul de testare prin care se verifică dacă programul îndeplineşte cerinţele iniţiale şi nevoile curente ale utilizatorului final; nu este responsabilitatea dezvoltatorului produsului; tester = clientul/ beneficiarul; realizată efectiv de către client, care aplică tehnici de testare black-box. tipuri de testare de acceptare: alpha testing, beta testing; contract acceptance testing; regulation acceptance testing; operational acceptance testing. Testare de acceptare. Etape de realizare etape de realizare: definirea criteriilor prin care produsul soft este considerat funcţional; creare unei suite de cazuri de testare pentru UAT; rularea testelor UAT; evaluarea şi raportarea rezultatelor. Testare de acceptare. Alfa Testing. Beta Testing Testare de acceptare. Alpha Testing vs Beta Testing Testare de acceptare. Tipuri de de testare de acceptare contract acceptance testing: produsul soft este testat din perspectiva îndeplinirii unor criterii şi specificaţii care sunt precizate într-un contract de colaborare între dezvoltator şi client; criteriile şi specificaţiile de acceptanţă sunt stabilite la semnarea contractului, înainte de dezvoltarea softului; regulation acceptance testing, i.e., compliance acceptance testing: verifică dacă produsul soft dezvoltat respectă regulamentele şi legile în vigoare referitoare de utilizarea şi funcţionarea unui produs soft specfic; operational acceptance testing, i.e., operational readiness testing, production acceptance testing: verifică dacă există fluxurile informaţionale necesare pentru utilizarea produsului soft de către client (e.g., planuri de backup, training pentru utilizatori, diferite procese de întreţinere şi verificări de securitate). Testare de acceptare. Dificultăţi de testare dificultăţi care apar la nivelul testării de acceptare: cerinţe care nu sunt descrise satisfăcător (clar, complet, corect); planificarea târzie (defectuoasă) a activităţilor de testare; testarea nu este realizată riguros, nu este o activitate planificată şi monitorizată; identificarea tardivă a defectelor, cu dificultăţi de eliminare a acestora. TIP DE TESTARE VS NIVEL DE TESTARE Tip de testare. Nivel de testare. Definiţie Obiective de testare. Exemple Retestare. Definiţie Testare de regresie. Definiţie Retestare vs Testare de regresie Tip de testare. Nivel de testare. Definiţie nivel de testare (engl. testing level): o serie de activităţi de testare asociate unei etape din procesul de dezvoltare al produsului soft; Ce testez? tip de testare (engl. testing type): mijlocul prin care un obiectiv al testării, stabilit anterior pentru un nivel de testare, poate fi realizat; Cum testez? Tip de testare. Exemple exemple de tipuri de testare: testarea unei metode: se poate realiza prin aplicarea unor criterii de testare (black-box, white-box), la nivelul testării unitare sau de integrare; testarea unei caracteristici non-funcţionale: se realizează prin aplicarea unui anumit tip de testare, e.g., testare de performanţă, testare de utilizabilitate, cu scopul de a evalua o caracteristică a calităţii produslui soft, la nivelul testării de sistem; testarea după eliminarea unui bug: se realizeză prin aplicarea re-testării (engl. re-testing, confirmation testing) după depanare, la orice nivel de testare; testarea legată de eliminarea unui bug: se realizează prin testarea de regresie (engl. regression testing), pentru a verifica dacă eliminarea unui bug nu are efecte secundare asupra softului, la orice nivel de testare. Re-testare. Definiţie re-testare (engl. re-testing, confirmation testing): re-execuţia testelor care au pus în evidenţă anterior un bug ce se presupune că a fost eliminat; scop: confirmarea că defectul a fost eliminat; cazurile de testare re-executate sunt identice cu cele rulate anterior; Testare de regresie. Definiţie testare de regresie (engl. regression testing): re-execuţia unor teste care au fost rulate anterior cu succes; scop: identificarea efectelor secundare (bug-uri) care pot apărea în urma modificării unor module; cazurile de testare se pot organiza in teste de regresie, care permit testarea: tuturor funcţionalităţilor sistemului; funcţionalităţilor cu probabilitate ridicată de a fi afectate de modificări; comportamentului componentelor sistemului care au fost modificate. testare de regresie ≠ re-testare; Niveluri de testare. Tipuri de testare PENTRU EXAMEN... Pentru examen... Niveluri de testare. Definiţii şi caracteristici: testare unitară; testare de integrare; 4 strategii (big-bang, top-down, bottom-up, sandwich), descriere, comparare; testare de sistem; testare funcţională; 5 tipuri de testare non-funcţională (volume, stress, load, usability, security) . testare de acceptare; alpha testing, beta testing. Tip de testare vs Nivel de testare. Definiţii şi caracteristici: re-testare; testare de regresie. Cursul următor... Curs 05: Tematică Test Automation Demo: Selenium WebDriver + Serenity BDD Performance Testing Companie IT invitată: Evozon Data: Marți, 25 Martie 2025; Orele: 08:00-10:00; Desfăşurare: Sala 6/II (Gh. Călugareanu), Clădirea Centrală a UBB. Cursul următor... Curs 06: Demo Mockito Create and Solve a Puzzle termen: 02 mai 2025, orele 20:00; echipe: max. 3 studenţi/echipă, i.e., echipe de forma (A, B, C) sau (A, B); echipele participante pot rezolva unul sau ambele task-uri de mai jos; pentru fiecare task rezolvat corect se acordă câte 2 puncte pentru activitatea Games fiecărui membru din echipă; Task 01. Create a Puzzle: cu min. 20 concepte studiate la VVSS; se va accesa pagina  şi se va alege tipul de joc crossword; se va crea un puzzle folosind min. 20 termeni studiaţi în cadrul disciplinei VVSS; se va genera puzzle-ul pe fundal alb şi se va posta pe channel-ul #Games; echipa se va înscrie în fişierul  pentru a putea primi punctajul pentru crearea puzzle-ului; pentru acest task se poate folosi orice alt tool care permite obţinerea puzzle-ului în forma cerută. Create and solve a puzzle Task 02. Solve a Puzzle; o echipă poate rezolva unul sau mai multe puzzle-uri propuse de alte echipe; task-ul se va puncta o singură dată, adică doar una dintre soluţiile propuse (cea cu punctaj maxim) va primi puncte; o echipă poate rezolva un puzzle chiar dacă nu a propus anterior un puzzle; după rezolvarea puzzle-ului (prin editarea fişierului sau listare, apoi rezolvare, apoi poză/scan) de către echipa (X, Y, Z), acesta se trimite doar echipei (A, B, C) care a propus puzzle-ul, pentru a fi evaluat; fiecare răspuns corect primeşte 0.10 puncte (0.10x20 întrebări = 2 puncte); echipa (A, B, C) evaluează soluţia primită şi completează în fişierul  componenţa echipei care a oferit soluţia şi punctajul corespunzător (e.g., 2 puncte, 1.8. puncte); după ce au fost evaluate soluţii oferite de max. 6 echipe participante, echipa care a propus puzzle-ul va posta soluţia la puzzle în thread-ul postării iniţiale pe channel-ul #Games, indicând prin aceasta faptul că nu mai poate primi spre evaluare alte soluţii. Referințe bibliografice [Myers2004] Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., 2004. [NT2005] K. Naik and P. Tripathy. Software Testing and Quality Assurance, Wiley Publishing, 2005. [MeszarosFowler2006] Meszaros, G., Fowler, M., Test Doubles, Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Universitatea Babe¸s-Bolyai Cluj-Napoca 15 Aprilie 2025 Evaluarea calit˘a¸tii softului calitatea softului – conformitatea cu cerin¸tele func¸tionale ¸si de performan¸t˘a precizate, documentate explicit ˆın standardele de dezvoltare ¸si caracteristici implicite ale unui produs soft dezvoltat. [Scott Pressman, 2005] corectitudine – proprietate a unui program de a respecta specifica¸tiile ¸si a oferi rezultate corecte Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Verificarea programelor metode formale pentru verificarea programelor: bazate pe demonstrarea corectitudinii: asistate de calculator, presupune verificarea corectitudinii codului surs˘a asociat programului ; aplicate programelor care trebuie s˘a se termine ¸si s˘a ob¸tin˘a un rezultat (curs 08); bazate pe modele: automate, presupune verificarea propriet˘a¸tilor programului ; aplicate sistemelor concurente; se aplic˘a ˆın etapele post-dezvoltare, e.g., verificarea modelelor. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Metode pentru demonstrarea corectitudinii programelor Robert W Floyd (8 Iunie 1936 – 25 Septembrie 2001) Metoda lui Floyd – metoda aser¸tiunilor inductive; Sir Charles Antony Richard Hoare (11 January 1934) Axiomatizarea lui Hoare – axiome ¸si reguli deductive; dezvoltarea algoritmilor din specifica¸tii; Limbajul lui Dijkstra – instruc¸tiuni cu santinel˘a; non-determinism; derivarea formal˘a a programelor. Edsger Wybe Dijkstra (11 Mai 1930 – 6 August 2002) Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Metoda lui Floyd. Metoda aser¸tiunilor inductive Aplicabilitate: pentru a demonstra: par¸tial corectitudinea programului; terminarea programului; total corectitudinea = par¸tial corectitudinea programului + terminarea programului. Folose¸ste: precondi¸tie – condi¸tia satisf˘acut˘a de datele de intrare ale programului; postcondi¸tie – condi¸tia care trebuie satisf˘acut˘a de rezultatele programului; algoritmul – descrierea programului (codul surs˘a); Etape de aplicare: 1 identificarea unui punct de t˘aietur˘a ˆın fiecare bucl˘a; 2 identificarea unei mul¸timi de aser¸tiuni inductive; 3 construirea ¸si demonstrarea condi¸tiilor de verificare/terminare. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Par¸tial corectitudine. Etape de realizare 1 se aleg puncte de t˘aietur˘a ˆın cadrul algoritmului: dou˘a puncte de t˘aietur˘a particulare: un punct de t˘aietur˘a la ˆınceputul algoritmului, un punct de t˘aietur˘a la sfˆar¸situl algoritmului; cel pu¸tin un punct de t˘aietur˘a ˆın fiecare instruc¸tiune repetitiv˘a; 2 pentru fiecare punct de t˘aietur˘a se alege cˆate un predicat invariant (aser¸tiune): punctul de intrare - φ(X); punctul de ie¸sire - ψ(X,Z); 3 se construiesc ¸si se demonstreaz˘a condi¸tiile de verificare: 1 ∀X ∀Y (Pi (X, Y ) ∧ Rαi,j (X, Y ) → Pj (X, rαi,j (X, Y ))); 2 Y – vector de variabile cu rezultate intermediare; 3 αi,j – drumul de la punctul de t˘aietur˘a i la punctul de t˘aietur˘a j; 4 Pi ¸si Pj – predicate invariante ˆın punctele de t˘aietur˘a i ¸si j asociate; 5 Rαi,j (X, Y ) – predicat care d˘a condi¸tia de parcurgere a drumului α; 6 rαi,j (X, Y ) – func¸tie care indic˘a transform˘arile variabilelor Y de pe drumul α; Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Par¸tial corectitudine. Exemplu. algoritmul pentru ridicarea la putere prin ˆınmul¸tiri repetate: z = xy ; Algoritmul putere(x, y, z) este: A: φ(X ) ::= (x > 0 ∧ y ≥ 0) z := 1; u := x ; v := y ; cattimp (v > 0) executa˘ B: η(X, Y ) ::= z ∗ uv = xy dac˘a (v % 2 == 0) atunci u := u ∗ u; v := v/2; altfel v := v − 1; z := z ∗ u; sfdaca˘ sfcattimp C: ψ(X, Z ) ::= z = xy sfAlg; se aleg punctele de t˘aietur˘a: A, B ¸si C; se stabilesc predicatele invariante pentru punctele de t˘aietur˘a alese: φ(X ), ψ(X, Z ) ¸si η(X, Y ); drumurile α ˆıntre punctele de t˘aietur˘a: {αAB , αBB , αBC , αAC } ⇒ {αAB , αBBatunci , αBBaltfel , αBC , αAC } ; Rαi,j (X, Y ) – predicate pentru parcurgerea drumurilor αi,j ; rαi,j (X, Y ) – func¸tii care indic˘a transform˘arile variabilelor Y de pe drumurile αi,j ; pentru fiecare drum α se construie¸ste ¸si se demonstreaz˘a condi¸tia de verificare de forma ∀X ∀Y (Pi (X, Y ) ∧ Rαi,j (X, Y ) → Pj (X, rαi,j (X, Y ))); Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Terminarea algoritmului. Etape de realizare. 1 se aleg punctele de t˘aietur˘a ˆın cadrul algoritmului; 2 pentru fiecare punct de t˘aietur˘a se alege cˆate un predicat invariant; se alege o mul¸time convenabil˘a M (i.e., o mul¸time par¸tial ordonat˘a, care nu con¸tine nici un ¸sir descresc˘ator infinit) ¸si o func¸tie descresc˘atoare ui ; ˆın punctul de t˘aietur˘a i func¸tia aleas˘a este ui : DX × DY → M; 4 se scriu condi¸tiile de terminare: condi¸tia de terminare pe drumul αi,j este: ∀X ∀Y (φ(X ) ∧ Rαi,j (X, Y ) → (ui (X, Y ) > uj (X, rαi,j (X, Y )))); dac˘a s-a demonstrat par¸tial corectitudinea, atunci condi¸tia de terminare poate fi: ∀X ∀Y (Pi (X, Y ) ∧ Rαi,j (X, Y ) → (ui (X, Y ) > uj (X, rαi,j (X, Y )))); 5 se demonstreaz˘a condi¸tiile de terminare: la trecerea de la un punctul de t˘aietur˘a i la j valorile func¸tiei u descresc, i.e., ui > uj . Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Sistemul axiomatic al lui Hoare Rela¸tii ¸si nota¸tii: deductibilitate: |=; g1, g2, ..., gm |= h are semnifica¸tia: “formula predicativ˘a h (concluzia) este deductiv˘a din formulele predicative g1, g2, ..., gm (premisele)“ ; implica¸tia: ⇒; ′ P ⇒ P ′ are semnifica¸tia: “dac˘a P este satisf˘acut atunci are loc ¸si P “ ; nega¸tia: ¬; ¬b are semnifica¸tia: “nega¸tia expresiei logice b“ ; contribu¸tiile lui Hoare: triplet – precondi¸tie, bloc de instruc¸tiuni, postcondi¸tie; axioma atribuirii pentru: instruc¸tiunea de atribuire; reguli deductive pentru: structura secven¸tial˘a, structura alternativ˘a ¸si structura repetitiv˘a; demonstrarea par¸tial ¸si total corectitudinii, dezvoltarea corect˘a a algoritmilor folosind triplete. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Triplete Hoare {φ} P {ψ} – triplet Hoare, unde: φ este precondi¸tia; ψ este postcondi¸tia; nota¸tia are semnifica¸tia: “dac˘a execu¸tia programului P ˆıncepe dintr-o stare care satisface φ, atunci starea ˆın care se ajunge dup˘a execu¸tia lui P va satisface ψ“; Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Triplete Hoare. Exemple (1) Care dintre urm˘atoarele triplete sunt valide? {x = 5} x := x ∗ 2 {true}; {x = 5} x := x ∗ 2 {x > 0}; {x = 5} x := x ∗ 2 {x = 10 || x = 5}; {x = 5} x := x ∗ 2 {x = 10}; toate tripletele sunt valide; {x = 5} x := x ∗ 2 {x = 10} – cel mai util triplet; {x = 10} – cea mai puternic˘a postcondi¸tie. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Triplete Hoare. Exemple (2) Care dintre urm˘atoarele triplete sunt valide? {x = 5 && y = 10} z := x/y {z < 1}; {x < y && y > 0} z := x/y {z < 1}; {y ̸= 0 && x/y < 1} z := x/y {z < 1}; toate tripletele sunt valide; {y ̸= 0 && x/y < 1} z := x/y {z < 1} – cel mai util triplet; {y ̸= 0 && x/y < 1} – cea mai slab˘a precondi¸tie. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Semantica tripletelor Hoare corectitudine par¸tial˘a nota¸tie: |=par {φ}P{ψ} tripletul {φ}P{ψ} este satisf˘acut relativ la corectitudinea par¸tial˘a, dac˘a pentru orice stare care satisface φ, starea rezultat˘a dup˘a execu¸tia programului P satisface postcondi¸tia ψ, avˆand condi¸tia c˘a programul se termin˘a; nu garanteaz˘a c˘a P se termin˘a; corectitudine total˘a nota¸tie: |=tot {φ}P{ψ} tripletul {φ}P{ψ} este satisf˘acut relativ la corectitudinea total˘a, dac˘a pentru orice stare care satisface φ, programul P se termin˘a, iar starea rezultat˘a dup˘a execu¸tia programului P satisface postcondi¸tia ψ; garanteaz˘a c˘a P se termin˘a. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Par¸tial corectitudine. Reguli deductive axioma atribuirii; regula compunerii secven¸tiale; regula consecin¸tei; regula alternan¸tei; regula itera¸tiei. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Axioma atribuirii |=par {φ(x |e)} x := e {ψ(x )} are semnifica¸tia “dac˘a prin ˆınlocuirea lui x ˆın φ(x ) cu e ob¸tinem o afirma¸tie adev˘arat˘a, atunci dup˘a atribuirea x := e afirma¸tia ψ(x ) va fi adev˘arat˘a.“ Fie tripletul {P} X := Y + 2 {Q} fiind dat Q, care este predicatul pentru care P are loc? pentru orice P astfel ˆıncˆat [P ⇒ ⟨X ← Y + 2⟩ (Q)] Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula compunerii secven¸tiale dac˘a |=par {φ}S {ω} ¸si |=par {ω}T {ψ} atunci |=par {φ} S ; T {ψ}; Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula consecin¸tei dac˘a φ1 ⇒ φ2, |=par {φ2}P{ψ2} ¸si ψ2 ⇒ ψ1 atunci |=par {φ1} P{ψ1} Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula alternan¸tei dac˘a |=par {φ ∧ cond } S {ψ} ¸si |=par {φ ∧ ¬cond }T {ψ} atunci propozi¸tia {φ} IF (cond ) THEN S ELSE T END{ψ} este par¸tial corect˘a ˆın raport cu specifica¸tia (φ, ψ). Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei Care sunt condi¸tiile de realizare ale structurii repetitive while, astfel ˆıncˆat: {φ} WHILE (cond ) DO S END {ψ} presupunem c˘a instruc¸tiunea while se termin˘a , i.e., ¬cond ; ˆın general, nu se cunoa¸ste de cˆate ori se va executa S; consider˘am un predicat η care r˘amˆane satisf˘acut dup˘a execu¸tia S: {η}S {η}	η este un predicat invariant; la ie¸sirea din bucl˘a avem η ∧ ¬cond ; pentru stabilirea post-condi¸tiei, {η} trebuie ales astfel ˆıncˆat [η ∧ ¬cond ⇒ ψ]. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei (cont.) dac˘a |=par {φ ∧ cond }S {ψ} atunci {φ} WHILE (cond ) DO S END {ψ}, cu condi¸tia c˘a exist˘a un predicat invariant η asociat buclei, astfel ˆıncˆat: [φ ⇒ η]	η este satisf˘acut la intrare ˆın bucl˘a; [η ∧ ¬cond ⇒ ψ]	η ob¸tine pe ψ la ie¸sirea din bucl˘a; {cond ∧ η}S {η}	η este satisf˘acut la fiecare itera¸tie. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei. Exemple Demonstrarea par¸tial corectitudinii folosind regula itera¸tiei: Exemplu 1. z = 2N ; Dezvoltarea algoritmilor (par¸tial corec¸ti), folosind regula itera¸tiei: Exemplu 2. R = A ∗ B; Exemplu 3. R = AB . Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei. Exemplu 1. efectuarea calculului: z = 2N : φ : {N ≥ 0} m := 0; y := 1; η : {y = 2m} WHILE (m! = N) DO η : {y = 2m} y := 2 ∗ y ; m := m + 1 END ψ : {y = 2N } trebuie demonstrat c˘a invariantul η este satisf˘acut la intrare ˆın bucl˘a; r˘amˆane satisf˘acut ˆın bucl˘a {η} y := 2 ∗ y ; m := m + 1; {η} ob¸tine post-condi¸tia [η ∧ (m = N) ⇒ (y = 2N )]. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei. Exemplu 2. ˆınmul¸tire prin adun˘ari repetate – “R este A adunat de B ori“: R = A ∗ B: φ : {B ≥ 0} ψ : {R = A ∗ B} ⇒ {B ≥ 0}S {R = A ∗ B} rezolvare (dezvoltarea tripletului): φ : {B ≥ 0} “init R“ WHILE (cond) DO “update R“ END ψ : {R = A ∗ B} regul˘a: se ˆınlocuie¸ste ˆın postcondi¸tia ψ unul din termeni cu o variabil˘a pentru a ob¸tine predicatul invariant η asociat buclei, astfel ˆıncˆat [(η ∧ ¬cond ) ⇒ ψ]; se introduce variabila b ˆın ψ ¸si se determin˘a invariantul η asociat buclei, descris prin: R = A ∗ b; pentru a ob¸tine postcondi¸tia, se alege cond s˘a fie (b ̸= B), unde [(R = A ∗ b) ∧ ¬(b ̸= B) ⇒ (R = A ∗ B)]. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula itera¸tiei. Exemplu 2 (cont.) ˆınmul¸tire prin adun˘ari repetate: invariantul – η: (R = A ∗ b); condi¸tia de execu¸tie a buclei (santinela) – cond: (b ̸= B); pentru a asigura c˘a invariantul este satisf˘acut ini¸tial, se efectueaz˘a ini¸tializarea: R := 0; b := 0; ˆın fiecare itera¸tie: (1) b este incrementat cu 1; (2) R este actualizat, ob¸tinˆand: φ : {B ≥ 0} R := 0; b := 0; WHILE (b ̸= B) DO η : {R = A ∗ b} R :=? ⇒ R := R + A b := b + 1 END ψ : {R = A ∗ B} Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Regula iterativ˘a. Exemplu 3. ridicare la putere prin ˆınmul¸tiri repetate – “R este A ˆınmul¸tit de B ori“: R = AB ; {φ : (A > 0) ∧ (B ≥ 0)} S {ψ : R = AB } rezolvare (dezvoltarea tripletului): pentru ob¸tinerea invariantului se ˆınlocuie¸ste ˆın ψ o constant˘a cu o variabil˘a, ob¸tinˆandu-se: η : R = Ab; φ : {(A > 0) ∧ (B ≥ 0)} R :=?; b := 0; ⇒ R:=1; WHILE (b ̸= B) DO η : {R = Ab} R :=?; ⇒ R := R ∗ A; b := b + 1 END ψ : {R = AB } Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Total corectitudine. Reguli deductive atribuire {φ} X := E {ψ} cu condi¸tia c˘a [φ ⇒⟨X ← E ⟩(ψ)]; compunere {φ} S ; T {ψ} cu condi¸tia c˘a exist˘a R astfel ˆıncˆat {φ} S {R} ¸si {R}T {ψ} ; alternan¸t˘a {φ} IF (cond ) THEN S ELSE T END {ψ} cu condi¸tia c˘a {φ ∧ cond } S {ψ} ¸si {φ ∧ ¬cond }T {ψ} Observa¸tie: similar cu regulile corectitudinii par¸tiale! Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Total corectitudine. Itera¸tia. fie tripletul {φ} WHILE (cond ) DO S END {ψ} cum demonstr˘am c˘a execu¸tia buclei se termin˘a? solu¸tie: se identific˘a o expresie ˆıntreag˘a V astfel ˆıncˆat: valoarea V este non-negativ˘a (i.e., V ≥ 0 ) ¸si valoarea V este strict descresc˘atoare la fiecare itera¸tie, {V = K } S {V < K } V – “invariant al buclei“, expresia ˆı¸si p˘astreaz˘a caracteristicile de la o itera¸tie la alta. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Total corectitudine. Exemplu ridicare la putere prin ˆınmul¸tiri repetate – “R este A ˆınmul¸tit de B ori“: R = AB ; {(A > 0) ∧ (B ≥ 0)} S {R = AB } invariantul buclei este: η : R = Ab ∧ (B ≥ b); φ : {(A > 0) ∧ (B ≥ 0)} R := 1; b := 0; WHILE (b ̸= B) DO	η : R = Ab ∧ (B ≥ b); R := R ∗ A; b := b + 1 END ψ : {R = AB } se define¸ste V – o construc¸tie care variaz˘a la nivelul buclei – descris prin expresia (B − b); V este strict descresc˘atoare la fiecare itera¸tie a buclei, deoarece [(B − (b + 1)) < (B − b)] Cum demonstr˘am c˘a V este o expresie non-negativ˘a? demonstrˆand c˘a (B ≥ b) este un invariant al buclei. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Total corectitudine. Regula itera¸tiei (rezumat) pentru a demonstra |=tot {φ} WHILE (cond ) DO S END {ψ} se identific˘a un predicat invariant η al buclei ¸si o expresie V, invariant˘a la nivelul buclei, astfel ˆıncˆat: η este satisf˘acut ini¸tial [φ ⇒ η]; η determin˘a ob¸tinerea post-condi¸tiei prin condi¸tia de ie¸sire din bucl˘a [(η ∧ ¬cond ) ⇒ ψ]; η se men¸tine satisf˘acut dup˘a execu¸tia blocului S , i.e., {η} S {η}; expresia V este strict descresc˘atoare la fiecare itera¸tie {V = K } S {V < K }; expresia V este ˆıntotdeauna non-negativ˘a; [η ⇒ (V ≥ 0)]. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Pentru examen... metoda lui Floyd: demonstrarea par¸tial corectitudinii, termin˘arii ¸si total corectitudinii ([F0], Cap.1) – probleme: c˘autarea unei valori ˆıntr-un ¸sir ordonat (Seminar 5); determinarea celui mai mare divizor comun a dou˘a numere naturale (Seminar 5); Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Urmeaz˘a... Limbajul Dijkstra Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Bibliografie I [Fre10] M. Frentiu. Verificarea ¸si validarea sistemelor soft. Presa Universitar˘a Clujean˘a, 2010. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Universitatea Babe¸s-Bolyai Cluj-Napoca 15 Aprilie 2025 Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Instruc¸tiuni cu santinel˘a instruc¸tiune cu santinel˘a (engl. guarded command) o list˘a de instruc¸tiuni prefixat˘a de o expresie boolean˘a; dac˘a expresia boolean˘a este ini¸tial evaluat˘a la true atunci lista instruc¸tiunilor este eligibil˘a pentru execu¸tie; sintax˘a: < guarded command >::=< guard >→< guarded list > < guard >::=< boolean expression > < guarded list >::=< statement > {; < statement >} < guarded command set >::= < guarded command > {  < guarded command >} < alternative construct >::= if < guarded command set > fi < repetitive construct >::= do < guarded command set > od < statement >::=< alternative construct > | < repetitive construct > | “other statements′′ Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Non-determinism. Exemple. Exemplu . Maximul a dou˘a numere: if x ≥ y → m := x y ≥ x → m := y fi Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Cea mai slab˘a precondi¸tie Hoare – introduce precondi¸tia suficient˘a astfel ˆıncˆat algoritmul s˘a ob¸tin˘a rezultate corecte; totu¸si nu exist˘a certitudinea c˘a algoritmul se va termina; Dijkstra – introduce precondi¸tia necesar˘a ¸si suficient˘a astfel ˆıncˆat algoritmul s˘a permit˘a ob¸tinerea rezultatului corect; cea mai slab˘a precondi¸tie (engl. weakest precondition, wp) wp(S , R), unde S – mul¸time de instruc¸tiuni; R – predicat (condi¸tie) asupra st˘arii programului; pornind execu¸tia instruc¸tiunilor S dintr-o stare p, execu¸tia se termin˘a ¸si starea ˆın care se ajunge satisface pe R; wp - transform˘a o precondi¸tie ˆıntr-o postcondi¸tie R (engl. predicate transformer). Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Propriet˘a¸tile wp [] 1  legi: Legea miracolului exclus; Legea monotoniei; Legea conjunc¸tiei; Legea disjunc¸tiei. 2  operatori: atribuire (:=); concatenare (;); 3  structuri: secven¸tial˘a; alternativ˘a; repetitiv˘a. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Propriet˘a¸tile wp [] 1  Legea miracolului exclus pentru orice S , pentru toate st˘arile, unde R = FALSE are loc: wp(S , FALSE ) = FALSE ; 2 Legea monotoniei pentru orice S ¸si orice dou˘a post-condi¸tii, astfel ˆıncˆat pentru toate st˘arile P ⇒ Q, pentru toate st˘arile are loc: wp(S , P) ⇒ wp(S , Q); 3 Legea conjunc¸tiei pentru orice S ¸si orice dou˘a post-condi¸tii P ¸si Q, pentru toate st˘arile: wp(S , P) ∧ wp(S , Q) = wp(S , P ∧ Q); 4 Legea disjunc¸tiei pentru orice S determinist ¸si orice post-condi¸tii P ¸si Q, pentru toate st˘arile: (wp(S , P) ∨ wp(S , Q)) ⇒ wp(S , P ∨ Q). Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Operatorul de atribuire ¸si concatenare operatorul de atribuire (:=) semantica expresiei x := E se poate descrie prin: wp(“x := E “, R) = Rx , unde x	E RE – o copie a predicatului R, pentru care, fiecare apari¸tie a variabilei x este ˆınlocuit˘a de E . operatorul de concatenare (;) semantica expresiei de concatenare ; se poate descrie prin: wp(“S 1; S 2“, R) = wp(S 1, wp(S 2, R)); S 1, S 2 – blocuri de instruc¸tiuni; R – postcondi¸tie. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Structura alternativ˘a 1. Fie IF descris˘a prin if B1 → SL1 ...  Bn → SLn fi. Fie BB descris˘a prin (∃i : 1 ≤ i ≤ n : Bi ), atunci wp(IF , R) = (BB ∧ (∀i : 1 ≤ i ≤ n : Bi ⇒ wp(SLi , R))). Substitu¸tia simpl˘a 1. Pentru (∀i : 1 ≤ i ≤ n : (Q ∧ Bi ) ⇒ wp(SLi , R)) pentru toate st˘arile, atunci (Q ∧ BB) ⇒ wp(IF , R) are loc ˆın toate st˘arile. t : SSet → Z , SSet – domeniul st˘arilor; Fie wdec(S , t) – cea mai slab˘a precondi¸tie definit˘a pentru S , pentru care func¸tia t descre¸ste ˆın starea final˘a, fa¸t˘a de cea ini¸tial˘a. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Construc¸tia repetitiv˘a Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Rafinare Date de intrare: X;	pre-condi¸tie: ϕ(X ) Date de ie¸sire: Z;	post-condi¸tie: ψ(X , Z ) program abstract Z : [ϕ, ψ] rafinare ≺ – are semnifica¸tia se rescrie prin... Z = P0 ≺ P1 ≺ P2 ≺ ... ≺ Pn−1 ≺ Pn reguli de rafinare regula atribuirii; regula compunerii secven¸tiale; regula alternan¸tei; regula itera¸tiei. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Rafinare [] Regula atribuirii: [ϕ(v /e), ψ] ≺ v := e Regula compunerii secven¸tiale: [η1, η2] ≺ [η1, γ] [γ, η2] (γ - predicat auxiliar (engl. middle predicate)) Regula alternan¸tei: cond = c1 ∨ c2 ∨ ... ∨ cn; [η1, η2] ≺ if c1 → [η1 ∧ c1, η2] c2 → [η1 ∧ c2, η2] . . . cn → [η1 ∧ cn, η2] fi Regula itera¸tiei: cond = c1 ∨ c2 ∨ ... ∨ cn [η, η ∧ ¬cond ] ≺ do c1 → [η ∧ c1, η ∧ TC ] c2  → [η ∧ c2, η ∧ TC ] . . . cn  → [η ∧ cn , η ∧ TC ] od Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Exemple Rafinare.pdf. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Instrumente software pentru analiza static˘a ¸si analiza dinamic˘a ESC2Java - Extended Static Checker to Java - Seminar 06; JML- Java Modeling Language - Seminar 06; Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Pentru examen... teoria Dijkstra rafinare: defini¸tii reguli; rafinare algoritmi din specifica¸tii (link: Rafinare.pdf) (2 probleme – Seminar 06): ˆımp˘ar¸tire ˆıntreag˘a (cˆat ¸si rest); r˘ad˘acin˘a p˘atrat˘a; Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Bibliografie I [Dij75] E. Dijkstra. Guarded commands, nondeterminacy and formal derivation of programs. CACM, 8(18):453–457, 1975. [Fre10] M. Frentiu. Verificarea ¸si validarea sistemelor soft. Presa Universitar˘a Clujean˘a, 2010. Lector dr. Camelia Chis˘ali¸t˘a-Cre¸tu Sumar Exemplul 1. Împărţire întreagă (cât şi rest) Specificare φ: (x0)  (y>0) ψ: (x=q*y+r)  (0r<y) Fie : (x=q*y+r)  (0r) un predicat intermediar (middle predicate). Prin aplicarea regulii compunerii secvenţiale: Predicatul  devine true prin atribuirea (q,r):= (0,x). Predicatul  este un predicat invariant. Prin aplicarea regulii iteraţiei: 1 Pentru ca DO să se termine, r trebuie să scadă (să descrească); deoarece ry, putem reduce valoarea lui r cu y, adică r←r-y.  trebuie să rămână true şi în post-condiţie, deci este necesar ca: q*y+r = q*y+r-y +y=(q+1)*y + (r-y). Astfel, r şi q îşi modifică valoarea. Exemplul 2. Rădăcină pătrată r = [sqrt(n)]; se ştie că r ≤ sqrt(n) < r+1; post-condiţia este r2 ≤ n < (r+1)2; Specificare: φ:	n>1 ψ:	r2 ≤ n < (r+1)2 A0 Subalgoritmul RadPatrata(n, r) este: [φ, ψ] endRadPatrata Rescriem predicatul de ieşire în forma:	(r2 <= n < q2 )  (q=r+1). Folosim predicatul intermediar (middle predicate)  ::= (r2 ≤ n < q2). A1 Subalgoritmul RadPatrata (n, r) este: [φ, ] [,] sfRadPatrata Predicatul  devine true în A1 pentru r=0 şi q=n+1. A2 Subalgoritmul RadPatrata (n, r) este: (q,r) ← (n+1,0) [,  (q=r+1)] {} sfRadPatrata Pentru A2 se pote aplica regula iteraţiei. A3 Subalgoritmul RadPatrata (n,r) este: (q,r) ← (n+1,0) DO q≠r+1 -> [ q≠r+1,  TC] OD sfRadPatrata Pentru ca DO să se termine, este necesar ca r sau q să descrească; q-r trebuie să devină 1 la final. 2 Expresia p=(q+r)/2 satisface condiţia r<p<q; iar (q-r) se actualizează prin modificarea intervalului [r,q] la [r,p] sau [p,q]. Dar  trebuie să rămână true în post-condiţie, deci este necesar ca: dacă (p2≤n) atunci atribuirea r ← p satisface invariantul ; dacă (p2>n) atunci atribuirea q ← p satisfice invariantul . A4 Subalgoritmul RadPatrata (n,r) este: (q,r) ← (n+1,0) DO q>r+1 -> p← (q+r)/2 IF p2n  r←p p2<n q←p FI OD sfRadPatrata Exemplul 3. Înmulţire prin adunări repetate Specificare: φ : (x0)  (y0) ψ : z = x*y A0 Subalgoritmul Produs(x,y,z) este: [φ, ψ] sfProdus Post-condiţia ψ este satisfacută dacă se utilizează un predicat intermediar : ::= (z+u*v = x*y )  (v≥0). De asemenea, se aplică regula compunerii secvenţiale: A1 Subalgoritmul Produs (x,y,z) este: [φ, ] [,ψ] sfProdus Programul abstract A1 devine true prin atribuirea	(u,v,z) ← (x,y,0). A2 Subalgoritmul Produs (x,y,z) este: (z,u,v) ← (0,x,y) [,ψ] sfProdus Programul abstract [,ψ] se poate rescrie prin [,  (v=0)], ceea ce permite aplicarea regulii iteraţiei: A3 3 Pentru ca DO să se termine, este necesar să micşorăm pe v: prima posibilitate: vv-1; dar  trebuie satisfăcut şi în postcondiţie, deci este necesar ca: z+u*v = z + u + u*(v-1) şi atribuirea zz+u trebuie să aibă loc; a doua posibilitate: vv/2, dacă v este par; dar  trebuie satisfăcut şi în post-condiţie, deci este necesar ca: z+u*v = z + (u*2)* v/2 şi atribuirea (u,v):=(u+u, v/2)trebuie realizată. A4 Exemplul 4. Cel mai mare divizor comun al două numere naturale Specificare: φ : x>0, y > 0 ψ : d=cmmmdc(x,y) A0 Subalgoritmul CMMDC(x,y,d) este: [φ, ψ] sfCMMDC Predicatul intermediar ::= cmmdc(d,s)=cmmdc(x,y) este utilizat pentru a aplica regula compunerii secvenţiale. A1 Subalgoritmul CMMDC(x,y,d) este: [φ, ] [,ψ] sfCMMDC Programul abstract A1 devine true prin atribuirea (d,s)=(x,y), folosind regula atribuirii: A2 Subalgoritmul CMMDC(x,y,d) este: (d,s) ← (x,y) [,ψ] sfCMMDC Dacă d=s atunci  implică pe ψ. Astfel, se poate scrie următorul program abstract: A3 Subalgoritmul CMMDC(x,y,d) este: (d,s) ← (x,y) [,  (d=s)] sfCMMDC Prin aplicarea regulii iteraţiei se obţine: A2 Subalgoritmul CMMDC(x,y,d) este: 4 (d,s) ← (x,y) DO d≠s  [d≠s,  TC] OD sfCMMDC Pentru d≠s avem condiţiile d>s şi d<s. Se ştie că pentru d>s avem cmmdc(d,s)=cmmdc(d-s,s) şi atribuirea d ←d-s păstrează predicatul  invariant. A3 Subalgoritmul CMMDC(x,y,d) este: (d,s) ← (x,y) DO d≠s  IF d>s  d←d-s d<s  s←s-d FI OD CMMDCs sfCMMDC Example 5. Raising a number to a power by multiplications Compute z = xy by multiple multiplications Specification: The predicate  ::=	(z*uv = xy )  (v≥0) implies ψ if v=0. Using it as a middle predicate we can apply the sequential composition rule: The  becomes true if (z,u,v) = (1,x,y) (in the first abstract program): The predicate  is invariant, we can apply the iteration rule. For the DO to terminate we must decrease v: First possibility: vv-1. But  should hold also in the post-condition, so we must have:	z*uv =	z * u*uv-1. So also the assignment (z,v)←(z*u,v-1) is needed. 5 Second possibility: vv/2, if v is even. . But  should hold also in the post-condition, so we must have: z*uv = z* (u*u)v/2 .So also the assignment (u,v) ← (u*u,v/2) is needed. Example 6. Insertion A = (a1, a2,...,an) an array with n components ordered in decrease order and x a value. Insert x in A such that A remains ordered and A containes a new value x. The predicate ORD is define by: ORD(n,A) ::= ( i,j: 1i,jn, ij  aiaj) Specification: φ::= ORD(n,A)  (n natural) ψ ::=ORD(n+1,A) and (A contains the initial elements and a new element x) There are two possibilities (x<an and n0) or ( xan or (n=0) ): A doua propoziţie nestandard se rafinează printr-o atribuire 6 Să notăm prin η următorul predicat ORD(n,A)  [ (x<a1)  (p=1)  (ap-1x<ap)  (1<pn)] Care este o postconditie pentru o problemă de căutare şi să folosim regula secvenţei. Ajungem la: Vom satisface postcondiţia η în urma apelului subalgoritmului de căutare, astfel că ajungem la: After the search we know that x is between ap-1 and ap , so x must be inserted on position p, so we have a'i+1 ← ai, for i=n,n-1,...,p and	a'p ← x. n'←n+1 We use the assignments: i←n; DO ip  ai+1←ai i←i-1 OD 7 Another refinement regardi8nt the nn+1 assignment: Example 7. InsertionSort Let A = (a1, a2,...,an) be an array with n integer components. The problem requires to order the components of A. Specification φ::= n2, A has integer components ψ ::= ORD(n,A) and A has the same elements as in the precondition We use the middle predicate ORD(k,A) and apply the sequential composition rule: The first abstract program may be refined to an assignment Wer can rewrite the remained abstract program remarking that ORD(k,A)  (k=n)  ψ We now can apply the iteration rule 8 For the DO to terminate we must increase k: First possibility: kk+1. But (k)::=ORD(k,A) invariant – by modifying k by k+1 the predicate (k|k+1) must be true. The abstract program [ (k<n)  ORD(k,A), ORD(k+1,A)] Corresponds to the following subproblem: If ORD(k,A) (the first k elements in A are orderes) then modify the A such that the first k+1 elements to be ordered. This can be achieve by calling a subalgorithn that inserts the ak+1 component such that after insertion the postcondition ORD(k+1,A) is true. 9 CURS 09. RAPORTAREA BUG-URILOR Verificarea și validarea sistemelor soft [29 Aprilie 2025] Lector dr. Camelia Chisăliţă-Creţu Universitatea Babeş-Bolyai Conţinut Ciclul de viaţă al unui bug Etape ale ciclului de viaţă al unui bug Abordări Principii şi reguli generale de raportare a bugurilor RIMGEA Definiţie. Componente Aplicabilitate. Obiective Reprezentare conceptuală Replicate Isolate Maximize Generalize Externalize Neutral tone Tipuri de bug-uri Bug de implementare Bug de proiectare Exemple Clasificarea bug-urilor pe baza atributelor de calitate Bibliografie CICLUL DE VIAŢĂ AL UNUI BUG Etape ale ciclului de viaţă al unui bug. Abordări Principii şi reguli generale de raportare a bugurilor stări ale unui bug stabilite de tester: New, Pending Testing, Retest, Reopened, Verified, Closed; stări ale unui bug stabilite de programator: Assigned, Open (Duplicate, Rejected, Deffered, Not a Bug), Fixed; sursa: [] Principii generale de raportare a unui bug principii de raportare a unui bug [Patton2005]: se raportează imediat după identificare; se realizează o descriere a bug-ului; nu se fac aprecieri subiective referitoare la bug-ul raportat; se urmărește starea bug-urilor (corectat sau nu) raportate anterior, i.e., se folosește un sistem de monitorizare a bugurilor (engl. bug tracking system); Principii şi reguli generale de raportare a unui bug Izolarea și reproducerea bug-urilor [Patton2005]: fii suspicios – nu te baza pe ceea ce au făcut sau spus alții, fii consecvent și riguros; acordă atenție timpului – nu ignora durata de realizare a unei operații (e.g., momentul zilei, utilizarea unui device care lucrează încet, viteza de prelucrare a datelor, etc.); acordă atenție domeniilor de valori – valori limită, volum de date mare, alocare și accesare a memoriei; starea unui bug – poate fi mascată de încheierea aparent cu succes a unei operații; un bug poate fi evidențiat de execuția într-o anumită ordine a pașilor de execuție și nu de momentul în care a apărut; dependențele existente între resurse utilizatele și interacțiunea cu memoria, partajarea rețelei și a componentelor hard; componentele hard nu trebuie ignorate, acestea se pot degrada și reacționează imprevizibil. RIMGEA Definiţie. Componente Aplicabilitate. Obiective Reprezentare conceptuală Replicate. Isolate. Maximize. Generalize. Externalize. Clear communication Bug de implementare. Bug de proiectare Exemple RIMGEA. Definiţie. Componente RIMGEA [] grup de reguli utilizat pentru investigarea şi îmbunătăţirea descrierii unui bug; componente Replicate – reproducerea bug-ului; Isolate – izolarea bug-ului; Maximize – maximizarea bug-ului; Generalize – generalizarea bug-ului; Externalize – externalizarea bug-ului; And say it clear and dispassionately – atitudine neutră la raportarea bug-ului. RIMGEA. Aplicabilitate tehnica RIMGEA se aplică pentru la raportarea: bug-urilor de implementare programul funcţionează într-o manieră pe care proiectantul şi programatorul o consideră nepotrivită, inadecvată; pune în evidenţă o deficienţă, i.e., greşeală, de scriere sau implementare a soluţiei adoptate; A program with a coding error will behave in a way the designer, programmer or tester will agree is improper. bug-urilor de proiectare programul funcţionează conform proiectării şi implementării; pune în evidenţă o deficienţă, i.e., greşeală, în abordarea modului de rezolvare; A program with a design error behaves in a way the designer and programmer intended. RIMGEA. Obiective obiective: la raportarea bug-urilor de implementare elaborarea unui raport care să conţină o listă minimală de paşi care să demonstreze cu certitudine existenţa unui bug în codul sursă; la raportarea bug-urilor de proiectare elaborarea unui raport care să precizeze clar care este aspectul de proiectare defecturos şi felul în care acesta reduce nejustificat calitatea softului. RIMGEA. Reprezentare conceptuală sursa: [] RIMGEA. Replicate reproducerea (engl. replicate): activitate de testare prin care se identifică ce este necesar pentru ca bug-ul să apară de fiecare dată când se doreşte manifestarea lui; pune în evidenţă şi cazurile în care bug-ul nu poate fi reprodus la cerere şi descrie factorii care ar indică posibilitatea apariţiei acestuia. RIMGEA. Isolate izolarea (engl. isolate): activitate de testare prin care se identifică cea mai scurtă secvenţă de paşi necesară pentru ca bug-ul să fie reprodus şi raportat într-o formă clară, astfel încât să se pună în evidenţă defecţiunea apărută; un raport al unui bug prezintă o singură defecţiune a produsului soft. RIMGEA. Maximize maximizarea (engl. maximize): activitate de testare prin care se identifică cele mai importante (grave) consecinţe ale existenţei bug-ului; se recomandă prezentarea consecinţelor frecvent întâlnite, determinate de prezenţa bug-ului, în cel mai des utilizate configuraţii de rulare, prelucrând date reale. RIMGEA. Generalize generalizarea (engl. generalize): activitate de testare prin care se identifică şi se clasifică situaţiile în care acest bug va cauza o defecţiune; RIMGEA. Externalize externalizarea (engl. externalize): activitate de testare prin care se identifică consecinţele prezenţei bug-ului din perspective diferite: utilizatorul propriu-zis: Cum este afectat factorul uman? beneficiarul, clientul: Cum este afectată reputaţia companiei clientului sau business-ul acestuia? dezvoltator, furnizor: Cum este afectată reputaţia companiei dezvoltatorului sau business-ul acestuia? terţ, competitor: Cât de important este acest bug? RIMGEA. And use a constructive communication comunicare clară şi constructivă/neutră (engl. and say it clearly and dispassionately, neutral tone): raportul unui bug conţine date concrete sau speculative într-o manieră constructivă, imparţială şi corectă; raportul unui bug nu conţine nu se critică, nu se insultă persoane; nu se includ aspecte irelevante, care pot afecta alte persoane, doar dacă ele sunt esenţiale pentru descrierea problemei şi condiţiilor care determină defecţiunea. Bug de implementare vs. Bug de proiectare RIMGEA. Exemple produs software testat: Apache Open Office: ; tool pentru managementul bug-urilor Bugzilla: ; configuraţie de rulare folosită la testare şi identificarea bug-urilor: sistem de operare: Windows 10 Home, 64-bit; procesor: Intel Core i5, 1.7GHz; memorie RAM: 4Gb; versiune Open Office Writer: 4.1.3. Open Office Writer. Bug-uri investigate bug-uri de implementare: Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Bug 2. inconsistenţă de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); bug-uri de proiectare: Bug 3. inconsistenţă de proiectare: Issue 126371 – Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Open Office Writer. Bug 1 (1) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Replicate – reproducerea bug-ului; Isolate – izolarea bug-ului; Maximize – maximizarea bug-ului; Generalize – generalizarea bug-ului; Externalize – externalizarea bug-ului; And say it clear and dispassionately – atitudine neutră la raportarea bug-ului. Open Office Writer. Bug 1 (2) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Replicate – reproducerea bug-ului; Scenariu A: Size curent: 20; fereastra principală setare Size: 10.23: fereatra principală: Size = 10.1; fereastra Format: Size = 10.2; Scenariu B: Size curent: 20; fereastra Format setare Size: 10.23: fereatra principală: Size = 10.1; fereastra Format: Size = 10.2; Open Office Writer. Bug 1 (3) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Isolate – izolarea bug-ului; identificarea celei mai scurte secvenţe de paşi prin care se evidenţiază bug-ul; E.g., Scenariu A, Scenariu B; Open Office Writer. Bug 1 (4) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Maximize – maximizarea bug-ului; maximizarea impactului negativ: impact negativ = inconsistenţa dintre cele două scenarii; întrebări: unde este aplicat algoritmul de rotunjire? câţi/care sunt algoritmii de rotunjire folosiţi? eroarea de aproximare este mai puţin importantă faţă de inconsistenţa evidenţiată de scenariile A şi B ---> variabila Font Size are două valori simultan 10.1 şi 10.2; Open Office Writer. Bug 1 (5) Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Generalize – generalizarea bug-ului; toate platformele au acelaşi bug: eroarea de aproximare raportată este mică; puţini utilizatori folosesc size cu zecimale. Bug 1. eroare de rotunjire: Issue 120368 - Font size with decimal values don't have a consistent (); Externalize – externalizarea bug-ului; utilizatorul identifică eroarea de aproximare ---> utilizatorul devine suspicios cu privire corectitudinea aproximărilor efectuate de OO Writer; dacă scenariul B oferă o aproximare corectă din perspectiva utilizatorului, atunci experienţa ca utilizator îi va fi afectată ---> va trebui să îşi amintească de fiecare dată când setează Font Size că Scenariul A nu este potrivit şi să îl evite; modul de abordare a acestor probleme de aproximare de către produsele concurente, e.g., Microsoft Office Word; Bug 2. inconsistenţă de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate – reproducerea bug-ului; Isolate – izolarea bug-ului; Maximize – maximizarea bug-ului; Generalize – generalizarea bug-ului; Externalize – externalizarea bug-ului; And say it clear and dispassionately – atitudine neutră la raportarea bug-ului; Open Office Writer. Bug 2 (2) Bug 2. inconsistenţă de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate – reproducerea bug-ului; Open Office Writer. Bug 2 (3) Bug 2. inconsistenţă de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Replicate – reproducerea bug-ului; Bug 2. inconsistenţă de setare: Issue 127562 - Inconsistency on Header Height max. value when enabled first time (); Isolate – izolarea bug-ului; Scenariu A: indică cea mai scurtă secvenţă de paşi prin care bug-ul este evidenţiat; Scenariu B: indică faptul că bug-ul apare indiferent de formatul de pagina ales iniţial, i.e., A4 (scenariu A) sau Letter şi apoi A4 (scenariu B); indică faptul că bug-ul apare la prima activare a opţiunii Header Height; Bug 3. inconsistenţă de proiectare: Issue 126371 – Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Se va investiga dacă OO Writer ar trebui să aibă un anumit comportament şi NU dacă acest comportament este corect sau nu. Replicate – reproducerea bug-ului; Isolate – izolarea bug-ului; Maximize – maximizarea bug-ului; Generalize – generalizarea bug-ului; Externalize – externalizarea bug-ului; And say it clear and dispassionately – atitudine neutră la raportarea bug-ului; Open Office Writer. Bug 3 (2) Bug 3. inconsistenţă de proiectare: Issue 126371 – Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Replicate – reproducerea bug-ului; butonul Vertical Text: disponibil când Asian Language Support din meniul Tools Options | Language Settings | Languages este activat ---> scrierea de sus în jos, pe verticală este posibilă; Open Office Writer. Bug 3 (3) Bug 3. inconsistenţă de proiectare: Issue 126371 – Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Isolate – izolarea bug-ului; Scenariu A Asian Language Support nu este activat; se încearcă adăugarea butonului Vertical Text din Drawing toolbar ---> butonul apare şi dispare imediat; dacă butonul este deja selectat, el nu apare în Drawing toolbar; Scenariu B Asian Language Support este activat; se încearcă eliminarea butonulului Vertical Text din Drawing toolbar ---> butonul dispare şi apare imediat; dacă butonul este deja deselectat, el apare totuşi în Drawing toolbar; Open Office Writer. Bug 3 (4) Bug 3. inconsistenţă de proiectare: Issue 126371 – Disappearing Vertical Text button in Drawing Toolbar in Writer v.4.1.1 (); Externalize – externalizarea bug-ului; impactul asupra utilizatorului: calitatea produsului este afectată, utilizatorul devine frustrat pentru eşecul de adăugare sau eliminare a butonului Vertical Text din Drawing toolbar; alte produse similare, e.g., Microsoft Office Word, nu constrâng utilizarea butonului Vertical Text doar în prezenţa unor setări specifice legate de limbă; calitatea produsului este afectată prin forţarea utilizatorului să îşi aducă aminte să modifice setările de limbă pentru a realiza scrierea unui text vertical, după care să revină la setările de limbă iniţiale; dacă utilizatorul uită să revină la setările iniţiale, acesta poate întâmpina dificultăţi şi la alte configurări care sunt afectate de anumite setări de limbă ---> utilizatorul nu beneficiază de caracteristicile produsului în maniera dorită; CLASIFICAREA BUG-URILOR PE BAZA ATRIBUTELOR DE CALITATE by Claudiu Draghia Funcţionalitate - Functionality bug; Lasă impresia unei funcţionări normale: most human like shape; curious with funny eyes; Impact vizual iniţial pozitiv: Dressed to impress. source [] Testabilitate - CHAOS UI; Impresionează şi se deghizează: Confident eyes; Camouflaged; Controllability; Heterogeneity; Automatability; Observability; Separation of concerns; Understandability; Isolateability.	source [] Performanţă - HaSo; Bug hibrid: Hardware; Software; source [Draghia2023] Securitate – CIAn; bug dezastruos; Confidentiality; Integrity; Availability; non-repudiation. source [Draghia2023] Investigarea bug-urilor source [Draghia2023] Pentru examen... Ciclul de viaţă al unui bug: Cele două variante discutate la curs (simplu şi detaliat); RIMGEA descrierea semnificaţiei acronimului: replicate, isolate, maximize, generalize, externalize, communicate it clear; Tipuri de bug-uri: Coding bug; Design bug; Coding bug vs design bug. A bug story Termen: Vineri, 16 Mai 2025, orele 20:00; Echipe: max. 3 studenţi/echipă, i.e., echipe de forma (A, B, C), (A, B); se acordă 2 puncte pentru activitatea Bug Story; dacă bug-ul este se regăseşte printre primele 3 cele mai votate bug-uri, se acordă suplimentar 1 punct. Paşi de rezolvare: Pas 1: alegerea unui produs soft; alegeţi un produs soft, e.g.: MS Office Word, Google Mail, Google Sheets, OO Writer, proiectul dezvoltat la disciplina Proiect Colectiv, etc; se va realiza o scurtă descriere a produsului soft (1-2 paragrafe) și se va include în document nou creat. Pas 2: descrierea poveştii unui bug asociat softului ales; creaţi/imaginaţi/identificaţi un bug şi realizaţi o descriere a acestuia (text, 1-2 paragrafe), atribuindu-i diferite însuşiri/caracteristici de manifestare asupra produsului soft (vezi însuşirile bugurilor descrise în secţiunea Clasificarea bug-urilor în Curs10. Raportea bug-urilor); furnizați și o descriere grafică expresivă (desen, imagine) a bugului, alegeți un nume sugestiv; descrierea/povestea bugului va fi inclusă în fişierul creat la Pasul 1; în descrierea grafică se pot folosi atât insecte, păsări sau animale, dar şi personaje (negative sau nu) din literatura universală, filme, desene animate, etc. Paşi de rezolvare: Pas 3: postarea poveştii bugului; fişierul finalizat la Pasul 2 se încarcă în channel-ul #BugStories în cadrul unei postări (pentru a putea fi votat ulterior); fişierul va conţine şi detaliile referitoare la componenţa echipei care a dezvoltat bug-ul (nume student, grupă); Pas 4: votarea celei mai interesante povești/descrieri postate; voturile se acordă individual, de către fiecare student înscris la VVSS care a participat sau nu la elaborarea poveştii unui bug; un student poate vota mai multe povești postate; studenţii se vor asigura că au acordat votul/rile lor până în Vineri, 16 Mai 2025, orele 20:00; pentru acordarea punctului suplimentar se vor lua în considerare doar voturile exprimate în channel-ul #BugStories prin react-ul Like (	); ca feedback, se pot adăuga şi alte reactions la postarea poveştii unui bug, inclusiv mesaj scris în postarea asociată descrierii bug-ului. Referințe bibliografice [ISTQBCertification2025] ISTQB Exam Certification,  . [Patton2005] R. Patton, Software Testing, Sams Publishing, 2005. [BBST2008] Black-Box Software Testing (BBST), Bug Advocacy, . [Altom2016] Levente Balint, BLOG : RIMGEN, How Well Do you Advocate For Your Bugs?, . [Draghia2023] Claudiu Draghia, .